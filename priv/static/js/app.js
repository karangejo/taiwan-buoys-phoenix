/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/js/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../deps/phoenix/priv/static/phoenix.js":
/*!**********************************************!*\
  !*** ../deps/phoenix/priv/static/phoenix.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var Phoenix = (() => {\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n\n  var __export = (target, all) => {\n    for (var name in all) __defProp(target, name, {\n      get: all[name],\n      enumerable: true\n    });\n  };\n\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n        get: () => from[key],\n        enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n      });\n    }\n\n    return to;\n  };\n\n  var __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n    value: true\n  }), mod); // js/phoenix/index.js\n\n\n  var phoenix_exports = {};\n\n  __export(phoenix_exports, {\n    Channel: () => Channel,\n    LongPoll: () => LongPoll,\n    Presence: () => Presence,\n    Serializer: () => serializer_default,\n    Socket: () => Socket\n  }); // js/phoenix/utils.js\n\n\n  var closure = value => {\n    if (typeof value === \"function\") {\n      return value;\n    } else {\n      let closure2 = function () {\n        return value;\n      };\n\n      return closure2;\n    }\n  }; // js/phoenix/constants.js\n\n\n  var globalSelf = typeof self !== \"undefined\" ? self : null;\n  var phxWindow = typeof window !== \"undefined\" ? window : null;\n  var global = globalSelf || phxWindow || global;\n  var DEFAULT_VSN = \"2.0.0\";\n  var SOCKET_STATES = {\n    connecting: 0,\n    open: 1,\n    closing: 2,\n    closed: 3\n  };\n  var DEFAULT_TIMEOUT = 1e4;\n  var WS_CLOSE_NORMAL = 1e3;\n  var CHANNEL_STATES = {\n    closed: \"closed\",\n    errored: \"errored\",\n    joined: \"joined\",\n    joining: \"joining\",\n    leaving: \"leaving\"\n  };\n  var CHANNEL_EVENTS = {\n    close: \"phx_close\",\n    error: \"phx_error\",\n    join: \"phx_join\",\n    reply: \"phx_reply\",\n    leave: \"phx_leave\"\n  };\n  var TRANSPORTS = {\n    longpoll: \"longpoll\",\n    websocket: \"websocket\"\n  };\n  var XHR_STATES = {\n    complete: 4\n  }; // js/phoenix/push.js\n\n  var Push = class {\n    constructor(channel, event, payload, timeout) {\n      this.channel = channel;\n      this.event = event;\n\n      this.payload = payload || function () {\n        return {};\n      };\n\n      this.receivedResp = null;\n      this.timeout = timeout;\n      this.timeoutTimer = null;\n      this.recHooks = [];\n      this.sent = false;\n    }\n\n    resend(timeout) {\n      this.timeout = timeout;\n      this.reset();\n      this.send();\n    }\n\n    send() {\n      if (this.hasReceived(\"timeout\")) {\n        return;\n      }\n\n      this.startTimeout();\n      this.sent = true;\n      this.channel.socket.push({\n        topic: this.channel.topic,\n        event: this.event,\n        payload: this.payload(),\n        ref: this.ref,\n        join_ref: this.channel.joinRef()\n      });\n    }\n\n    receive(status, callback) {\n      if (this.hasReceived(status)) {\n        callback(this.receivedResp.response);\n      }\n\n      this.recHooks.push({\n        status,\n        callback\n      });\n      return this;\n    }\n\n    reset() {\n      this.cancelRefEvent();\n      this.ref = null;\n      this.refEvent = null;\n      this.receivedResp = null;\n      this.sent = false;\n    }\n\n    matchReceive({\n      status,\n      response,\n      _ref\n    }) {\n      this.recHooks.filter(h => h.status === status).forEach(h => h.callback(response));\n    }\n\n    cancelRefEvent() {\n      if (!this.refEvent) {\n        return;\n      }\n\n      this.channel.off(this.refEvent);\n    }\n\n    cancelTimeout() {\n      clearTimeout(this.timeoutTimer);\n      this.timeoutTimer = null;\n    }\n\n    startTimeout() {\n      if (this.timeoutTimer) {\n        this.cancelTimeout();\n      }\n\n      this.ref = this.channel.socket.makeRef();\n      this.refEvent = this.channel.replyEventName(this.ref);\n      this.channel.on(this.refEvent, payload => {\n        this.cancelRefEvent();\n        this.cancelTimeout();\n        this.receivedResp = payload;\n        this.matchReceive(payload);\n      });\n      this.timeoutTimer = setTimeout(() => {\n        this.trigger(\"timeout\", {});\n      }, this.timeout);\n    }\n\n    hasReceived(status) {\n      return this.receivedResp && this.receivedResp.status === status;\n    }\n\n    trigger(status, response) {\n      this.channel.trigger(this.refEvent, {\n        status,\n        response\n      });\n    }\n\n  }; // js/phoenix/timer.js\n\n  var Timer = class {\n    constructor(callback, timerCalc) {\n      this.callback = callback;\n      this.timerCalc = timerCalc;\n      this.timer = null;\n      this.tries = 0;\n    }\n\n    reset() {\n      this.tries = 0;\n      clearTimeout(this.timer);\n    }\n\n    scheduleTimeout() {\n      clearTimeout(this.timer);\n      this.timer = setTimeout(() => {\n        this.tries = this.tries + 1;\n        this.callback();\n      }, this.timerCalc(this.tries + 1));\n    }\n\n  }; // js/phoenix/channel.js\n\n  var Channel = class {\n    constructor(topic, params, socket) {\n      this.state = CHANNEL_STATES.closed;\n      this.topic = topic;\n      this.params = closure(params || {});\n      this.socket = socket;\n      this.bindings = [];\n      this.bindingRef = 0;\n      this.timeout = this.socket.timeout;\n      this.joinedOnce = false;\n      this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n      this.pushBuffer = [];\n      this.stateChangeRefs = [];\n      this.rejoinTimer = new Timer(() => {\n        if (this.socket.isConnected()) {\n          this.rejoin();\n        }\n      }, this.socket.rejoinAfterMs);\n      this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));\n      this.stateChangeRefs.push(this.socket.onOpen(() => {\n        this.rejoinTimer.reset();\n\n        if (this.isErrored()) {\n          this.rejoin();\n        }\n      }));\n      this.joinPush.receive(\"ok\", () => {\n        this.state = CHANNEL_STATES.joined;\n        this.rejoinTimer.reset();\n        this.pushBuffer.forEach(pushEvent => pushEvent.send());\n        this.pushBuffer = [];\n      });\n      this.joinPush.receive(\"error\", () => {\n        this.state = CHANNEL_STATES.errored;\n\n        if (this.socket.isConnected()) {\n          this.rejoinTimer.scheduleTimeout();\n        }\n      });\n      this.onClose(() => {\n        this.rejoinTimer.reset();\n        if (this.socket.hasLogger()) this.socket.log(\"channel\", `close ${this.topic} ${this.joinRef()}`);\n        this.state = CHANNEL_STATES.closed;\n        this.socket.remove(this);\n      });\n      this.onError(reason => {\n        if (this.socket.hasLogger()) this.socket.log(\"channel\", `error ${this.topic}`, reason);\n\n        if (this.isJoining()) {\n          this.joinPush.reset();\n        }\n\n        this.state = CHANNEL_STATES.errored;\n\n        if (this.socket.isConnected()) {\n          this.rejoinTimer.scheduleTimeout();\n        }\n      });\n      this.joinPush.receive(\"timeout\", () => {\n        if (this.socket.hasLogger()) this.socket.log(\"channel\", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);\n        let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);\n        leavePush.send();\n        this.state = CHANNEL_STATES.errored;\n        this.joinPush.reset();\n\n        if (this.socket.isConnected()) {\n          this.rejoinTimer.scheduleTimeout();\n        }\n      });\n      this.on(CHANNEL_EVENTS.reply, (payload, ref) => {\n        this.trigger(this.replyEventName(ref), payload);\n      });\n    }\n\n    join(timeout = this.timeout) {\n      if (this.joinedOnce) {\n        throw new Error(\"tried to join multiple times. 'join' can only be called a single time per channel instance\");\n      } else {\n        this.timeout = timeout;\n        this.joinedOnce = true;\n        this.rejoin();\n        return this.joinPush;\n      }\n    }\n\n    onClose(callback) {\n      this.on(CHANNEL_EVENTS.close, callback);\n    }\n\n    onError(callback) {\n      return this.on(CHANNEL_EVENTS.error, reason => callback(reason));\n    }\n\n    on(event, callback) {\n      let ref = this.bindingRef++;\n      this.bindings.push({\n        event,\n        ref,\n        callback\n      });\n      return ref;\n    }\n\n    off(event, ref) {\n      this.bindings = this.bindings.filter(bind => {\n        return !(bind.event === event && (typeof ref === \"undefined\" || ref === bind.ref));\n      });\n    }\n\n    canPush() {\n      return this.socket.isConnected() && this.isJoined();\n    }\n\n    push(event, payload, timeout = this.timeout) {\n      payload = payload || {};\n\n      if (!this.joinedOnce) {\n        throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);\n      }\n\n      let pushEvent = new Push(this, event, function () {\n        return payload;\n      }, timeout);\n\n      if (this.canPush()) {\n        pushEvent.send();\n      } else {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n      }\n\n      return pushEvent;\n    }\n\n    leave(timeout = this.timeout) {\n      this.rejoinTimer.reset();\n      this.joinPush.cancelTimeout();\n      this.state = CHANNEL_STATES.leaving;\n\n      let onClose = () => {\n        if (this.socket.hasLogger()) this.socket.log(\"channel\", `leave ${this.topic}`);\n        this.trigger(CHANNEL_EVENTS.close, \"leave\");\n      };\n\n      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);\n      leavePush.receive(\"ok\", () => onClose()).receive(\"timeout\", () => onClose());\n      leavePush.send();\n\n      if (!this.canPush()) {\n        leavePush.trigger(\"ok\", {});\n      }\n\n      return leavePush;\n    }\n\n    onMessage(_event, payload, _ref) {\n      return payload;\n    }\n\n    isMember(topic, event, payload, joinRef) {\n      if (this.topic !== topic) {\n        return false;\n      }\n\n      if (joinRef && joinRef !== this.joinRef()) {\n        if (this.socket.hasLogger()) this.socket.log(\"channel\", \"dropping outdated message\", {\n          topic,\n          event,\n          payload,\n          joinRef\n        });\n        return false;\n      } else {\n        return true;\n      }\n    }\n\n    joinRef() {\n      return this.joinPush.ref;\n    }\n\n    rejoin(timeout = this.timeout) {\n      if (this.isLeaving()) {\n        return;\n      }\n\n      this.socket.leaveOpenTopic(this.topic);\n      this.state = CHANNEL_STATES.joining;\n      this.joinPush.resend(timeout);\n    }\n\n    trigger(event, payload, ref, joinRef) {\n      let handledPayload = this.onMessage(event, payload, ref, joinRef);\n\n      if (payload && !handledPayload) {\n        throw new Error(\"channel onMessage callbacks must return the payload, modified or unmodified\");\n      }\n\n      let eventBindings = this.bindings.filter(bind => bind.event === event);\n\n      for (let i = 0; i < eventBindings.length; i++) {\n        let bind = eventBindings[i];\n        bind.callback(handledPayload, ref, joinRef || this.joinRef());\n      }\n    }\n\n    replyEventName(ref) {\n      return `chan_reply_${ref}`;\n    }\n\n    isClosed() {\n      return this.state === CHANNEL_STATES.closed;\n    }\n\n    isErrored() {\n      return this.state === CHANNEL_STATES.errored;\n    }\n\n    isJoined() {\n      return this.state === CHANNEL_STATES.joined;\n    }\n\n    isJoining() {\n      return this.state === CHANNEL_STATES.joining;\n    }\n\n    isLeaving() {\n      return this.state === CHANNEL_STATES.leaving;\n    }\n\n  }; // js/phoenix/ajax.js\n\n  var Ajax = class {\n    static request(method, endPoint, accept, body, timeout, ontimeout, callback) {\n      if (global.XDomainRequest) {\n        let req = new global.XDomainRequest();\n        return this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\n      } else {\n        let req = new global.XMLHttpRequest();\n        return this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);\n      }\n    }\n\n    static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\n      req.timeout = timeout;\n      req.open(method, endPoint);\n\n      req.onload = () => {\n        let response = this.parseJSON(req.responseText);\n        callback && callback(response);\n      };\n\n      if (ontimeout) {\n        req.ontimeout = ontimeout;\n      }\n\n      req.onprogress = () => {};\n\n      req.send(body);\n      return req;\n    }\n\n    static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\n      req.open(method, endPoint, true);\n      req.timeout = timeout;\n      req.setRequestHeader(\"Content-Type\", accept);\n\n      req.onerror = () => callback && callback(null);\n\n      req.onreadystatechange = () => {\n        if (req.readyState === XHR_STATES.complete && callback) {\n          let response = this.parseJSON(req.responseText);\n          callback(response);\n        }\n      };\n\n      if (ontimeout) {\n        req.ontimeout = ontimeout;\n      }\n\n      req.send(body);\n      return req;\n    }\n\n    static parseJSON(resp) {\n      if (!resp || resp === \"\") {\n        return null;\n      }\n\n      try {\n        return JSON.parse(resp);\n      } catch (e) {\n        console && console.log(\"failed to parse JSON response\", resp);\n        return null;\n      }\n    }\n\n    static serialize(obj, parentKey) {\n      let queryStr = [];\n\n      for (var key in obj) {\n        if (!Object.prototype.hasOwnProperty.call(obj, key)) {\n          continue;\n        }\n\n        let paramKey = parentKey ? `${parentKey}[${key}]` : key;\n        let paramVal = obj[key];\n\n        if (typeof paramVal === \"object\") {\n          queryStr.push(this.serialize(paramVal, paramKey));\n        } else {\n          queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal));\n        }\n      }\n\n      return queryStr.join(\"&\");\n    }\n\n    static appendParams(url, params) {\n      if (Object.keys(params).length === 0) {\n        return url;\n      }\n\n      let prefix = url.match(/\\?/) ? \"&\" : \"?\";\n      return `${url}${prefix}${this.serialize(params)}`;\n    }\n\n  }; // js/phoenix/longpoll.js\n\n  var LongPoll = class {\n    constructor(endPoint) {\n      this.endPoint = null;\n      this.token = null;\n      this.skipHeartbeat = true;\n      this.reqs = /* @__PURE__ */new Set();\n\n      this.onopen = function () {};\n\n      this.onerror = function () {};\n\n      this.onmessage = function () {};\n\n      this.onclose = function () {};\n\n      this.pollEndpoint = this.normalizeEndpoint(endPoint);\n      this.readyState = SOCKET_STATES.connecting;\n      this.poll();\n    }\n\n    normalizeEndpoint(endPoint) {\n      return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll);\n    }\n\n    endpointURL() {\n      return Ajax.appendParams(this.pollEndpoint, {\n        token: this.token\n      });\n    }\n\n    closeAndRetry(code, reason, wasClean) {\n      this.close(code, reason, wasClean);\n      this.readyState = SOCKET_STATES.connecting;\n    }\n\n    ontimeout() {\n      this.onerror(\"timeout\");\n      this.closeAndRetry(1005, \"timeout\", false);\n    }\n\n    isActive() {\n      return this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting;\n    }\n\n    poll() {\n      this.ajax(\"GET\", null, () => this.ontimeout(), resp => {\n        if (resp) {\n          var {\n            status,\n            token,\n            messages\n          } = resp;\n          this.token = token;\n        } else {\n          status = 0;\n        }\n\n        switch (status) {\n          case 200:\n            messages.forEach(msg => {\n              setTimeout(() => this.onmessage({\n                data: msg\n              }), 0);\n            });\n            this.poll();\n            break;\n\n          case 204:\n            this.poll();\n            break;\n\n          case 410:\n            this.readyState = SOCKET_STATES.open;\n            this.onopen({});\n            this.poll();\n            break;\n\n          case 403:\n            this.onerror(403);\n            this.close(1008, \"forbidden\", false);\n            break;\n\n          case 0:\n          case 500:\n            this.onerror(500);\n            this.closeAndRetry(1011, \"internal server error\", 500);\n            break;\n\n          default:\n            throw new Error(`unhandled poll status ${status}`);\n        }\n      });\n    }\n\n    send(body) {\n      this.ajax(\"POST\", body, () => this.onerror(\"timeout\"), resp => {\n        if (!resp || resp.status !== 200) {\n          this.onerror(resp && resp.status);\n          this.closeAndRetry(1011, \"internal server error\", false);\n        }\n      });\n    }\n\n    close(code, reason, wasClean) {\n      for (let req of this.reqs) {\n        req.abort();\n      }\n\n      this.readyState = SOCKET_STATES.closed;\n      let opts = Object.assign({\n        code: 1e3,\n        reason: void 0,\n        wasClean: true\n      }, {\n        code,\n        reason,\n        wasClean\n      });\n\n      if (typeof CloseEvent !== \"undefined\") {\n        this.onclose(new CloseEvent(\"close\", opts));\n      } else {\n        this.onclose(opts);\n      }\n    }\n\n    ajax(method, body, onCallerTimeout, callback) {\n      let req;\n\n      let ontimeout = () => {\n        this.reqs.delete(req);\n        onCallerTimeout();\n      };\n\n      req = Ajax.request(method, this.endpointURL(), \"application/json\", body, this.timeout, ontimeout, resp => {\n        this.reqs.delete(req);\n\n        if (this.isActive()) {\n          callback(resp);\n        }\n      });\n      this.reqs.add(req);\n    }\n\n  }; // js/phoenix/presence.js\n\n  var Presence = class {\n    constructor(channel, opts = {}) {\n      let events = opts.events || {\n        state: \"presence_state\",\n        diff: \"presence_diff\"\n      };\n      this.state = {};\n      this.pendingDiffs = [];\n      this.channel = channel;\n      this.joinRef = null;\n      this.caller = {\n        onJoin: function () {},\n        onLeave: function () {},\n        onSync: function () {}\n      };\n      this.channel.on(events.state, newState => {\n        let {\n          onJoin,\n          onLeave,\n          onSync\n        } = this.caller;\n        this.joinRef = this.channel.joinRef();\n        this.state = Presence.syncState(this.state, newState, onJoin, onLeave);\n        this.pendingDiffs.forEach(diff => {\n          this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n        });\n        this.pendingDiffs = [];\n        onSync();\n      });\n      this.channel.on(events.diff, diff => {\n        let {\n          onJoin,\n          onLeave,\n          onSync\n        } = this.caller;\n\n        if (this.inPendingSyncState()) {\n          this.pendingDiffs.push(diff);\n        } else {\n          this.state = Presence.syncDiff(this.state, diff, onJoin, onLeave);\n          onSync();\n        }\n      });\n    }\n\n    onJoin(callback) {\n      this.caller.onJoin = callback;\n    }\n\n    onLeave(callback) {\n      this.caller.onLeave = callback;\n    }\n\n    onSync(callback) {\n      this.caller.onSync = callback;\n    }\n\n    list(by) {\n      return Presence.list(this.state, by);\n    }\n\n    inPendingSyncState() {\n      return !this.joinRef || this.joinRef !== this.channel.joinRef();\n    }\n\n    static syncState(currentState, newState, onJoin, onLeave) {\n      let state = this.clone(currentState);\n      let joins = {};\n      let leaves = {};\n      this.map(state, (key, presence) => {\n        if (!newState[key]) {\n          leaves[key] = presence;\n        }\n      });\n      this.map(newState, (key, newPresence) => {\n        let currentPresence = state[key];\n\n        if (currentPresence) {\n          let newRefs = newPresence.metas.map(m => m.phx_ref);\n          let curRefs = currentPresence.metas.map(m => m.phx_ref);\n          let joinedMetas = newPresence.metas.filter(m => curRefs.indexOf(m.phx_ref) < 0);\n          let leftMetas = currentPresence.metas.filter(m => newRefs.indexOf(m.phx_ref) < 0);\n\n          if (joinedMetas.length > 0) {\n            joins[key] = newPresence;\n            joins[key].metas = joinedMetas;\n          }\n\n          if (leftMetas.length > 0) {\n            leaves[key] = this.clone(currentPresence);\n            leaves[key].metas = leftMetas;\n          }\n        } else {\n          joins[key] = newPresence;\n        }\n      });\n      return this.syncDiff(state, {\n        joins,\n        leaves\n      }, onJoin, onLeave);\n    }\n\n    static syncDiff(state, diff, onJoin, onLeave) {\n      let {\n        joins,\n        leaves\n      } = this.clone(diff);\n\n      if (!onJoin) {\n        onJoin = function () {};\n      }\n\n      if (!onLeave) {\n        onLeave = function () {};\n      }\n\n      this.map(joins, (key, newPresence) => {\n        let currentPresence = state[key];\n        state[key] = this.clone(newPresence);\n\n        if (currentPresence) {\n          let joinedRefs = state[key].metas.map(m => m.phx_ref);\n          let curMetas = currentPresence.metas.filter(m => joinedRefs.indexOf(m.phx_ref) < 0);\n          state[key].metas.unshift(...curMetas);\n        }\n\n        onJoin(key, currentPresence, newPresence);\n      });\n      this.map(leaves, (key, leftPresence) => {\n        let currentPresence = state[key];\n\n        if (!currentPresence) {\n          return;\n        }\n\n        let refsToRemove = leftPresence.metas.map(m => m.phx_ref);\n        currentPresence.metas = currentPresence.metas.filter(p => {\n          return refsToRemove.indexOf(p.phx_ref) < 0;\n        });\n        onLeave(key, currentPresence, leftPresence);\n\n        if (currentPresence.metas.length === 0) {\n          delete state[key];\n        }\n      });\n      return state;\n    }\n\n    static list(presences, chooser) {\n      if (!chooser) {\n        chooser = function (key, pres) {\n          return pres;\n        };\n      }\n\n      return this.map(presences, (key, presence) => {\n        return chooser(key, presence);\n      });\n    }\n\n    static map(obj, func) {\n      return Object.getOwnPropertyNames(obj).map(key => func(key, obj[key]));\n    }\n\n    static clone(obj) {\n      return JSON.parse(JSON.stringify(obj));\n    }\n\n  }; // js/phoenix/serializer.js\n\n  var serializer_default = {\n    HEADER_LENGTH: 1,\n    META_LENGTH: 4,\n    KINDS: {\n      push: 0,\n      reply: 1,\n      broadcast: 2\n    },\n\n    encode(msg, callback) {\n      if (msg.payload.constructor === ArrayBuffer) {\n        return callback(this.binaryEncode(msg));\n      } else {\n        let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];\n        return callback(JSON.stringify(payload));\n      }\n    },\n\n    decode(rawPayload, callback) {\n      if (rawPayload.constructor === ArrayBuffer) {\n        return callback(this.binaryDecode(rawPayload));\n      } else {\n        let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);\n        return callback({\n          join_ref,\n          ref,\n          topic,\n          event,\n          payload\n        });\n      }\n    },\n\n    binaryEncode(message) {\n      let {\n        join_ref,\n        ref,\n        event,\n        topic,\n        payload\n      } = message;\n      let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;\n      let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);\n      let view = new DataView(header);\n      let offset = 0;\n      view.setUint8(offset++, this.KINDS.push);\n      view.setUint8(offset++, join_ref.length);\n      view.setUint8(offset++, ref.length);\n      view.setUint8(offset++, topic.length);\n      view.setUint8(offset++, event.length);\n      Array.from(join_ref, char => view.setUint8(offset++, char.charCodeAt(0)));\n      Array.from(ref, char => view.setUint8(offset++, char.charCodeAt(0)));\n      Array.from(topic, char => view.setUint8(offset++, char.charCodeAt(0)));\n      Array.from(event, char => view.setUint8(offset++, char.charCodeAt(0)));\n      var combined = new Uint8Array(header.byteLength + payload.byteLength);\n      combined.set(new Uint8Array(header), 0);\n      combined.set(new Uint8Array(payload), header.byteLength);\n      return combined.buffer;\n    },\n\n    binaryDecode(buffer) {\n      let view = new DataView(buffer);\n      let kind = view.getUint8(0);\n      let decoder = new TextDecoder();\n\n      switch (kind) {\n        case this.KINDS.push:\n          return this.decodePush(buffer, view, decoder);\n\n        case this.KINDS.reply:\n          return this.decodeReply(buffer, view, decoder);\n\n        case this.KINDS.broadcast:\n          return this.decodeBroadcast(buffer, view, decoder);\n      }\n    },\n\n    decodePush(buffer, view, decoder) {\n      let joinRefSize = view.getUint8(1);\n      let topicSize = view.getUint8(2);\n      let eventSize = view.getUint8(3);\n      let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;\n      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n      offset = offset + joinRefSize;\n      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n      offset = offset + topicSize;\n      let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n      offset = offset + eventSize;\n      let data = buffer.slice(offset, buffer.byteLength);\n      return {\n        join_ref: joinRef,\n        ref: null,\n        topic,\n        event,\n        payload: data\n      };\n    },\n\n    decodeReply(buffer, view, decoder) {\n      let joinRefSize = view.getUint8(1);\n      let refSize = view.getUint8(2);\n      let topicSize = view.getUint8(3);\n      let eventSize = view.getUint8(4);\n      let offset = this.HEADER_LENGTH + this.META_LENGTH;\n      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));\n      offset = offset + joinRefSize;\n      let ref = decoder.decode(buffer.slice(offset, offset + refSize));\n      offset = offset + refSize;\n      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n      offset = offset + topicSize;\n      let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n      offset = offset + eventSize;\n      let data = buffer.slice(offset, buffer.byteLength);\n      let payload = {\n        status: event,\n        response: data\n      };\n      return {\n        join_ref: joinRef,\n        ref,\n        topic,\n        event: CHANNEL_EVENTS.reply,\n        payload\n      };\n    },\n\n    decodeBroadcast(buffer, view, decoder) {\n      let topicSize = view.getUint8(1);\n      let eventSize = view.getUint8(2);\n      let offset = this.HEADER_LENGTH + 2;\n      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n      offset = offset + topicSize;\n      let event = decoder.decode(buffer.slice(offset, offset + eventSize));\n      offset = offset + eventSize;\n      let data = buffer.slice(offset, buffer.byteLength);\n      return {\n        join_ref: null,\n        ref: null,\n        topic,\n        event,\n        payload: data\n      };\n    }\n\n  }; // js/phoenix/socket.js\n\n  var Socket = class {\n    constructor(endPoint, opts = {}) {\n      this.stateChangeCallbacks = {\n        open: [],\n        close: [],\n        error: [],\n        message: []\n      };\n      this.channels = [];\n      this.sendBuffer = [];\n      this.ref = 0;\n      this.timeout = opts.timeout || DEFAULT_TIMEOUT;\n      this.transport = opts.transport || global.WebSocket || LongPoll;\n      this.establishedConnections = 0;\n      this.defaultEncoder = serializer_default.encode.bind(serializer_default);\n      this.defaultDecoder = serializer_default.decode.bind(serializer_default);\n      this.closeWasClean = false;\n      this.binaryType = opts.binaryType || \"arraybuffer\";\n      this.connectClock = 1;\n\n      if (this.transport !== LongPoll) {\n        this.encode = opts.encode || this.defaultEncoder;\n        this.decode = opts.decode || this.defaultDecoder;\n      } else {\n        this.encode = this.defaultEncoder;\n        this.decode = this.defaultDecoder;\n      }\n\n      let awaitingConnectionOnPageShow = null;\n\n      if (phxWindow && phxWindow.addEventListener) {\n        phxWindow.addEventListener(\"pagehide\", _e => {\n          if (this.conn) {\n            this.disconnect();\n            awaitingConnectionOnPageShow = this.connectClock;\n          }\n        });\n        phxWindow.addEventListener(\"pageshow\", _e => {\n          if (awaitingConnectionOnPageShow === this.connectClock) {\n            awaitingConnectionOnPageShow = null;\n            this.connect();\n          }\n        });\n      }\n\n      this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;\n\n      this.rejoinAfterMs = tries => {\n        if (opts.rejoinAfterMs) {\n          return opts.rejoinAfterMs(tries);\n        } else {\n          return [1e3, 2e3, 5e3][tries - 1] || 1e4;\n        }\n      };\n\n      this.reconnectAfterMs = tries => {\n        if (opts.reconnectAfterMs) {\n          return opts.reconnectAfterMs(tries);\n        } else {\n          return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;\n        }\n      };\n\n      this.logger = opts.logger || null;\n      this.longpollerTimeout = opts.longpollerTimeout || 2e4;\n      this.params = closure(opts.params || {});\n      this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;\n      this.vsn = opts.vsn || DEFAULT_VSN;\n      this.heartbeatTimeoutTimer = null;\n      this.heartbeatTimer = null;\n      this.pendingHeartbeatRef = null;\n      this.reconnectTimer = new Timer(() => {\n        this.teardown(() => this.connect());\n      }, this.reconnectAfterMs);\n    }\n\n    getLongPollTransport() {\n      return LongPoll;\n    }\n\n    replaceTransport(newTransport) {\n      this.connectClock++;\n      this.closeWasClean = true;\n      this.reconnectTimer.reset();\n      this.sendBuffer = [];\n\n      if (this.conn) {\n        this.conn.close();\n        this.conn = null;\n      }\n\n      this.transport = newTransport;\n    }\n\n    protocol() {\n      return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\n    }\n\n    endPointURL() {\n      let uri = Ajax.appendParams(Ajax.appendParams(this.endPoint, this.params()), {\n        vsn: this.vsn\n      });\n\n      if (uri.charAt(0) !== \"/\") {\n        return uri;\n      }\n\n      if (uri.charAt(1) === \"/\") {\n        return `${this.protocol()}:${uri}`;\n      }\n\n      return `${this.protocol()}://${location.host}${uri}`;\n    }\n\n    disconnect(callback, code, reason) {\n      this.connectClock++;\n      this.closeWasClean = true;\n      this.reconnectTimer.reset();\n      this.teardown(callback, code, reason);\n    }\n\n    connect(params) {\n      if (params) {\n        console && console.log(\"passing params to connect is deprecated. Instead pass :params to the Socket constructor\");\n        this.params = closure(params);\n      }\n\n      if (this.conn) {\n        return;\n      }\n\n      this.connectClock++;\n      this.closeWasClean = false;\n      this.conn = new this.transport(this.endPointURL());\n      this.conn.binaryType = this.binaryType;\n      this.conn.timeout = this.longpollerTimeout;\n\n      this.conn.onopen = () => this.onConnOpen();\n\n      this.conn.onerror = error => this.onConnError(error);\n\n      this.conn.onmessage = event => this.onConnMessage(event);\n\n      this.conn.onclose = event => this.onConnClose(event);\n    }\n\n    log(kind, msg, data) {\n      this.logger(kind, msg, data);\n    }\n\n    hasLogger() {\n      return this.logger !== null;\n    }\n\n    onOpen(callback) {\n      let ref = this.makeRef();\n      this.stateChangeCallbacks.open.push([ref, callback]);\n      return ref;\n    }\n\n    onClose(callback) {\n      let ref = this.makeRef();\n      this.stateChangeCallbacks.close.push([ref, callback]);\n      return ref;\n    }\n\n    onError(callback) {\n      let ref = this.makeRef();\n      this.stateChangeCallbacks.error.push([ref, callback]);\n      return ref;\n    }\n\n    onMessage(callback) {\n      let ref = this.makeRef();\n      this.stateChangeCallbacks.message.push([ref, callback]);\n      return ref;\n    }\n\n    ping(callback) {\n      if (!this.isConnected()) {\n        return false;\n      }\n\n      let ref = this.makeRef();\n      let startTime = Date.now();\n      this.push({\n        topic: \"phoenix\",\n        event: \"heartbeat\",\n        payload: {},\n        ref\n      });\n      let onMsgRef = this.onMessage(msg => {\n        if (msg.ref === ref) {\n          this.off([onMsgRef]);\n          callback(Date.now() - startTime);\n        }\n      });\n      return true;\n    }\n\n    clearHeartbeats() {\n      clearTimeout(this.heartbeatTimer);\n      clearTimeout(this.heartbeatTimeoutTimer);\n    }\n\n    onConnOpen() {\n      if (this.hasLogger()) this.log(\"transport\", `connected to ${this.endPointURL()}`);\n      this.closeWasClean = false;\n      this.establishedConnections++;\n      this.flushSendBuffer();\n      this.reconnectTimer.reset();\n      this.resetHeartbeat();\n      this.stateChangeCallbacks.open.forEach(([, callback]) => callback());\n    }\n\n    heartbeatTimeout() {\n      if (this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null;\n\n        if (this.hasLogger()) {\n          this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n        }\n\n        this.triggerChanError();\n        this.closeWasClean = false;\n        this.teardown(() => this.reconnectTimer.scheduleTimeout(), WS_CLOSE_NORMAL, \"heartbeat timeout\");\n      }\n    }\n\n    resetHeartbeat() {\n      if (this.conn && this.conn.skipHeartbeat) {\n        return;\n      }\n\n      this.pendingHeartbeatRef = null;\n      this.clearHeartbeats();\n      this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n    }\n\n    teardown(callback, code, reason) {\n      if (!this.conn) {\n        return callback && callback();\n      }\n\n      this.waitForBufferDone(() => {\n        if (this.conn) {\n          if (code) {\n            this.conn.close(code, reason || \"\");\n          } else {\n            this.conn.close();\n          }\n        }\n\n        this.waitForSocketClosed(() => {\n          if (this.conn) {\n            this.conn.onopen = function () {};\n\n            this.conn.onerror = function () {};\n\n            this.conn.onmessage = function () {};\n\n            this.conn.onclose = function () {};\n\n            this.conn = null;\n          }\n\n          callback && callback();\n        });\n      });\n    }\n\n    waitForBufferDone(callback, tries = 1) {\n      if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {\n        callback();\n        return;\n      }\n\n      setTimeout(() => {\n        this.waitForBufferDone(callback, tries + 1);\n      }, 150 * tries);\n    }\n\n    waitForSocketClosed(callback, tries = 1) {\n      if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {\n        callback();\n        return;\n      }\n\n      setTimeout(() => {\n        this.waitForSocketClosed(callback, tries + 1);\n      }, 150 * tries);\n    }\n\n    onConnClose(event) {\n      let closeCode = event && event.code;\n      if (this.hasLogger()) this.log(\"transport\", \"close\", event);\n      this.triggerChanError();\n      this.clearHeartbeats();\n\n      if (!this.closeWasClean && closeCode !== 1e3) {\n        this.reconnectTimer.scheduleTimeout();\n      }\n\n      this.stateChangeCallbacks.close.forEach(([, callback]) => callback(event));\n    }\n\n    onConnError(error) {\n      if (this.hasLogger()) this.log(\"transport\", error);\n      let transportBefore = this.transport;\n      let establishedBefore = this.establishedConnections;\n      this.stateChangeCallbacks.error.forEach(([, callback]) => {\n        callback(error, transportBefore, establishedBefore);\n      });\n\n      if (transportBefore === this.transport || establishedBefore > 0) {\n        this.triggerChanError();\n      }\n    }\n\n    triggerChanError() {\n      this.channels.forEach(channel => {\n        if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {\n          channel.trigger(CHANNEL_EVENTS.error);\n        }\n      });\n    }\n\n    connectionState() {\n      switch (this.conn && this.conn.readyState) {\n        case SOCKET_STATES.connecting:\n          return \"connecting\";\n\n        case SOCKET_STATES.open:\n          return \"open\";\n\n        case SOCKET_STATES.closing:\n          return \"closing\";\n\n        default:\n          return \"closed\";\n      }\n    }\n\n    isConnected() {\n      return this.connectionState() === \"open\";\n    }\n\n    remove(channel) {\n      this.off(channel.stateChangeRefs);\n      this.channels = this.channels.filter(c => c.joinRef() !== channel.joinRef());\n    }\n\n    off(refs) {\n      for (let key in this.stateChangeCallbacks) {\n        this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {\n          return refs.indexOf(ref) === -1;\n        });\n      }\n    }\n\n    channel(topic, chanParams = {}) {\n      let chan = new Channel(topic, chanParams, this);\n      this.channels.push(chan);\n      return chan;\n    }\n\n    push(data) {\n      if (this.hasLogger()) {\n        let {\n          topic,\n          event,\n          payload,\n          ref,\n          join_ref\n        } = data;\n        this.log(\"push\", `${topic} ${event} (${join_ref}, ${ref})`, payload);\n      }\n\n      if (this.isConnected()) {\n        this.encode(data, result => this.conn.send(result));\n      } else {\n        this.sendBuffer.push(() => this.encode(data, result => this.conn.send(result)));\n      }\n    }\n\n    makeRef() {\n      let newRef = this.ref + 1;\n\n      if (newRef === this.ref) {\n        this.ref = 0;\n      } else {\n        this.ref = newRef;\n      }\n\n      return this.ref.toString();\n    }\n\n    sendHeartbeat() {\n      if (this.pendingHeartbeatRef && !this.isConnected()) {\n        return;\n      }\n\n      this.pendingHeartbeatRef = this.makeRef();\n      this.push({\n        topic: \"phoenix\",\n        event: \"heartbeat\",\n        payload: {},\n        ref: this.pendingHeartbeatRef\n      });\n      this.heartbeatTimeoutTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);\n    }\n\n    flushSendBuffer() {\n      if (this.isConnected() && this.sendBuffer.length > 0) {\n        this.sendBuffer.forEach(callback => callback());\n        this.sendBuffer = [];\n      }\n    }\n\n    onConnMessage(rawMessage) {\n      this.decode(rawMessage.data, msg => {\n        let {\n          topic,\n          event,\n          payload,\n          ref,\n          join_ref\n        } = msg;\n\n        if (ref && ref === this.pendingHeartbeatRef) {\n          this.clearHeartbeats();\n          this.pendingHeartbeatRef = null;\n          this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);\n        }\n\n        if (this.hasLogger()) this.log(\"receive\", `${payload.status || \"\"} ${topic} ${event} ${ref && \"(\" + ref + \")\" || \"\"}`, payload);\n\n        for (let i = 0; i < this.channels.length; i++) {\n          const channel = this.channels[i];\n\n          if (!channel.isMember(topic, event, payload, join_ref)) {\n            continue;\n          }\n\n          channel.trigger(event, payload, ref, join_ref);\n        }\n\n        for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {\n          let [, callback] = this.stateChangeCallbacks.message[i];\n          callback(msg);\n        }\n      });\n    }\n\n    leaveOpenTopic(topic) {\n      let dupChannel = this.channels.find(c => c.topic === topic && (c.isJoined() || c.isJoining()));\n\n      if (dupChannel) {\n        if (this.hasLogger()) this.log(\"transport\", `leaving duplicate topic \"${topic}\"`);\n        dupChannel.leave();\n      }\n    }\n\n  };\n  return __toCommonJS(phoenix_exports);\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZGVwcy9waG9lbml4L3ByaXYvc3RhdGljL3Bob2VuaXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vZGVwcy9waG9lbml4L3ByaXYvc3RhdGljL3Bob2VuaXguanM/MzFiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUGhvZW5peCA9ICgoKSA9PiB7XG4gIHZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gIHZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgdmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG4gIHZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gIH07XG4gIHZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gICAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvO1xuICB9O1xuICB2YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuICAvLyBqcy9waG9lbml4L2luZGV4LmpzXG4gIHZhciBwaG9lbml4X2V4cG9ydHMgPSB7fTtcbiAgX19leHBvcnQocGhvZW5peF9leHBvcnRzLCB7XG4gICAgQ2hhbm5lbDogKCkgPT4gQ2hhbm5lbCxcbiAgICBMb25nUG9sbDogKCkgPT4gTG9uZ1BvbGwsXG4gICAgUHJlc2VuY2U6ICgpID0+IFByZXNlbmNlLFxuICAgIFNlcmlhbGl6ZXI6ICgpID0+IHNlcmlhbGl6ZXJfZGVmYXVsdCxcbiAgICBTb2NrZXQ6ICgpID0+IFNvY2tldFxuICB9KTtcblxuICAvLyBqcy9waG9lbml4L3V0aWxzLmpzXG4gIHZhciBjbG9zdXJlID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjbG9zdXJlMiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGNsb3N1cmUyO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L2NvbnN0YW50cy5qc1xuICB2YXIgZ2xvYmFsU2VsZiA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IG51bGw7XG4gIHZhciBwaHhXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogbnVsbDtcbiAgdmFyIGdsb2JhbCA9IGdsb2JhbFNlbGYgfHwgcGh4V2luZG93IHx8IGdsb2JhbDtcbiAgdmFyIERFRkFVTFRfVlNOID0gXCIyLjAuMFwiO1xuICB2YXIgU09DS0VUX1NUQVRFUyA9IHsgY29ubmVjdGluZzogMCwgb3BlbjogMSwgY2xvc2luZzogMiwgY2xvc2VkOiAzIH07XG4gIHZhciBERUZBVUxUX1RJTUVPVVQgPSAxZTQ7XG4gIHZhciBXU19DTE9TRV9OT1JNQUwgPSAxZTM7XG4gIHZhciBDSEFOTkVMX1NUQVRFUyA9IHtcbiAgICBjbG9zZWQ6IFwiY2xvc2VkXCIsXG4gICAgZXJyb3JlZDogXCJlcnJvcmVkXCIsXG4gICAgam9pbmVkOiBcImpvaW5lZFwiLFxuICAgIGpvaW5pbmc6IFwiam9pbmluZ1wiLFxuICAgIGxlYXZpbmc6IFwibGVhdmluZ1wiXG4gIH07XG4gIHZhciBDSEFOTkVMX0VWRU5UUyA9IHtcbiAgICBjbG9zZTogXCJwaHhfY2xvc2VcIixcbiAgICBlcnJvcjogXCJwaHhfZXJyb3JcIixcbiAgICBqb2luOiBcInBoeF9qb2luXCIsXG4gICAgcmVwbHk6IFwicGh4X3JlcGx5XCIsXG4gICAgbGVhdmU6IFwicGh4X2xlYXZlXCJcbiAgfTtcbiAgdmFyIFRSQU5TUE9SVFMgPSB7XG4gICAgbG9uZ3BvbGw6IFwibG9uZ3BvbGxcIixcbiAgICB3ZWJzb2NrZXQ6IFwid2Vic29ja2V0XCJcbiAgfTtcbiAgdmFyIFhIUl9TVEFURVMgPSB7XG4gICAgY29tcGxldGU6IDRcbiAgfTtcblxuICAvLyBqcy9waG9lbml4L3B1c2guanNcbiAgdmFyIFB1c2ggPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQpIHtcbiAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9O1xuICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBudWxsO1xuICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgIHRoaXMudGltZW91dFRpbWVyID0gbnVsbDtcbiAgICAgIHRoaXMucmVjSG9va3MgPSBbXTtcbiAgICAgIHRoaXMuc2VudCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXNlbmQodGltZW91dCkge1xuICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHRoaXMuc2VuZCgpO1xuICAgIH1cbiAgICBzZW5kKCkge1xuICAgICAgaWYgKHRoaXMuaGFzUmVjZWl2ZWQoXCJ0aW1lb3V0XCIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhcnRUaW1lb3V0KCk7XG4gICAgICB0aGlzLnNlbnQgPSB0cnVlO1xuICAgICAgdGhpcy5jaGFubmVsLnNvY2tldC5wdXNoKHtcbiAgICAgICAgdG9waWM6IHRoaXMuY2hhbm5lbC50b3BpYyxcbiAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICAgIHBheWxvYWQ6IHRoaXMucGF5bG9hZCgpLFxuICAgICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgICBqb2luX3JlZjogdGhpcy5jaGFubmVsLmpvaW5SZWYoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlY2VpdmUoc3RhdHVzLCBjYWxsYmFjaykge1xuICAgICAgaWYgKHRoaXMuaGFzUmVjZWl2ZWQoc3RhdHVzKSkge1xuICAgICAgICBjYWxsYmFjayh0aGlzLnJlY2VpdmVkUmVzcC5yZXNwb25zZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlY0hvb2tzLnB1c2goeyBzdGF0dXMsIGNhbGxiYWNrIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgdGhpcy5jYW5jZWxSZWZFdmVudCgpO1xuICAgICAgdGhpcy5yZWYgPSBudWxsO1xuICAgICAgdGhpcy5yZWZFdmVudCA9IG51bGw7XG4gICAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IG51bGw7XG4gICAgICB0aGlzLnNlbnQgPSBmYWxzZTtcbiAgICB9XG4gICAgbWF0Y2hSZWNlaXZlKHsgc3RhdHVzLCByZXNwb25zZSwgX3JlZiB9KSB7XG4gICAgICB0aGlzLnJlY0hvb2tzLmZpbHRlcigoaCkgPT4gaC5zdGF0dXMgPT09IHN0YXR1cykuZm9yRWFjaCgoaCkgPT4gaC5jYWxsYmFjayhyZXNwb25zZSkpO1xuICAgIH1cbiAgICBjYW5jZWxSZWZFdmVudCgpIHtcbiAgICAgIGlmICghdGhpcy5yZWZFdmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmNoYW5uZWwub2ZmKHRoaXMucmVmRXZlbnQpO1xuICAgIH1cbiAgICBjYW5jZWxUaW1lb3V0KCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFRpbWVyKTtcbiAgICAgIHRoaXMudGltZW91dFRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgc3RhcnRUaW1lb3V0KCkge1xuICAgICAgaWYgKHRoaXMudGltZW91dFRpbWVyKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsVGltZW91dCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWYgPSB0aGlzLmNoYW5uZWwuc29ja2V0Lm1ha2VSZWYoKTtcbiAgICAgIHRoaXMucmVmRXZlbnQgPSB0aGlzLmNoYW5uZWwucmVwbHlFdmVudE5hbWUodGhpcy5yZWYpO1xuICAgICAgdGhpcy5jaGFubmVsLm9uKHRoaXMucmVmRXZlbnQsIChwYXlsb2FkKSA9PiB7XG4gICAgICAgIHRoaXMuY2FuY2VsUmVmRXZlbnQoKTtcbiAgICAgICAgdGhpcy5jYW5jZWxUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gcGF5bG9hZDtcbiAgICAgICAgdGhpcy5tYXRjaFJlY2VpdmUocGF5bG9hZCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMudGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihcInRpbWVvdXRcIiwge30pO1xuICAgICAgfSwgdGhpcy50aW1lb3V0KTtcbiAgICB9XG4gICAgaGFzUmVjZWl2ZWQoc3RhdHVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWNlaXZlZFJlc3AgJiYgdGhpcy5yZWNlaXZlZFJlc3Auc3RhdHVzID09PSBzdGF0dXM7XG4gICAgfVxuICAgIHRyaWdnZXIoc3RhdHVzLCByZXNwb25zZSkge1xuICAgICAgdGhpcy5jaGFubmVsLnRyaWdnZXIodGhpcy5yZWZFdmVudCwgeyBzdGF0dXMsIHJlc3BvbnNlIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L3RpbWVyLmpzXG4gIHZhciBUaW1lciA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgdGltZXJDYWxjKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB0aGlzLnRpbWVyQ2FsYyA9IHRpbWVyQ2FsYztcbiAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgdGhpcy50cmllcyA9IDA7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgdGhpcy50cmllcyA9IDA7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgfVxuICAgIHNjaGVkdWxlVGltZW91dCgpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy50cmllcyA9IHRoaXMudHJpZXMgKyAxO1xuICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICB9LCB0aGlzLnRpbWVyQ2FsYyh0aGlzLnRyaWVzICsgMSkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L2NoYW5uZWwuanNcbiAgdmFyIENoYW5uZWwgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IodG9waWMsIHBhcmFtcywgc29ja2V0KSB7XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkO1xuICAgICAgdGhpcy50b3BpYyA9IHRvcGljO1xuICAgICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKHBhcmFtcyB8fCB7fSk7XG4gICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICAgIHRoaXMuYmluZGluZ3MgPSBbXTtcbiAgICAgIHRoaXMuYmluZGluZ1JlZiA9IDA7XG4gICAgICB0aGlzLnRpbWVvdXQgPSB0aGlzLnNvY2tldC50aW1lb3V0O1xuICAgICAgdGhpcy5qb2luZWRPbmNlID0gZmFsc2U7XG4gICAgICB0aGlzLmpvaW5QdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMuam9pbiwgdGhpcy5wYXJhbXMsIHRoaXMudGltZW91dCk7XG4gICAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXTtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzID0gW107XG4gICAgICB0aGlzLnJlam9pblRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICB0aGlzLnJlam9pbigpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzLnNvY2tldC5yZWpvaW5BZnRlck1zKTtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzLnB1c2godGhpcy5zb2NrZXQub25FcnJvcigoKSA9PiB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCkpKTtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzLnB1c2godGhpcy5zb2NrZXQub25PcGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgICAgICBpZiAodGhpcy5pc0Vycm9yZWQoKSkge1xuICAgICAgICAgIHRoaXMucmVqb2luKCk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcIm9rXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5lZDtcbiAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgICAgICB0aGlzLnB1c2hCdWZmZXIuZm9yRWFjaCgocHVzaEV2ZW50KSA9PiBwdXNoRXZlbnQuc2VuZCgpKTtcbiAgICAgICAgdGhpcy5wdXNoQnVmZmVyID0gW107XG4gICAgICB9KTtcbiAgICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcImVycm9yXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWQ7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLm9uQ2xvc2UoKCkgPT4ge1xuICAgICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCk7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSlcbiAgICAgICAgICB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGBjbG9zZSAke3RoaXMudG9waWN9ICR7dGhpcy5qb2luUmVmKCl9YCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWQ7XG4gICAgICAgIHRoaXMuc29ja2V0LnJlbW92ZSh0aGlzKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbkVycm9yKChyZWFzb24pID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKVxuICAgICAgICAgIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYGVycm9yICR7dGhpcy50b3BpY31gLCByZWFzb24pO1xuICAgICAgICBpZiAodGhpcy5pc0pvaW5pbmcoKSkge1xuICAgICAgICAgIHRoaXMuam9pblB1c2gucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpXG4gICAgICAgICAgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgdGltZW91dCAke3RoaXMudG9waWN9ICgke3RoaXMuam9pblJlZigpfSlgLCB0aGlzLmpvaW5QdXNoLnRpbWVvdXQpO1xuICAgICAgICBsZXQgbGVhdmVQdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMubGVhdmUsIGNsb3N1cmUoe30pLCB0aGlzLnRpbWVvdXQpO1xuICAgICAgICBsZWF2ZVB1c2guc2VuZCgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgdGhpcy5qb2luUHVzaC5yZXNldCgpO1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbihDSEFOTkVMX0VWRU5UUy5yZXBseSwgKHBheWxvYWQsIHJlZikgPT4ge1xuICAgICAgICB0aGlzLnRyaWdnZXIodGhpcy5yZXBseUV2ZW50TmFtZShyZWYpLCBwYXlsb2FkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBqb2luKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpIHtcbiAgICAgIGlmICh0aGlzLmpvaW5lZE9uY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJpZWQgdG8gam9pbiBtdWx0aXBsZSB0aW1lcy4gJ2pvaW4nIGNhbiBvbmx5IGJlIGNhbGxlZCBhIHNpbmdsZSB0aW1lIHBlciBjaGFubmVsIGluc3RhbmNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgICAgdGhpcy5qb2luZWRPbmNlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWpvaW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuam9pblB1c2g7XG4gICAgICB9XG4gICAgfVxuICAgIG9uQ2xvc2UoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgb25FcnJvcihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMub24oQ0hBTk5FTF9FVkVOVFMuZXJyb3IsIChyZWFzb24pID0+IGNhbGxiYWNrKHJlYXNvbikpO1xuICAgIH1cbiAgICBvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICAgIGxldCByZWYgPSB0aGlzLmJpbmRpbmdSZWYrKztcbiAgICAgIHRoaXMuYmluZGluZ3MucHVzaCh7IGV2ZW50LCByZWYsIGNhbGxiYWNrIH0pO1xuICAgICAgcmV0dXJuIHJlZjtcbiAgICB9XG4gICAgb2ZmKGV2ZW50LCByZWYpIHtcbiAgICAgIHRoaXMuYmluZGluZ3MgPSB0aGlzLmJpbmRpbmdzLmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgICByZXR1cm4gIShiaW5kLmV2ZW50ID09PSBldmVudCAmJiAodHlwZW9mIHJlZiA9PT0gXCJ1bmRlZmluZWRcIiB8fCByZWYgPT09IGJpbmQucmVmKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY2FuUHVzaCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuaXNKb2luZWQoKTtcbiAgICB9XG4gICAgcHVzaChldmVudCwgcGF5bG9hZCwgdGltZW91dCA9IHRoaXMudGltZW91dCkge1xuICAgICAgcGF5bG9hZCA9IHBheWxvYWQgfHwge307XG4gICAgICBpZiAoIXRoaXMuam9pbmVkT25jZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHRyaWVkIHRvIHB1c2ggJyR7ZXZlbnR9JyB0byAnJHt0aGlzLnRvcGljfScgYmVmb3JlIGpvaW5pbmcuIFVzZSBjaGFubmVsLmpvaW4oKSBiZWZvcmUgcHVzaGluZyBldmVudHNgKTtcbiAgICAgIH1cbiAgICAgIGxldCBwdXNoRXZlbnQgPSBuZXcgUHVzaCh0aGlzLCBldmVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgICBpZiAodGhpcy5jYW5QdXNoKCkpIHtcbiAgICAgICAgcHVzaEV2ZW50LnNlbmQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hFdmVudC5zdGFydFRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5wdXNoQnVmZmVyLnB1c2gocHVzaEV2ZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwdXNoRXZlbnQ7XG4gICAgfVxuICAgIGxlYXZlKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpIHtcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKTtcbiAgICAgIHRoaXMuam9pblB1c2guY2FuY2VsVGltZW91dCgpO1xuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmxlYXZpbmc7XG4gICAgICBsZXQgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKVxuICAgICAgICAgIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYGxlYXZlICR7dGhpcy50b3BpY31gKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKENIQU5ORUxfRVZFTlRTLmNsb3NlLCBcImxlYXZlXCIpO1xuICAgICAgfTtcbiAgICAgIGxldCBsZWF2ZVB1c2ggPSBuZXcgUHVzaCh0aGlzLCBDSEFOTkVMX0VWRU5UUy5sZWF2ZSwgY2xvc3VyZSh7fSksIHRpbWVvdXQpO1xuICAgICAgbGVhdmVQdXNoLnJlY2VpdmUoXCJva1wiLCAoKSA9PiBvbkNsb3NlKCkpLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+IG9uQ2xvc2UoKSk7XG4gICAgICBsZWF2ZVB1c2guc2VuZCgpO1xuICAgICAgaWYgKCF0aGlzLmNhblB1c2goKSkge1xuICAgICAgICBsZWF2ZVB1c2gudHJpZ2dlcihcIm9rXCIsIHt9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWF2ZVB1c2g7XG4gICAgfVxuICAgIG9uTWVzc2FnZShfZXZlbnQsIHBheWxvYWQsIF9yZWYpIHtcbiAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgICBpc01lbWJlcih0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5SZWYpIHtcbiAgICAgIGlmICh0aGlzLnRvcGljICE9PSB0b3BpYykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoam9pblJlZiAmJiBqb2luUmVmICE9PSB0aGlzLmpvaW5SZWYoKSkge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpXG4gICAgICAgICAgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBcImRyb3BwaW5nIG91dGRhdGVkIG1lc3NhZ2VcIiwgeyB0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5SZWYgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBqb2luUmVmKCkge1xuICAgICAgcmV0dXJuIHRoaXMuam9pblB1c2gucmVmO1xuICAgIH1cbiAgICByZWpvaW4odGltZW91dCA9IHRoaXMudGltZW91dCkge1xuICAgICAgaWYgKHRoaXMuaXNMZWF2aW5nKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zb2NrZXQubGVhdmVPcGVuVG9waWModGhpcy50b3BpYyk7XG4gICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmluZztcbiAgICAgIHRoaXMuam9pblB1c2gucmVzZW5kKHRpbWVvdXQpO1xuICAgIH1cbiAgICB0cmlnZ2VyKGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5SZWYpIHtcbiAgICAgIGxldCBoYW5kbGVkUGF5bG9hZCA9IHRoaXMub25NZXNzYWdlKGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5SZWYpO1xuICAgICAgaWYgKHBheWxvYWQgJiYgIWhhbmRsZWRQYXlsb2FkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNoYW5uZWwgb25NZXNzYWdlIGNhbGxiYWNrcyBtdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZFwiKTtcbiAgICAgIH1cbiAgICAgIGxldCBldmVudEJpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5maWx0ZXIoKGJpbmQpID0+IGJpbmQuZXZlbnQgPT09IGV2ZW50KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRCaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgYmluZCA9IGV2ZW50QmluZGluZ3NbaV07XG4gICAgICAgIGJpbmQuY2FsbGJhY2soaGFuZGxlZFBheWxvYWQsIHJlZiwgam9pblJlZiB8fCB0aGlzLmpvaW5SZWYoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlcGx5RXZlbnROYW1lKHJlZikge1xuICAgICAgcmV0dXJuIGBjaGFuX3JlcGx5XyR7cmVmfWA7XG4gICAgfVxuICAgIGlzQ2xvc2VkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmNsb3NlZDtcbiAgICB9XG4gICAgaXNFcnJvcmVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmVycm9yZWQ7XG4gICAgfVxuICAgIGlzSm9pbmVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5lZDtcbiAgICB9XG4gICAgaXNKb2luaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5pbmc7XG4gICAgfVxuICAgIGlzTGVhdmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L2FqYXguanNcbiAgdmFyIEFqYXggPSBjbGFzcyB7XG4gICAgc3RhdGljIHJlcXVlc3QobWV0aG9kLCBlbmRQb2ludCwgYWNjZXB0LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoZ2xvYmFsLlhEb21haW5SZXF1ZXN0KSB7XG4gICAgICAgIGxldCByZXEgPSBuZXcgZ2xvYmFsLlhEb21haW5SZXF1ZXN0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnhkb21haW5SZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcmVxID0gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy54aHJSZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYWNjZXB0LCBib2R5LCB0aW1lb3V0LCBvbnRpbWVvdXQsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHhkb21haW5SZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjaykge1xuICAgICAgcmVxLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgcmVxLm9wZW4obWV0aG9kLCBlbmRQb2ludCk7XG4gICAgICByZXEub25sb2FkID0gKCkgPT4ge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB0aGlzLnBhcnNlSlNPTihyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgfTtcbiAgICAgIGlmIChvbnRpbWVvdXQpIHtcbiAgICAgICAgcmVxLm9udGltZW91dCA9IG9udGltZW91dDtcbiAgICAgIH1cbiAgICAgIHJlcS5vbnByb2dyZXNzID0gKCkgPT4ge1xuICAgICAgfTtcbiAgICAgIHJlcS5zZW5kKGJvZHkpO1xuICAgICAgcmV0dXJuIHJlcTtcbiAgICB9XG4gICAgc3RhdGljIHhoclJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBhY2NlcHQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spIHtcbiAgICAgIHJlcS5vcGVuKG1ldGhvZCwgZW5kUG9pbnQsIHRydWUpO1xuICAgICAgcmVxLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgYWNjZXB0KTtcbiAgICAgIHJlcS5vbmVycm9yID0gKCkgPT4gY2FsbGJhY2sgJiYgY2FsbGJhY2sobnVsbCk7XG4gICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT09IFhIUl9TVEFURVMuY29tcGxldGUgJiYgY2FsbGJhY2spIHtcbiAgICAgICAgICBsZXQgcmVzcG9uc2UgPSB0aGlzLnBhcnNlSlNPTihyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAob250aW1lb3V0KSB7XG4gICAgICAgIHJlcS5vbnRpbWVvdXQgPSBvbnRpbWVvdXQ7XG4gICAgICB9XG4gICAgICByZXEuc2VuZChib2R5KTtcbiAgICAgIHJldHVybiByZXE7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZUpTT04ocmVzcCkge1xuICAgICAgaWYgKCFyZXNwIHx8IHJlc3AgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXNwKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZSAmJiBjb25zb2xlLmxvZyhcImZhaWxlZCB0byBwYXJzZSBKU09OIHJlc3BvbnNlXCIsIHJlc3ApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHNlcmlhbGl6ZShvYmosIHBhcmVudEtleSkge1xuICAgICAgbGV0IHF1ZXJ5U3RyID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJhbUtleSA9IHBhcmVudEtleSA/IGAke3BhcmVudEtleX1bJHtrZXl9XWAgOiBrZXk7XG4gICAgICAgIGxldCBwYXJhbVZhbCA9IG9ialtrZXldO1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtVmFsID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgcXVlcnlTdHIucHVzaCh0aGlzLnNlcmlhbGl6ZShwYXJhbVZhbCwgcGFyYW1LZXkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxdWVyeVN0ci5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChwYXJhbUtleSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbVZhbCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcXVlcnlTdHIuam9pbihcIiZcIik7XG4gICAgfVxuICAgIHN0YXRpYyBhcHBlbmRQYXJhbXModXJsLCBwYXJhbXMpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhwYXJhbXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgfVxuICAgICAgbGV0IHByZWZpeCA9IHVybC5tYXRjaCgvXFw/LykgPyBcIiZcIiA6IFwiP1wiO1xuICAgICAgcmV0dXJuIGAke3VybH0ke3ByZWZpeH0ke3RoaXMuc2VyaWFsaXplKHBhcmFtcyl9YDtcbiAgICB9XG4gIH07XG5cbiAgLy8ganMvcGhvZW5peC9sb25ncG9sbC5qc1xuICB2YXIgTG9uZ1BvbGwgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoZW5kUG9pbnQpIHtcbiAgICAgIHRoaXMuZW5kUG9pbnQgPSBudWxsO1xuICAgICAgdGhpcy50b2tlbiA9IG51bGw7XG4gICAgICB0aGlzLnNraXBIZWFydGJlYXQgPSB0cnVlO1xuICAgICAgdGhpcy5yZXFzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHRoaXMub25vcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgdGhpcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIH07XG4gICAgICB0aGlzLnBvbGxFbmRwb2ludCA9IHRoaXMubm9ybWFsaXplRW5kcG9pbnQoZW5kUG9pbnQpO1xuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nO1xuICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfVxuICAgIG5vcm1hbGl6ZUVuZHBvaW50KGVuZFBvaW50KSB7XG4gICAgICByZXR1cm4gZW5kUG9pbnQucmVwbGFjZShcIndzOi8vXCIsIFwiaHR0cDovL1wiKS5yZXBsYWNlKFwid3NzOi8vXCIsIFwiaHR0cHM6Ly9cIikucmVwbGFjZShuZXcgUmVnRXhwKFwiKC4qKS9cIiArIFRSQU5TUE9SVFMud2Vic29ja2V0KSwgXCIkMS9cIiArIFRSQU5TUE9SVFMubG9uZ3BvbGwpO1xuICAgIH1cbiAgICBlbmRwb2ludFVSTCgpIHtcbiAgICAgIHJldHVybiBBamF4LmFwcGVuZFBhcmFtcyh0aGlzLnBvbGxFbmRwb2ludCwgeyB0b2tlbjogdGhpcy50b2tlbiB9KTtcbiAgICB9XG4gICAgY2xvc2VBbmRSZXRyeShjb2RlLCByZWFzb24sIHdhc0NsZWFuKSB7XG4gICAgICB0aGlzLmNsb3NlKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pO1xuICAgICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nO1xuICAgIH1cbiAgICBvbnRpbWVvdXQoKSB7XG4gICAgICB0aGlzLm9uZXJyb3IoXCJ0aW1lb3V0XCIpO1xuICAgICAgdGhpcy5jbG9zZUFuZFJldHJ5KDEwMDUsIFwidGltZW91dFwiLCBmYWxzZSk7XG4gICAgfVxuICAgIGlzQWN0aXZlKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5vcGVuIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nO1xuICAgIH1cbiAgICBwb2xsKCkge1xuICAgICAgdGhpcy5hamF4KFwiR0VUXCIsIG51bGwsICgpID0+IHRoaXMub250aW1lb3V0KCksIChyZXNwKSA9PiB7XG4gICAgICAgIGlmIChyZXNwKSB7XG4gICAgICAgICAgdmFyIHsgc3RhdHVzLCB0b2tlbiwgbWVzc2FnZXMgfSA9IHJlc3A7XG4gICAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXR1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICBjYXNlIDIwMDpcbiAgICAgICAgICAgIG1lc3NhZ2VzLmZvckVhY2goKG1zZykgPT4ge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMub25tZXNzYWdlKHsgZGF0YTogbXNnIH0pLCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDIwNDpcbiAgICAgICAgICAgIHRoaXMucG9sbCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0MTA6XG4gICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLm9wZW47XG4gICAgICAgICAgICB0aGlzLm9ub3Blbih7fSk7XG4gICAgICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDAzOlxuICAgICAgICAgICAgdGhpcy5vbmVycm9yKDQwMyk7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKDEwMDgsIFwiZm9yYmlkZGVuXCIsIGZhbHNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYXNlIDUwMDpcbiAgICAgICAgICAgIHRoaXMub25lcnJvcig1MDApO1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFuZFJldHJ5KDEwMTEsIFwiaW50ZXJuYWwgc2VydmVyIGVycm9yXCIsIDUwMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgcG9sbCBzdGF0dXMgJHtzdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kKGJvZHkpIHtcbiAgICAgIHRoaXMuYWpheChcIlBPU1RcIiwgYm9keSwgKCkgPT4gdGhpcy5vbmVycm9yKFwidGltZW91dFwiKSwgKHJlc3ApID0+IHtcbiAgICAgICAgaWYgKCFyZXNwIHx8IHJlc3Auc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICB0aGlzLm9uZXJyb3IocmVzcCAmJiByZXNwLnN0YXR1cyk7XG4gICAgICAgICAgdGhpcy5jbG9zZUFuZFJldHJ5KDEwMTEsIFwiaW50ZXJuYWwgc2VydmVyIGVycm9yXCIsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNsb3NlKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pIHtcbiAgICAgIGZvciAobGV0IHJlcSBvZiB0aGlzLnJlcXMpIHtcbiAgICAgICAgcmVxLmFib3J0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSBTT0NLRVRfU1RBVEVTLmNsb3NlZDtcbiAgICAgIGxldCBvcHRzID0gT2JqZWN0LmFzc2lnbih7IGNvZGU6IDFlMywgcmVhc29uOiB2b2lkIDAsIHdhc0NsZWFuOiB0cnVlIH0sIHsgY29kZSwgcmVhc29uLCB3YXNDbGVhbiB9KTtcbiAgICAgIGlmICh0eXBlb2YgQ2xvc2VFdmVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLm9uY2xvc2UobmV3IENsb3NlRXZlbnQoXCJjbG9zZVwiLCBvcHRzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uY2xvc2Uob3B0cyk7XG4gICAgICB9XG4gICAgfVxuICAgIGFqYXgobWV0aG9kLCBib2R5LCBvbkNhbGxlclRpbWVvdXQsIGNhbGxiYWNrKSB7XG4gICAgICBsZXQgcmVxO1xuICAgICAgbGV0IG9udGltZW91dCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5yZXFzLmRlbGV0ZShyZXEpO1xuICAgICAgICBvbkNhbGxlclRpbWVvdXQoKTtcbiAgICAgIH07XG4gICAgICByZXEgPSBBamF4LnJlcXVlc3QobWV0aG9kLCB0aGlzLmVuZHBvaW50VVJMKCksIFwiYXBwbGljYXRpb24vanNvblwiLCBib2R5LCB0aGlzLnRpbWVvdXQsIG9udGltZW91dCwgKHJlc3ApID0+IHtcbiAgICAgICAgdGhpcy5yZXFzLmRlbGV0ZShyZXEpO1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgY2FsbGJhY2socmVzcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5yZXFzLmFkZChyZXEpO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L3ByZXNlbmNlLmpzXG4gIHZhciBQcmVzZW5jZSA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBvcHRzID0ge30pIHtcbiAgICAgIGxldCBldmVudHMgPSBvcHRzLmV2ZW50cyB8fCB7IHN0YXRlOiBcInByZXNlbmNlX3N0YXRlXCIsIGRpZmY6IFwicHJlc2VuY2VfZGlmZlwiIH07XG4gICAgICB0aGlzLnN0YXRlID0ge307XG4gICAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdO1xuICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgIHRoaXMuam9pblJlZiA9IG51bGw7XG4gICAgICB0aGlzLmNhbGxlciA9IHtcbiAgICAgICAgb25Kb2luOiBmdW5jdGlvbigpIHtcbiAgICAgICAgfSxcbiAgICAgICAgb25MZWF2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3luYzogZnVuY3Rpb24oKSB7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLmNoYW5uZWwub24oZXZlbnRzLnN0YXRlLCAobmV3U3RhdGUpID0+IHtcbiAgICAgICAgbGV0IHsgb25Kb2luLCBvbkxlYXZlLCBvblN5bmMgfSA9IHRoaXMuY2FsbGVyO1xuICAgICAgICB0aGlzLmpvaW5SZWYgPSB0aGlzLmNoYW5uZWwuam9pblJlZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY1N0YXRlKHRoaXMuc3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcy5mb3JFYWNoKChkaWZmKSA9PiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IFByZXNlbmNlLnN5bmNEaWZmKHRoaXMuc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdO1xuICAgICAgICBvblN5bmMoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jaGFubmVsLm9uKGV2ZW50cy5kaWZmLCAoZGlmZikgPT4ge1xuICAgICAgICBsZXQgeyBvbkpvaW4sIG9uTGVhdmUsIG9uU3luYyB9ID0gdGhpcy5jYWxsZXI7XG4gICAgICAgIGlmICh0aGlzLmluUGVuZGluZ1N5bmNTdGF0ZSgpKSB7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nRGlmZnMucHVzaChkaWZmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICAgICAgICBvblN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIG9uSm9pbihjYWxsYmFjaykge1xuICAgICAgdGhpcy5jYWxsZXIub25Kb2luID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIG9uTGVhdmUoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuY2FsbGVyLm9uTGVhdmUgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgb25TeW5jKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxlci5vblN5bmMgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgbGlzdChieSkge1xuICAgICAgcmV0dXJuIFByZXNlbmNlLmxpc3QodGhpcy5zdGF0ZSwgYnkpO1xuICAgIH1cbiAgICBpblBlbmRpbmdTeW5jU3RhdGUoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuam9pblJlZiB8fCB0aGlzLmpvaW5SZWYgIT09IHRoaXMuY2hhbm5lbC5qb2luUmVmKCk7XG4gICAgfVxuICAgIHN0YXRpYyBzeW5jU3RhdGUoY3VycmVudFN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKSB7XG4gICAgICBsZXQgc3RhdGUgPSB0aGlzLmNsb25lKGN1cnJlbnRTdGF0ZSk7XG4gICAgICBsZXQgam9pbnMgPSB7fTtcbiAgICAgIGxldCBsZWF2ZXMgPSB7fTtcbiAgICAgIHRoaXMubWFwKHN0YXRlLCAoa2V5LCBwcmVzZW5jZSkgPT4ge1xuICAgICAgICBpZiAoIW5ld1N0YXRlW2tleV0pIHtcbiAgICAgICAgICBsZWF2ZXNba2V5XSA9IHByZXNlbmNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMubWFwKG5ld1N0YXRlLCAoa2V5LCBuZXdQcmVzZW5jZSkgPT4ge1xuICAgICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XTtcbiAgICAgICAgaWYgKGN1cnJlbnRQcmVzZW5jZSkge1xuICAgICAgICAgIGxldCBuZXdSZWZzID0gbmV3UHJlc2VuY2UubWV0YXMubWFwKChtKSA9PiBtLnBoeF9yZWYpO1xuICAgICAgICAgIGxldCBjdXJSZWZzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLm1hcCgobSkgPT4gbS5waHhfcmVmKTtcbiAgICAgICAgICBsZXQgam9pbmVkTWV0YXMgPSBuZXdQcmVzZW5jZS5tZXRhcy5maWx0ZXIoKG0pID0+IGN1clJlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMCk7XG4gICAgICAgICAgbGV0IGxlZnRNZXRhcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5maWx0ZXIoKG0pID0+IG5ld1JlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMCk7XG4gICAgICAgICAgaWYgKGpvaW5lZE1ldGFzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGpvaW5zW2tleV0gPSBuZXdQcmVzZW5jZTtcbiAgICAgICAgICAgIGpvaW5zW2tleV0ubWV0YXMgPSBqb2luZWRNZXRhcztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxlZnRNZXRhcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZWF2ZXNba2V5XSA9IHRoaXMuY2xvbmUoY3VycmVudFByZXNlbmNlKTtcbiAgICAgICAgICAgIGxlYXZlc1trZXldLm1ldGFzID0gbGVmdE1ldGFzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuc3luY0RpZmYoc3RhdGUsIHsgam9pbnMsIGxlYXZlcyB9LCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgIH1cbiAgICBzdGF0aWMgc3luY0RpZmYoc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSkge1xuICAgICAgbGV0IHsgam9pbnMsIGxlYXZlcyB9ID0gdGhpcy5jbG9uZShkaWZmKTtcbiAgICAgIGlmICghb25Kb2luKSB7XG4gICAgICAgIG9uSm9pbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKCFvbkxlYXZlKSB7XG4gICAgICAgIG9uTGVhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFwKGpvaW5zLCAoa2V5LCBuZXdQcmVzZW5jZSkgPT4ge1xuICAgICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XTtcbiAgICAgICAgc3RhdGVba2V5XSA9IHRoaXMuY2xvbmUobmV3UHJlc2VuY2UpO1xuICAgICAgICBpZiAoY3VycmVudFByZXNlbmNlKSB7XG4gICAgICAgICAgbGV0IGpvaW5lZFJlZnMgPSBzdGF0ZVtrZXldLm1ldGFzLm1hcCgobSkgPT4gbS5waHhfcmVmKTtcbiAgICAgICAgICBsZXQgY3VyTWV0YXMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMuZmlsdGVyKChtKSA9PiBqb2luZWRSZWZzLmluZGV4T2YobS5waHhfcmVmKSA8IDApO1xuICAgICAgICAgIHN0YXRlW2tleV0ubWV0YXMudW5zaGlmdCguLi5jdXJNZXRhcyk7XG4gICAgICAgIH1cbiAgICAgICAgb25Kb2luKGtleSwgY3VycmVudFByZXNlbmNlLCBuZXdQcmVzZW5jZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubWFwKGxlYXZlcywgKGtleSwgbGVmdFByZXNlbmNlKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50UHJlc2VuY2UgPSBzdGF0ZVtrZXldO1xuICAgICAgICBpZiAoIWN1cnJlbnRQcmVzZW5jZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVmc1RvUmVtb3ZlID0gbGVmdFByZXNlbmNlLm1ldGFzLm1hcCgobSkgPT4gbS5waHhfcmVmKTtcbiAgICAgICAgY3VycmVudFByZXNlbmNlLm1ldGFzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLmZpbHRlcigocCkgPT4ge1xuICAgICAgICAgIHJldHVybiByZWZzVG9SZW1vdmUuaW5kZXhPZihwLnBoeF9yZWYpIDwgMDtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uTGVhdmUoa2V5LCBjdXJyZW50UHJlc2VuY2UsIGxlZnRQcmVzZW5jZSk7XG4gICAgICAgIGlmIChjdXJyZW50UHJlc2VuY2UubWV0YXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIHN0YXRlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBzdGF0aWMgbGlzdChwcmVzZW5jZXMsIGNob29zZXIpIHtcbiAgICAgIGlmICghY2hvb3Nlcikge1xuICAgICAgICBjaG9vc2VyID0gZnVuY3Rpb24oa2V5LCBwcmVzKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXM7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tYXAocHJlc2VuY2VzLCAoa2V5LCBwcmVzZW5jZSkgPT4ge1xuICAgICAgICByZXR1cm4gY2hvb3NlcihrZXksIHByZXNlbmNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgbWFwKG9iaiwgZnVuYykge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubWFwKChrZXkpID0+IGZ1bmMoa2V5LCBvYmpba2V5XSkpO1xuICAgIH1cbiAgICBzdGF0aWMgY2xvbmUob2JqKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgICB9XG4gIH07XG5cbiAgLy8ganMvcGhvZW5peC9zZXJpYWxpemVyLmpzXG4gIHZhciBzZXJpYWxpemVyX2RlZmF1bHQgPSB7XG4gICAgSEVBREVSX0xFTkdUSDogMSxcbiAgICBNRVRBX0xFTkdUSDogNCxcbiAgICBLSU5EUzogeyBwdXNoOiAwLCByZXBseTogMSwgYnJvYWRjYXN0OiAyIH0sXG4gICAgZW5jb2RlKG1zZywgY2FsbGJhY2spIHtcbiAgICAgIGlmIChtc2cucGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuYmluYXJ5RW5jb2RlKG1zZykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHBheWxvYWQgPSBbbXNnLmpvaW5fcmVmLCBtc2cucmVmLCBtc2cudG9waWMsIG1zZy5ldmVudCwgbXNnLnBheWxvYWRdO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVjb2RlKHJhd1BheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAocmF3UGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuYmluYXJ5RGVjb2RlKHJhd1BheWxvYWQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBbam9pbl9yZWYsIHJlZiwgdG9waWMsIGV2ZW50LCBwYXlsb2FkXSA9IEpTT04ucGFyc2UocmF3UGF5bG9hZCk7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayh7IGpvaW5fcmVmLCByZWYsIHRvcGljLCBldmVudCwgcGF5bG9hZCB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGJpbmFyeUVuY29kZShtZXNzYWdlKSB7XG4gICAgICBsZXQgeyBqb2luX3JlZiwgcmVmLCBldmVudCwgdG9waWMsIHBheWxvYWQgfSA9IG1lc3NhZ2U7XG4gICAgICBsZXQgbWV0YUxlbmd0aCA9IHRoaXMuTUVUQV9MRU5HVEggKyBqb2luX3JlZi5sZW5ndGggKyByZWYubGVuZ3RoICsgdG9waWMubGVuZ3RoICsgZXZlbnQubGVuZ3RoO1xuICAgICAgbGV0IGhlYWRlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLkhFQURFUl9MRU5HVEggKyBtZXRhTGVuZ3RoKTtcbiAgICAgIGxldCB2aWV3ID0gbmV3IERhdGFWaWV3KGhlYWRlcik7XG4gICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHRoaXMuS0lORFMucHVzaCk7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBqb2luX3JlZi5sZW5ndGgpO1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgcmVmLmxlbmd0aCk7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCB0b3BpYy5sZW5ndGgpO1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgZXZlbnQubGVuZ3RoKTtcbiAgICAgIEFycmF5LmZyb20oam9pbl9yZWYsIChjaGFyKSA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgIEFycmF5LmZyb20ocmVmLCAoY2hhcikgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSk7XG4gICAgICBBcnJheS5mcm9tKHRvcGljLCAoY2hhcikgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSk7XG4gICAgICBBcnJheS5mcm9tKGV2ZW50LCAoY2hhcikgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSk7XG4gICAgICB2YXIgY29tYmluZWQgPSBuZXcgVWludDhBcnJheShoZWFkZXIuYnl0ZUxlbmd0aCArIHBheWxvYWQuYnl0ZUxlbmd0aCk7XG4gICAgICBjb21iaW5lZC5zZXQobmV3IFVpbnQ4QXJyYXkoaGVhZGVyKSwgMCk7XG4gICAgICBjb21iaW5lZC5zZXQobmV3IFVpbnQ4QXJyYXkocGF5bG9hZCksIGhlYWRlci5ieXRlTGVuZ3RoKTtcbiAgICAgIHJldHVybiBjb21iaW5lZC5idWZmZXI7XG4gICAgfSxcbiAgICBiaW5hcnlEZWNvZGUoYnVmZmVyKSB7XG4gICAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgICAgbGV0IGtpbmQgPSB2aWV3LmdldFVpbnQ4KDApO1xuICAgICAgbGV0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICBjYXNlIHRoaXMuS0lORFMucHVzaDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVQdXNoKGJ1ZmZlciwgdmlldywgZGVjb2Rlcik7XG4gICAgICAgIGNhc2UgdGhpcy5LSU5EUy5yZXBseTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVSZXBseShidWZmZXIsIHZpZXcsIGRlY29kZXIpO1xuICAgICAgICBjYXNlIHRoaXMuS0lORFMuYnJvYWRjYXN0OlxuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVjb2RlUHVzaChidWZmZXIsIHZpZXcsIGRlY29kZXIpIHtcbiAgICAgIGxldCBqb2luUmVmU2l6ZSA9IHZpZXcuZ2V0VWludDgoMSk7XG4gICAgICBsZXQgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgyKTtcbiAgICAgIGxldCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDMpO1xuICAgICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIHRoaXMuTUVUQV9MRU5HVEggLSAxO1xuICAgICAgbGV0IGpvaW5SZWYgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBqb2luUmVmU2l6ZSkpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgam9pblJlZlNpemU7XG4gICAgICBsZXQgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZTtcbiAgICAgIGxldCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplO1xuICAgICAgbGV0IGRhdGEgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICByZXR1cm4geyBqb2luX3JlZjogam9pblJlZiwgcmVmOiBudWxsLCB0b3BpYywgZXZlbnQsIHBheWxvYWQ6IGRhdGEgfTtcbiAgICB9LFxuICAgIGRlY29kZVJlcGx5KGJ1ZmZlciwgdmlldywgZGVjb2Rlcikge1xuICAgICAgbGV0IGpvaW5SZWZTaXplID0gdmlldy5nZXRVaW50OCgxKTtcbiAgICAgIGxldCByZWZTaXplID0gdmlldy5nZXRVaW50OCgyKTtcbiAgICAgIGxldCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDMpO1xuICAgICAgbGV0IGV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoNCk7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgdGhpcy5NRVRBX0xFTkdUSDtcbiAgICAgIGxldCBqb2luUmVmID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgam9pblJlZlNpemUpKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIGpvaW5SZWZTaXplO1xuICAgICAgbGV0IHJlZiA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHJlZlNpemUpKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIHJlZlNpemU7XG4gICAgICBsZXQgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKTtcbiAgICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZTtcbiAgICAgIGxldCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplO1xuICAgICAgbGV0IGRhdGEgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICBsZXQgcGF5bG9hZCA9IHsgc3RhdHVzOiBldmVudCwgcmVzcG9uc2U6IGRhdGEgfTtcbiAgICAgIHJldHVybiB7IGpvaW5fcmVmOiBqb2luUmVmLCByZWYsIHRvcGljLCBldmVudDogQ0hBTk5FTF9FVkVOVFMucmVwbHksIHBheWxvYWQgfTtcbiAgICB9LFxuICAgIGRlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpIHtcbiAgICAgIGxldCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDEpO1xuICAgICAgbGV0IGV2ZW50U2l6ZSA9IHZpZXcuZ2V0VWludDgoMik7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgMjtcbiAgICAgIGxldCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpO1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplO1xuICAgICAgbGV0IGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSk7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemU7XG4gICAgICBsZXQgZGF0YSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgIHJldHVybiB7IGpvaW5fcmVmOiBudWxsLCByZWY6IG51bGwsIHRvcGljLCBldmVudCwgcGF5bG9hZDogZGF0YSB9O1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4L3NvY2tldC5qc1xuICB2YXIgU29ja2V0ID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGVuZFBvaW50LCBvcHRzID0ge30pIHtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MgPSB7IG9wZW46IFtdLCBjbG9zZTogW10sIGVycm9yOiBbXSwgbWVzc2FnZTogW10gfTtcbiAgICAgIHRoaXMuY2hhbm5lbHMgPSBbXTtcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICAgICAgdGhpcy5yZWYgPSAwO1xuICAgICAgdGhpcy50aW1lb3V0ID0gb3B0cy50aW1lb3V0IHx8IERFRkFVTFRfVElNRU9VVDtcbiAgICAgIHRoaXMudHJhbnNwb3J0ID0gb3B0cy50cmFuc3BvcnQgfHwgZ2xvYmFsLldlYlNvY2tldCB8fCBMb25nUG9sbDtcbiAgICAgIHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9ucyA9IDA7XG4gICAgICB0aGlzLmRlZmF1bHRFbmNvZGVyID0gc2VyaWFsaXplcl9kZWZhdWx0LmVuY29kZS5iaW5kKHNlcmlhbGl6ZXJfZGVmYXVsdCk7XG4gICAgICB0aGlzLmRlZmF1bHREZWNvZGVyID0gc2VyaWFsaXplcl9kZWZhdWx0LmRlY29kZS5iaW5kKHNlcmlhbGl6ZXJfZGVmYXVsdCk7XG4gICAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuYmluYXJ5VHlwZSA9IG9wdHMuYmluYXJ5VHlwZSB8fCBcImFycmF5YnVmZmVyXCI7XG4gICAgICB0aGlzLmNvbm5lY3RDbG9jayA9IDE7XG4gICAgICBpZiAodGhpcy50cmFuc3BvcnQgIT09IExvbmdQb2xsKSB7XG4gICAgICAgIHRoaXMuZW5jb2RlID0gb3B0cy5lbmNvZGUgfHwgdGhpcy5kZWZhdWx0RW5jb2RlcjtcbiAgICAgICAgdGhpcy5kZWNvZGUgPSBvcHRzLmRlY29kZSB8fCB0aGlzLmRlZmF1bHREZWNvZGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbmNvZGUgPSB0aGlzLmRlZmF1bHRFbmNvZGVyO1xuICAgICAgICB0aGlzLmRlY29kZSA9IHRoaXMuZGVmYXVsdERlY29kZXI7XG4gICAgICB9XG4gICAgICBsZXQgYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9IG51bGw7XG4gICAgICBpZiAocGh4V2luZG93ICYmIHBoeFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHBoeFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgKF9lKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID0gdGhpcy5jb25uZWN0Q2xvY2s7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGh4V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLCAoX2UpID0+IHtcbiAgICAgICAgICBpZiAoYXdhaXRpbmdDb25uZWN0aW9uT25QYWdlU2hvdyA9PT0gdGhpcy5jb25uZWN0Q2xvY2spIHtcbiAgICAgICAgICAgIGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyA9IG9wdHMuaGVhcnRiZWF0SW50ZXJ2YWxNcyB8fCAzZTQ7XG4gICAgICB0aGlzLnJlam9pbkFmdGVyTXMgPSAodHJpZXMpID0+IHtcbiAgICAgICAgaWYgKG9wdHMucmVqb2luQWZ0ZXJNcykge1xuICAgICAgICAgIHJldHVybiBvcHRzLnJlam9pbkFmdGVyTXModHJpZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbMWUzLCAyZTMsIDVlM11bdHJpZXMgLSAxXSB8fCAxZTQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLnJlY29ubmVjdEFmdGVyTXMgPSAodHJpZXMpID0+IHtcbiAgICAgICAgaWYgKG9wdHMucmVjb25uZWN0QWZ0ZXJNcykge1xuICAgICAgICAgIHJldHVybiBvcHRzLnJlY29ubmVjdEFmdGVyTXModHJpZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbMTAsIDUwLCAxMDAsIDE1MCwgMjAwLCAyNTAsIDUwMCwgMWUzLCAyZTNdW3RyaWVzIC0gMV0gfHwgNWUzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5sb2dnZXIgPSBvcHRzLmxvZ2dlciB8fCBudWxsO1xuICAgICAgdGhpcy5sb25ncG9sbGVyVGltZW91dCA9IG9wdHMubG9uZ3BvbGxlclRpbWVvdXQgfHwgMmU0O1xuICAgICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKG9wdHMucGFyYW1zIHx8IHt9KTtcbiAgICAgIHRoaXMuZW5kUG9pbnQgPSBgJHtlbmRQb2ludH0vJHtUUkFOU1BPUlRTLndlYnNvY2tldH1gO1xuICAgICAgdGhpcy52c24gPSBvcHRzLnZzbiB8fCBERUZBVUxUX1ZTTjtcbiAgICAgIHRoaXMuaGVhcnRiZWF0VGltZW91dFRpbWVyID0gbnVsbDtcbiAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBudWxsO1xuICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbDtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBuZXcgVGltZXIoKCkgPT4ge1xuICAgICAgICB0aGlzLnRlYXJkb3duKCgpID0+IHRoaXMuY29ubmVjdCgpKTtcbiAgICAgIH0sIHRoaXMucmVjb25uZWN0QWZ0ZXJNcyk7XG4gICAgfVxuICAgIGdldExvbmdQb2xsVHJhbnNwb3J0KCkge1xuICAgICAgcmV0dXJuIExvbmdQb2xsO1xuICAgIH1cbiAgICByZXBsYWNlVHJhbnNwb3J0KG5ld1RyYW5zcG9ydCkge1xuICAgICAgdGhpcy5jb25uZWN0Q2xvY2srKztcbiAgICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IHRydWU7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnJlc2V0KCk7XG4gICAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuY29ubiA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYW5zcG9ydCA9IG5ld1RyYW5zcG9ydDtcbiAgICB9XG4gICAgcHJvdG9jb2woKSB7XG4gICAgICByZXR1cm4gbG9jYXRpb24ucHJvdG9jb2wubWF0Y2goL15odHRwcy8pID8gXCJ3c3NcIiA6IFwid3NcIjtcbiAgICB9XG4gICAgZW5kUG9pbnRVUkwoKSB7XG4gICAgICBsZXQgdXJpID0gQWpheC5hcHBlbmRQYXJhbXMoQWpheC5hcHBlbmRQYXJhbXModGhpcy5lbmRQb2ludCwgdGhpcy5wYXJhbXMoKSksIHsgdnNuOiB0aGlzLnZzbiB9KTtcbiAgICAgIGlmICh1cmkuY2hhckF0KDApICE9PSBcIi9cIikge1xuICAgICAgICByZXR1cm4gdXJpO1xuICAgICAgfVxuICAgICAgaWYgKHVyaS5jaGFyQXQoMSkgPT09IFwiL1wiKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnByb3RvY29sKCl9OiR7dXJpfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYCR7dGhpcy5wcm90b2NvbCgpfTovLyR7bG9jYXRpb24uaG9zdH0ke3VyaX1gO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KGNhbGxiYWNrLCBjb2RlLCByZWFzb24pIHtcbiAgICAgIHRoaXMuY29ubmVjdENsb2NrKys7XG4gICAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSB0cnVlO1xuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpO1xuICAgICAgdGhpcy50ZWFyZG93bihjYWxsYmFjaywgY29kZSwgcmVhc29uKTtcbiAgICB9XG4gICAgY29ubmVjdChwYXJhbXMpIHtcbiAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgY29uc29sZSAmJiBjb25zb2xlLmxvZyhcInBhc3NpbmcgcGFyYW1zIHRvIGNvbm5lY3QgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCBwYXNzIDpwYXJhbXMgdG8gdGhlIFNvY2tldCBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBjbG9zdXJlKHBhcmFtcyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29ubmVjdENsb2NrKys7XG4gICAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuY29ubiA9IG5ldyB0aGlzLnRyYW5zcG9ydCh0aGlzLmVuZFBvaW50VVJMKCkpO1xuICAgICAgdGhpcy5jb25uLmJpbmFyeVR5cGUgPSB0aGlzLmJpbmFyeVR5cGU7XG4gICAgICB0aGlzLmNvbm4udGltZW91dCA9IHRoaXMubG9uZ3BvbGxlclRpbWVvdXQ7XG4gICAgICB0aGlzLmNvbm4ub25vcGVuID0gKCkgPT4gdGhpcy5vbkNvbm5PcGVuKCk7XG4gICAgICB0aGlzLmNvbm4ub25lcnJvciA9IChlcnJvcikgPT4gdGhpcy5vbkNvbm5FcnJvcihlcnJvcik7XG4gICAgICB0aGlzLmNvbm4ub25tZXNzYWdlID0gKGV2ZW50KSA9PiB0aGlzLm9uQ29ubk1lc3NhZ2UoZXZlbnQpO1xuICAgICAgdGhpcy5jb25uLm9uY2xvc2UgPSAoZXZlbnQpID0+IHRoaXMub25Db25uQ2xvc2UoZXZlbnQpO1xuICAgIH1cbiAgICBsb2coa2luZCwgbXNnLCBkYXRhKSB7XG4gICAgICB0aGlzLmxvZ2dlcihraW5kLCBtc2csIGRhdGEpO1xuICAgIH1cbiAgICBoYXNMb2dnZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2dnZXIgIT09IG51bGw7XG4gICAgfVxuICAgIG9uT3BlbihjYWxsYmFjaykge1xuICAgICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpO1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5vcGVuLnB1c2goW3JlZiwgY2FsbGJhY2tdKTtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfVxuICAgIG9uQ2xvc2UoY2FsbGJhY2spIHtcbiAgICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKTtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UucHVzaChbcmVmLCBjYWxsYmFja10pO1xuICAgICAgcmV0dXJuIHJlZjtcbiAgICB9XG4gICAgb25FcnJvcihjYWxsYmFjaykge1xuICAgICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpO1xuICAgICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5lcnJvci5wdXNoKFtyZWYsIGNhbGxiYWNrXSk7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH1cbiAgICBvbk1lc3NhZ2UoY2FsbGJhY2spIHtcbiAgICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKTtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZS5wdXNoKFtyZWYsIGNhbGxiYWNrXSk7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH1cbiAgICBwaW5nKGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKCk7XG4gICAgICBsZXQgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIHRoaXMucHVzaCh7IHRvcGljOiBcInBob2VuaXhcIiwgZXZlbnQ6IFwiaGVhcnRiZWF0XCIsIHBheWxvYWQ6IHt9LCByZWYgfSk7XG4gICAgICBsZXQgb25Nc2dSZWYgPSB0aGlzLm9uTWVzc2FnZSgobXNnKSA9PiB7XG4gICAgICAgIGlmIChtc2cucmVmID09PSByZWYpIHtcbiAgICAgICAgICB0aGlzLm9mZihbb25Nc2dSZWZdKTtcbiAgICAgICAgICBjYWxsYmFjayhEYXRlLm5vdygpIC0gc3RhcnRUaW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2xlYXJIZWFydGJlYXRzKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVhcnRiZWF0VGltZW91dFRpbWVyKTtcbiAgICB9XG4gICAgb25Db25uT3BlbigpIHtcbiAgICAgIGlmICh0aGlzLmhhc0xvZ2dlcigpKVxuICAgICAgICB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBgY29ubmVjdGVkIHRvICR7dGhpcy5lbmRQb2ludFVSTCgpfWApO1xuICAgICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gZmFsc2U7XG4gICAgICB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbnMrKztcbiAgICAgIHRoaXMuZmx1c2hTZW5kQnVmZmVyKCk7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnJlc2V0KCk7XG4gICAgICB0aGlzLnJlc2V0SGVhcnRiZWF0KCk7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm9wZW4uZm9yRWFjaCgoWywgY2FsbGJhY2tdKSA9PiBjYWxsYmFjaygpKTtcbiAgICB9XG4gICAgaGVhcnRiZWF0VGltZW91dCgpIHtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaGFzTG9nZ2VyKCkpIHtcbiAgICAgICAgICB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBcImhlYXJ0YmVhdCB0aW1lb3V0LiBBdHRlbXB0aW5nIHRvIHJlLWVzdGFibGlzaCBjb25uZWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZ2dlckNoYW5FcnJvcigpO1xuICAgICAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy50ZWFyZG93bigoKSA9PiB0aGlzLnJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpLCBXU19DTE9TRV9OT1JNQUwsIFwiaGVhcnRiZWF0IHRpbWVvdXRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc2V0SGVhcnRiZWF0KCkge1xuICAgICAgaWYgKHRoaXMuY29ubiAmJiB0aGlzLmNvbm4uc2tpcEhlYXJ0YmVhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsO1xuICAgICAgdGhpcy5jbGVhckhlYXJ0YmVhdHMoKTtcbiAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VuZEhlYXJ0YmVhdCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpO1xuICAgIH1cbiAgICB0ZWFyZG93bihjYWxsYmFjaywgY29kZSwgcmVhc29uKSB7XG4gICAgICBpZiAoIXRoaXMuY29ubikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICAgIHRoaXMud2FpdEZvckJ1ZmZlckRvbmUoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubi5jbG9zZShjb2RlLCByZWFzb24gfHwgXCJcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29ubi5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhaXRGb3JTb2NrZXRDbG9zZWQoKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgICAgICAgIHRoaXMuY29ubi5vbm9wZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmNvbm4ub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuY29ubi5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmNvbm4ub25jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuY29ubiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHdhaXRGb3JCdWZmZXJEb25lKGNhbGxiYWNrLCB0cmllcyA9IDEpIHtcbiAgICAgIGlmICh0cmllcyA9PT0gNSB8fCAhdGhpcy5jb25uIHx8ICF0aGlzLmNvbm4uYnVmZmVyZWRBbW91bnQpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMud2FpdEZvckJ1ZmZlckRvbmUoY2FsbGJhY2ssIHRyaWVzICsgMSk7XG4gICAgICB9LCAxNTAgKiB0cmllcyk7XG4gICAgfVxuICAgIHdhaXRGb3JTb2NrZXRDbG9zZWQoY2FsbGJhY2ssIHRyaWVzID0gMSkge1xuICAgICAgaWYgKHRyaWVzID09PSA1IHx8ICF0aGlzLmNvbm4gfHwgdGhpcy5jb25uLnJlYWR5U3RhdGUgPT09IFNPQ0tFVF9TVEFURVMuY2xvc2VkKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLndhaXRGb3JTb2NrZXRDbG9zZWQoY2FsbGJhY2ssIHRyaWVzICsgMSk7XG4gICAgICB9LCAxNTAgKiB0cmllcyk7XG4gICAgfVxuICAgIG9uQ29ubkNsb3NlKGV2ZW50KSB7XG4gICAgICBsZXQgY2xvc2VDb2RlID0gZXZlbnQgJiYgZXZlbnQuY29kZTtcbiAgICAgIGlmICh0aGlzLmhhc0xvZ2dlcigpKVxuICAgICAgICB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBcImNsb3NlXCIsIGV2ZW50KTtcbiAgICAgIHRoaXMudHJpZ2dlckNoYW5FcnJvcigpO1xuICAgICAgdGhpcy5jbGVhckhlYXJ0YmVhdHMoKTtcbiAgICAgIGlmICghdGhpcy5jbG9zZVdhc0NsZWFuICYmIGNsb3NlQ29kZSAhPT0gMWUzKSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0VGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmNsb3NlLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4gY2FsbGJhY2soZXZlbnQpKTtcbiAgICB9XG4gICAgb25Db25uRXJyb3IoZXJyb3IpIHtcbiAgICAgIGlmICh0aGlzLmhhc0xvZ2dlcigpKVxuICAgICAgICB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBlcnJvcik7XG4gICAgICBsZXQgdHJhbnNwb3J0QmVmb3JlID0gdGhpcy50cmFuc3BvcnQ7XG4gICAgICBsZXQgZXN0YWJsaXNoZWRCZWZvcmUgPSB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbnM7XG4gICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmVycm9yLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4ge1xuICAgICAgICBjYWxsYmFjayhlcnJvciwgdHJhbnNwb3J0QmVmb3JlLCBlc3RhYmxpc2hlZEJlZm9yZSk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0cmFuc3BvcnRCZWZvcmUgPT09IHRoaXMudHJhbnNwb3J0IHx8IGVzdGFibGlzaGVkQmVmb3JlID4gMCkge1xuICAgICAgICB0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJpZ2dlckNoYW5FcnJvcigpIHtcbiAgICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaCgoY2hhbm5lbCkgPT4ge1xuICAgICAgICBpZiAoIShjaGFubmVsLmlzRXJyb3JlZCgpIHx8IGNoYW5uZWwuaXNMZWF2aW5nKCkgfHwgY2hhbm5lbC5pc0Nsb3NlZCgpKSkge1xuICAgICAgICAgIGNoYW5uZWwudHJpZ2dlcihDSEFOTkVMX0VWRU5UUy5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuY29ubiAmJiB0aGlzLmNvbm4ucmVhZHlTdGF0ZSkge1xuICAgICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZzpcbiAgICAgICAgICByZXR1cm4gXCJjb25uZWN0aW5nXCI7XG4gICAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5vcGVuOlxuICAgICAgICAgIHJldHVybiBcIm9wZW5cIjtcbiAgICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLmNsb3Npbmc6XG4gICAgICAgICAgcmV0dXJuIFwiY2xvc2luZ1wiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBcImNsb3NlZFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25TdGF0ZSgpID09PSBcIm9wZW5cIjtcbiAgICB9XG4gICAgcmVtb3ZlKGNoYW5uZWwpIHtcbiAgICAgIHRoaXMub2ZmKGNoYW5uZWwuc3RhdGVDaGFuZ2VSZWZzKTtcbiAgICAgIHRoaXMuY2hhbm5lbHMgPSB0aGlzLmNoYW5uZWxzLmZpbHRlcigoYykgPT4gYy5qb2luUmVmKCkgIT09IGNoYW5uZWwuam9pblJlZigpKTtcbiAgICB9XG4gICAgb2ZmKHJlZnMpIHtcbiAgICAgIGZvciAobGV0IGtleSBpbiB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzKSB7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Nba2V5XSA9IHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Nba2V5XS5maWx0ZXIoKFtyZWZdKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHJlZnMuaW5kZXhPZihyZWYpID09PSAtMTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNoYW5uZWwodG9waWMsIGNoYW5QYXJhbXMgPSB7fSkge1xuICAgICAgbGV0IGNoYW4gPSBuZXcgQ2hhbm5lbCh0b3BpYywgY2hhblBhcmFtcywgdGhpcyk7XG4gICAgICB0aGlzLmNoYW5uZWxzLnB1c2goY2hhbik7XG4gICAgICByZXR1cm4gY2hhbjtcbiAgICB9XG4gICAgcHVzaChkYXRhKSB7XG4gICAgICBpZiAodGhpcy5oYXNMb2dnZXIoKSkge1xuICAgICAgICBsZXQgeyB0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pbl9yZWYgfSA9IGRhdGE7XG4gICAgICAgIHRoaXMubG9nKFwicHVzaFwiLCBgJHt0b3BpY30gJHtldmVudH0gKCR7am9pbl9yZWZ9LCAke3JlZn0pYCwgcGF5bG9hZCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgIHRoaXMuZW5jb2RlKGRhdGEsIChyZXN1bHQpID0+IHRoaXMuY29ubi5zZW5kKHJlc3VsdCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZW5kQnVmZmVyLnB1c2goKCkgPT4gdGhpcy5lbmNvZGUoZGF0YSwgKHJlc3VsdCkgPT4gdGhpcy5jb25uLnNlbmQocmVzdWx0KSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBtYWtlUmVmKCkge1xuICAgICAgbGV0IG5ld1JlZiA9IHRoaXMucmVmICsgMTtcbiAgICAgIGlmIChuZXdSZWYgPT09IHRoaXMucmVmKSB7XG4gICAgICAgIHRoaXMucmVmID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVmID0gbmV3UmVmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVmLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHNlbmRIZWFydGJlYXQoKSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmICYmICF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gdGhpcy5tYWtlUmVmKCk7XG4gICAgICB0aGlzLnB1c2goeyB0b3BpYzogXCJwaG9lbml4XCIsIGV2ZW50OiBcImhlYXJ0YmVhdFwiLCBwYXlsb2FkOiB7fSwgcmVmOiB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgfSk7XG4gICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oZWFydGJlYXRUaW1lb3V0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyk7XG4gICAgfVxuICAgIGZsdXNoU2VuZEJ1ZmZlcigpIHtcbiAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkgJiYgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5zZW5kQnVmZmVyLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpKTtcbiAgICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIG9uQ29ubk1lc3NhZ2UocmF3TWVzc2FnZSkge1xuICAgICAgdGhpcy5kZWNvZGUocmF3TWVzc2FnZS5kYXRhLCAobXNnKSA9PiB7XG4gICAgICAgIGxldCB7IHRvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luX3JlZiB9ID0gbXNnO1xuICAgICAgICBpZiAocmVmICYmIHJlZiA9PT0gdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKSB7XG4gICAgICAgICAgdGhpcy5jbGVhckhlYXJ0YmVhdHMoKTtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsO1xuICAgICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VuZEhlYXJ0YmVhdCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0xvZ2dlcigpKVxuICAgICAgICAgIHRoaXMubG9nKFwicmVjZWl2ZVwiLCBgJHtwYXlsb2FkLnN0YXR1cyB8fCBcIlwifSAke3RvcGljfSAke2V2ZW50fSAke3JlZiAmJiBcIihcIiArIHJlZiArIFwiKVwiIHx8IFwiXCJ9YCwgcGF5bG9hZCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGFubmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLmNoYW5uZWxzW2ldO1xuICAgICAgICAgIGlmICghY2hhbm5lbC5pc01lbWJlcih0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5fcmVmKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoYW5uZWwudHJpZ2dlcihldmVudCwgcGF5bG9hZCwgcmVmLCBqb2luX3JlZik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgWywgY2FsbGJhY2tdID0gdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlW2ldO1xuICAgICAgICAgIGNhbGxiYWNrKG1zZyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZU9wZW5Ub3BpYyh0b3BpYykge1xuICAgICAgbGV0IGR1cENoYW5uZWwgPSB0aGlzLmNoYW5uZWxzLmZpbmQoKGMpID0+IGMudG9waWMgPT09IHRvcGljICYmIChjLmlzSm9pbmVkKCkgfHwgYy5pc0pvaW5pbmcoKSkpO1xuICAgICAgaWYgKGR1cENoYW5uZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzTG9nZ2VyKCkpXG4gICAgICAgICAgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgYGxlYXZpbmcgZHVwbGljYXRlIHRvcGljIFwiJHt0b3BpY31cImApO1xuICAgICAgICBkdXBDaGFubmVsLmxlYXZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gX190b0NvbW1vbkpTKHBob2VuaXhfZXhwb3J0cyk7XG59KSgpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQURBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFqRkE7QUFDQTtBQW1GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7QUFDQTtBQW9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBM0xBO0FBQ0E7QUE2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQTVFQTtBQUNBO0FBOEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQXpCQTtBQTJCQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMUdBO0FBQ0E7QUE0R0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUxBO0FBUUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBcElBO0FBQ0E7QUFzSUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBaEdBO0FBQ0E7QUFrR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUF4V0E7QUF5V0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../deps/phoenix/priv/static/phoenix.js\n");

/***/ }),

/***/ "../deps/phoenix_html/priv/static/phoenix_html.js":
/*!********************************************************!*\
  !*** ../deps/phoenix_html/priv/static/phoenix_html.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n(function () {\n  var PolyfillEvent = eventConstructor();\n\n  function eventConstructor() {\n    if (typeof window.CustomEvent === \"function\") return window.CustomEvent; // IE<=9 Support\n\n    function CustomEvent(event, params) {\n      params = params || {\n        bubbles: false,\n        cancelable: false,\n        detail: undefined\n      };\n      var evt = document.createEvent('CustomEvent');\n      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n      return evt;\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n    return CustomEvent;\n  }\n\n  function buildHiddenInput(name, value) {\n    var input = document.createElement(\"input\");\n    input.type = \"hidden\";\n    input.name = name;\n    input.value = value;\n    return input;\n  }\n\n  function handleClick(element, targetModifierKey) {\n    var to = element.getAttribute(\"data-to\"),\n        method = buildHiddenInput(\"_method\", element.getAttribute(\"data-method\")),\n        csrf = buildHiddenInput(\"_csrf_token\", element.getAttribute(\"data-csrf\")),\n        form = document.createElement(\"form\"),\n        target = element.getAttribute(\"target\");\n    form.method = element.getAttribute(\"data-method\") === \"get\" ? \"get\" : \"post\";\n    form.action = to;\n    form.style.display = \"hidden\";\n    if (target) form.target = target;else if (targetModifierKey) form.target = \"_blank\";\n    form.appendChild(csrf);\n    form.appendChild(method);\n    document.body.appendChild(form);\n    form.submit();\n  }\n\n  window.addEventListener(\"click\", function (e) {\n    var element = e.target;\n    if (e.defaultPrevented) return;\n\n    while (element && element.getAttribute) {\n      var phoenixLinkEvent = new PolyfillEvent('phoenix.link.click', {\n        \"bubbles\": true,\n        \"cancelable\": true\n      });\n\n      if (!element.dispatchEvent(phoenixLinkEvent)) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        return false;\n      }\n\n      if (element.getAttribute(\"data-method\")) {\n        handleClick(element, e.metaKey || e.shiftKey);\n        e.preventDefault();\n        return false;\n      } else {\n        element = element.parentNode;\n      }\n    }\n  }, false);\n  window.addEventListener('phoenix.link.click', function (e) {\n    var message = e.target.getAttribute(\"data-confirm\");\n\n    if (message && !window.confirm(message)) {\n      e.preventDefault();\n    }\n  }, false);\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZGVwcy9waG9lbml4X2h0bWwvcHJpdi9zdGF0aWMvcGhvZW5peF9odG1sLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL2RlcHMvcGhvZW5peF9odG1sL3ByaXYvc3RhdGljL3Bob2VuaXhfaHRtbC5qcz80N2Q4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBQb2x5ZmlsbEV2ZW50ID0gZXZlbnRDb25zdHJ1Y3RvcigpO1xuXG4gIGZ1bmN0aW9uIGV2ZW50Q29uc3RydWN0b3IoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHdpbmRvdy5DdXN0b21FdmVudDtcbiAgICAvLyBJRTw9OSBTdXBwb3J0XG4gICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcykge1xuICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHtidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdW5kZWZpbmVkfTtcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XG4gICAgICByZXR1cm4gZXZ0O1xuICAgIH1cbiAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuICAgIHJldHVybiBDdXN0b21FdmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkSGlkZGVuSW5wdXQobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgaW5wdXQudHlwZSA9IFwiaGlkZGVuXCI7XG4gICAgaW5wdXQubmFtZSA9IG5hbWU7XG4gICAgaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDbGljayhlbGVtZW50LCB0YXJnZXRNb2RpZmllcktleSkge1xuICAgIHZhciB0byA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10b1wiKSxcbiAgICAgICAgbWV0aG9kID0gYnVpbGRIaWRkZW5JbnB1dChcIl9tZXRob2RcIiwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSksXG4gICAgICAgIGNzcmYgPSBidWlsZEhpZGRlbklucHV0KFwiX2NzcmZfdG9rZW5cIiwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNzcmZcIikpLFxuICAgICAgICBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIiksXG4gICAgICAgIHRhcmdldCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpO1xuXG4gICAgZm9ybS5tZXRob2QgPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSA9PT0gXCJnZXRcIikgPyBcImdldFwiIDogXCJwb3N0XCI7XG4gICAgZm9ybS5hY3Rpb24gPSB0bztcbiAgICBmb3JtLnN0eWxlLmRpc3BsYXkgPSBcImhpZGRlblwiO1xuXG4gICAgaWYgKHRhcmdldCkgZm9ybS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgZWxzZSBpZiAodGFyZ2V0TW9kaWZpZXJLZXkpIGZvcm0udGFyZ2V0ID0gXCJfYmxhbmtcIjtcblxuICAgIGZvcm0uYXBwZW5kQ2hpbGQoY3NyZik7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChtZXRob2QpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG4gICAgZm9ybS5zdWJtaXQoKTtcbiAgfVxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlbGVtZW50ID0gZS50YXJnZXQ7XG4gICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXG4gICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBwaG9lbml4TGlua0V2ZW50ID0gbmV3IFBvbHlmaWxsRXZlbnQoJ3Bob2VuaXgubGluay5jbGljaycsIHtcbiAgICAgICAgXCJidWJibGVzXCI6IHRydWUsIFwiY2FuY2VsYWJsZVwiOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFlbGVtZW50LmRpc3BhdGNoRXZlbnQocGhvZW5peExpbmtFdmVudCkpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbWV0aG9kXCIpKSB7XG4gICAgICAgIGhhbmRsZUNsaWNrKGVsZW1lbnQsIGUubWV0YUtleSB8fCBlLnNoaWZ0S2V5KTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfSwgZmFsc2UpO1xuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwaG9lbml4LmxpbmsuY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgIHZhciBtZXNzYWdlID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb25maXJtXCIpO1xuICAgIGlmKG1lc3NhZ2UgJiYgIXdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LCBmYWxzZSk7XG59KSgpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../deps/phoenix_html/priv/static/phoenix_html.js\n");

/***/ }),

/***/ "../deps/phoenix_live_view/priv/static/phoenix_live_view.js":
/*!******************************************************************!*\
  !*** ../deps/phoenix_live_view/priv/static/phoenix_live_view.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var LiveView = (() => {\n  var __defProp = Object.defineProperty;\n  var __getOwnPropSymbols = Object.getOwnPropertySymbols;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __propIsEnum = Object.prototype.propertyIsEnumerable;\n\n  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value\n  }) : obj[key] = value;\n\n  var __spreadValues = (a, b) => {\n    for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n  };\n\n  var __markAsModule = target => __defProp(target, \"__esModule\", {\n    value: true\n  });\n\n  var __export = (target, all) => {\n    __markAsModule(target);\n\n    for (var name in all) __defProp(target, name, {\n      get: all[name],\n      enumerable: true\n    });\n  }; // js/phoenix_live_view/index.js\n\n\n  var phoenix_live_view_exports = {};\n\n  __export(phoenix_live_view_exports, {\n    LiveSocket: () => LiveSocket\n  }); // js/phoenix_live_view/constants.js\n\n\n  var CONSECUTIVE_RELOADS = \"consecutive-reloads\";\n  var MAX_RELOADS = 10;\n  var RELOAD_JITTER = [1e3, 3e3];\n  var FAILSAFE_JITTER = 3e4;\n  var PHX_EVENT_CLASSES = [\"phx-click-loading\", \"phx-change-loading\", \"phx-submit-loading\", \"phx-keydown-loading\", \"phx-keyup-loading\", \"phx-blur-loading\", \"phx-focus-loading\"];\n  var PHX_COMPONENT = \"data-phx-component\";\n  var PHX_LIVE_LINK = \"data-phx-link\";\n  var PHX_TRACK_STATIC = \"track-static\";\n  var PHX_LINK_STATE = \"data-phx-link-state\";\n  var PHX_REF = \"data-phx-ref\";\n  var PHX_TRACK_UPLOADS = \"track-uploads\";\n  var PHX_UPLOAD_REF = \"data-phx-upload-ref\";\n  var PHX_PREFLIGHTED_REFS = \"data-phx-preflighted-refs\";\n  var PHX_DONE_REFS = \"data-phx-done-refs\";\n  var PHX_DROP_TARGET = \"drop-target\";\n  var PHX_ACTIVE_ENTRY_REFS = \"data-phx-active-refs\";\n  var PHX_LIVE_FILE_UPDATED = \"phx:live-file:updated\";\n  var PHX_SKIP = \"data-phx-skip\";\n  var PHX_REMOVE = \"data-phx-remove\";\n  var PHX_PAGE_LOADING = \"page-loading\";\n  var PHX_CONNECTED_CLASS = \"phx-connected\";\n  var PHX_DISCONNECTED_CLASS = \"phx-disconnected\";\n  var PHX_NO_FEEDBACK_CLASS = \"phx-no-feedback\";\n  var PHX_ERROR_CLASS = \"phx-error\";\n  var PHX_PARENT_ID = \"data-phx-parent-id\";\n  var PHX_MAIN = \"data-phx-main\";\n  var PHX_ROOT_ID = \"data-phx-root-id\";\n  var PHX_TRIGGER_ACTION = \"trigger-action\";\n  var PHX_FEEDBACK_FOR = \"feedback-for\";\n  var PHX_HAS_FOCUSED = \"phx-has-focused\";\n  var FOCUSABLE_INPUTS = [\"text\", \"textarea\", \"number\", \"email\", \"password\", \"search\", \"tel\", \"url\", \"date\", \"time\"];\n  var CHECKABLE_INPUTS = [\"checkbox\", \"radio\"];\n  var PHX_HAS_SUBMITTED = \"phx-has-submitted\";\n  var PHX_SESSION = \"data-phx-session\";\n  var PHX_VIEW_SELECTOR = `[${PHX_SESSION}]`;\n  var PHX_STATIC = \"data-phx-static\";\n  var PHX_READONLY = \"data-phx-readonly\";\n  var PHX_DISABLED = \"data-phx-disabled\";\n  var PHX_DISABLE_WITH = \"disable-with\";\n  var PHX_DISABLE_WITH_RESTORE = \"data-phx-disable-with-restore\";\n  var PHX_HOOK = \"hook\";\n  var PHX_DEBOUNCE = \"debounce\";\n  var PHX_THROTTLE = \"throttle\";\n  var PHX_UPDATE = \"update\";\n  var PHX_KEY = \"key\";\n  var PHX_PRIVATE = \"phxPrivate\";\n  var PHX_AUTO_RECOVER = \"auto-recover\";\n  var PHX_LV_DEBUG = \"phx:live-socket:debug\";\n  var PHX_LV_PROFILE = \"phx:live-socket:profiling\";\n  var PHX_LV_LATENCY_SIM = \"phx:live-socket:latency-sim\";\n  var PHX_PROGRESS = \"progress\";\n  var LOADER_TIMEOUT = 1;\n  var BEFORE_UNLOAD_LOADER_TIMEOUT = 200;\n  var BINDING_PREFIX = \"phx-\";\n  var PUSH_TIMEOUT = 3e4;\n  var DEBOUNCE_TRIGGER = \"debounce-trigger\";\n  var THROTTLED = \"throttled\";\n  var DEBOUNCE_PREV_KEY = \"debounce-prev-key\";\n  var DEFAULTS = {\n    debounce: 300,\n    throttle: 300\n  };\n  var DYNAMICS = \"d\";\n  var STATIC = \"s\";\n  var COMPONENTS = \"c\";\n  var EVENTS = \"e\";\n  var REPLY = \"r\";\n  var TITLE = \"t\"; // js/phoenix_live_view/entry_uploader.js\n\n  var EntryUploader = class {\n    constructor(entry, chunkSize, liveSocket) {\n      this.liveSocket = liveSocket;\n      this.entry = entry;\n      this.offset = 0;\n      this.chunkSize = chunkSize;\n      this.chunkTimer = null;\n      this.uploadChannel = liveSocket.channel(`lvu:${entry.ref}`, {\n        token: entry.metadata()\n      });\n    }\n\n    error(reason) {\n      clearTimeout(this.chunkTimer);\n      this.uploadChannel.leave();\n      this.entry.error(reason);\n    }\n\n    upload() {\n      this.uploadChannel.onError(reason => this.error(reason));\n      this.uploadChannel.join().receive(\"ok\", _data => this.readNextChunk()).receive(\"error\", reason => this.error(reason));\n    }\n\n    isDone() {\n      return this.offset >= this.entry.file.size;\n    }\n\n    readNextChunk() {\n      let reader = new window.FileReader();\n      let blob = this.entry.file.slice(this.offset, this.chunkSize + this.offset);\n\n      reader.onload = e => {\n        if (e.target.error === null) {\n          this.offset += e.target.result.byteLength;\n          this.pushChunk(e.target.result);\n        } else {\n          return logError(\"Read error: \" + e.target.error);\n        }\n      };\n\n      reader.readAsArrayBuffer(blob);\n    }\n\n    pushChunk(chunk) {\n      if (!this.uploadChannel.isJoined()) {\n        return;\n      }\n\n      this.uploadChannel.push(\"chunk\", chunk).receive(\"ok\", () => {\n        this.entry.progress(this.offset / this.entry.file.size * 100);\n\n        if (!this.isDone()) {\n          this.chunkTimer = setTimeout(() => this.readNextChunk(), this.liveSocket.getLatencySim() || 0);\n        }\n      });\n    }\n\n  }; // js/phoenix_live_view/utils.js\n\n  var logError = (msg, obj) => console.error && console.error(msg, obj);\n\n  var isCid = cid => typeof cid === \"number\";\n\n  function detectDuplicateIds() {\n    let ids = new Set();\n    let elems = document.querySelectorAll(\"*[id]\");\n\n    for (let i = 0, len = elems.length; i < len; i++) {\n      if (ids.has(elems[i].id)) {\n        console.error(`Multiple IDs detected: ${elems[i].id}. Ensure unique element ids.`);\n      } else {\n        ids.add(elems[i].id);\n      }\n    }\n  }\n\n  var debug = (view, kind, msg, obj) => {\n    if (view.liveSocket.isDebugEnabled()) {\n      console.log(`${view.id} ${kind}: ${msg} - `, obj);\n    }\n  };\n\n  var closure = val => typeof val === \"function\" ? val : function () {\n    return val;\n  };\n\n  var clone = obj => {\n    return JSON.parse(JSON.stringify(obj));\n  };\n\n  var closestPhxBinding = (el, binding, borderEl) => {\n    do {\n      if (el.matches(`[${binding}]`)) {\n        return el;\n      }\n\n      el = el.parentElement || el.parentNode;\n    } while (el !== null && el.nodeType === 1 && !(borderEl && borderEl.isSameNode(el) || el.matches(PHX_VIEW_SELECTOR)));\n\n    return null;\n  };\n\n  var isObject = obj => {\n    return obj !== null && typeof obj === \"object\" && !(obj instanceof Array);\n  };\n\n  var isEqualObj = (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2);\n\n  var isEmpty = obj => {\n    for (let x in obj) {\n      return false;\n    }\n\n    return true;\n  };\n\n  var maybe = (el, callback) => el && callback(el);\n\n  var channelUploader = function (entries, onError, resp, liveSocket) {\n    entries.forEach(entry => {\n      let entryUploader = new EntryUploader(entry, resp.config.chunk_size, liveSocket);\n      entryUploader.upload();\n    });\n  }; // js/phoenix_live_view/browser.js\n\n\n  var Browser = {\n    canPushState() {\n      return typeof history.pushState !== \"undefined\";\n    },\n\n    dropLocal(localStorage, namespace, subkey) {\n      return localStorage.removeItem(this.localKey(namespace, subkey));\n    },\n\n    updateLocal(localStorage, namespace, subkey, initial, func) {\n      let current = this.getLocal(localStorage, namespace, subkey);\n      let key = this.localKey(namespace, subkey);\n      let newVal = current === null ? initial : func(current);\n      localStorage.setItem(key, JSON.stringify(newVal));\n      return newVal;\n    },\n\n    getLocal(localStorage, namespace, subkey) {\n      return JSON.parse(localStorage.getItem(this.localKey(namespace, subkey)));\n    },\n\n    updateCurrentState(callback) {\n      if (!this.canPushState()) {\n        return;\n      }\n\n      history.replaceState(callback(history.state || {}), \"\", window.location.href);\n    },\n\n    pushState(kind, meta, to) {\n      if (this.canPushState()) {\n        if (to !== window.location.href) {\n          if (meta.type == \"redirect\" && meta.scroll) {\n            let currentState = history.state || {};\n            currentState.scroll = meta.scroll;\n            history.replaceState(currentState, \"\", window.location.href);\n          }\n\n          delete meta.scroll;\n          history[kind + \"State\"](meta, \"\", to || null);\n          let hashEl = this.getHashTargetEl(window.location.hash);\n\n          if (hashEl) {\n            hashEl.scrollIntoView();\n          } else if (meta.type === \"redirect\") {\n            window.scroll(0, 0);\n          }\n        }\n      } else {\n        this.redirect(to);\n      }\n    },\n\n    setCookie(name, value) {\n      document.cookie = `${name}=${value}`;\n    },\n\n    getCookie(name) {\n      return document.cookie.replace(new RegExp(`(?:(?:^|.*;s*)${name}s*=s*([^;]*).*$)|^.*$`), \"$1\");\n    },\n\n    redirect(toURL, flash) {\n      if (flash) {\n        Browser.setCookie(\"__phoenix_flash__\", flash + \"; max-age=60000; path=/\");\n      }\n\n      window.location = toURL;\n    },\n\n    localKey(namespace, subkey) {\n      return `${namespace}-${subkey}`;\n    },\n\n    getHashTargetEl(maybeHash) {\n      let hash = maybeHash.toString().substring(1);\n\n      if (hash === \"\") {\n        return;\n      }\n\n      return document.getElementById(hash) || document.querySelector(`a[name=\"${hash}\"]`);\n    }\n\n  };\n  var browser_default = Browser; // js/phoenix_live_view/dom.js\n\n  var DOM = {\n    byId(id) {\n      return document.getElementById(id) || logError(`no id found for ${id}`);\n    },\n\n    removeClass(el, className) {\n      el.classList.remove(className);\n\n      if (el.classList.length === 0) {\n        el.removeAttribute(\"class\");\n      }\n    },\n\n    all(node, query, callback) {\n      if (!node) {\n        return [];\n      }\n\n      let array = Array.from(node.querySelectorAll(query));\n      return callback ? array.forEach(callback) : array;\n    },\n\n    childNodeLength(html) {\n      let template = document.createElement(\"template\");\n      template.innerHTML = html;\n      return template.content.childElementCount;\n    },\n\n    isUploadInput(el) {\n      return el.type === \"file\" && el.getAttribute(PHX_UPLOAD_REF) !== null;\n    },\n\n    findUploadInputs(node) {\n      return this.all(node, `input[type=\"file\"][${PHX_UPLOAD_REF}]`);\n    },\n\n    findComponentNodeList(node, cid) {\n      return this.filterWithinSameLiveView(this.all(node, `[${PHX_COMPONENT}=\"${cid}\"]`), node);\n    },\n\n    isPhxDestroyed(node) {\n      return node.id && DOM.private(node, \"destroyed\") ? true : false;\n    },\n\n    markPhxChildDestroyed(el) {\n      el.setAttribute(PHX_SESSION, \"\");\n      this.putPrivate(el, \"destroyed\", true);\n    },\n\n    findPhxChildrenInFragment(html, parentId) {\n      let template = document.createElement(\"template\");\n      template.innerHTML = html;\n      return this.findPhxChildren(template.content, parentId);\n    },\n\n    isIgnored(el, phxUpdate) {\n      return (el.getAttribute(phxUpdate) || el.getAttribute(\"data-phx-update\")) === \"ignore\";\n    },\n\n    isPhxUpdate(el, phxUpdate, updateTypes) {\n      return el.getAttribute && updateTypes.indexOf(el.getAttribute(phxUpdate)) >= 0;\n    },\n\n    findPhxChildren(el, parentId) {\n      return this.all(el, `${PHX_VIEW_SELECTOR}[${PHX_PARENT_ID}=\"${parentId}\"]`);\n    },\n\n    findParentCIDs(node, cids) {\n      let initial = new Set(cids);\n      return cids.reduce((acc, cid) => {\n        let selector = `[${PHX_COMPONENT}=\"${cid}\"] [${PHX_COMPONENT}]`;\n        this.filterWithinSameLiveView(this.all(node, selector), node).map(el => parseInt(el.getAttribute(PHX_COMPONENT))).forEach(childCID => acc.delete(childCID));\n        return acc;\n      }, initial);\n    },\n\n    filterWithinSameLiveView(nodes, parent) {\n      if (parent.querySelector(PHX_VIEW_SELECTOR)) {\n        return nodes.filter(el => this.withinSameLiveView(el, parent));\n      } else {\n        return nodes;\n      }\n    },\n\n    withinSameLiveView(node, parent) {\n      while (node = node.parentNode) {\n        if (node.isSameNode(parent)) {\n          return true;\n        }\n\n        if (node.getAttribute(PHX_SESSION) !== null) {\n          return false;\n        }\n      }\n    },\n\n    private(el, key) {\n      return el[PHX_PRIVATE] && el[PHX_PRIVATE][key];\n    },\n\n    deletePrivate(el, key) {\n      el[PHX_PRIVATE] && delete el[PHX_PRIVATE][key];\n    },\n\n    putPrivate(el, key, value) {\n      if (!el[PHX_PRIVATE]) {\n        el[PHX_PRIVATE] = {};\n      }\n\n      el[PHX_PRIVATE][key] = value;\n    },\n\n    copyPrivates(target, source) {\n      if (source[PHX_PRIVATE]) {\n        target[PHX_PRIVATE] = clone(source[PHX_PRIVATE]);\n      }\n    },\n\n    putTitle(str) {\n      let titleEl = document.querySelector(\"title\");\n      let {\n        prefix,\n        suffix\n      } = titleEl.dataset;\n      document.title = `${prefix || \"\"}${str}${suffix || \"\"}`;\n    },\n\n    debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, callback) {\n      let debounce = el.getAttribute(phxDebounce);\n      let throttle = el.getAttribute(phxThrottle);\n\n      if (debounce === \"\") {\n        debounce = defaultDebounce;\n      }\n\n      if (throttle === \"\") {\n        throttle = defaultThrottle;\n      }\n\n      let value = debounce || throttle;\n\n      switch (value) {\n        case null:\n          return callback();\n\n        case \"blur\":\n          if (this.once(el, \"debounce-blur\")) {\n            el.addEventListener(\"blur\", () => callback());\n          }\n\n          return;\n\n        default:\n          let timeout = parseInt(value);\n\n          let trigger = () => throttle ? this.deletePrivate(el, THROTTLED) : callback();\n\n          let currentCycle = this.incCycle(el, DEBOUNCE_TRIGGER, trigger);\n\n          if (isNaN(timeout)) {\n            return logError(`invalid throttle/debounce value: ${value}`);\n          }\n\n          if (throttle) {\n            let newKeyDown = false;\n\n            if (event.type === \"keydown\") {\n              let prevKey = this.private(el, DEBOUNCE_PREV_KEY);\n              this.putPrivate(el, DEBOUNCE_PREV_KEY, event.key);\n              newKeyDown = prevKey !== event.key;\n            }\n\n            if (!newKeyDown && this.private(el, THROTTLED)) {\n              return false;\n            } else {\n              callback();\n              this.putPrivate(el, THROTTLED, true);\n              setTimeout(() => this.triggerCycle(el, DEBOUNCE_TRIGGER), timeout);\n            }\n          } else {\n            setTimeout(() => this.triggerCycle(el, DEBOUNCE_TRIGGER, currentCycle), timeout);\n          }\n\n          let form = el.form;\n\n          if (form && this.once(form, \"bind-debounce\")) {\n            form.addEventListener(\"submit\", () => {\n              Array.from(new FormData(form).entries(), ([name]) => {\n                let input = form.querySelector(`[name=\"${name}\"]`);\n                this.incCycle(input, DEBOUNCE_TRIGGER);\n                this.deletePrivate(input, THROTTLED);\n              });\n            });\n          }\n\n          if (this.once(el, \"bind-debounce\")) {\n            el.addEventListener(\"blur\", () => this.triggerCycle(el, DEBOUNCE_TRIGGER));\n          }\n\n      }\n    },\n\n    triggerCycle(el, key, currentCycle) {\n      let [cycle, trigger] = this.private(el, key);\n\n      if (!currentCycle) {\n        currentCycle = cycle;\n      }\n\n      if (currentCycle === cycle) {\n        this.incCycle(el, key);\n        trigger();\n      }\n    },\n\n    once(el, key) {\n      if (this.private(el, key) === true) {\n        return false;\n      }\n\n      this.putPrivate(el, key, true);\n      return true;\n    },\n\n    incCycle(el, key, trigger = function () {}) {\n      let [currentCycle] = this.private(el, key) || [0, trigger];\n      currentCycle++;\n      this.putPrivate(el, key, [currentCycle, trigger]);\n      return currentCycle;\n    },\n\n    discardError(container, el, phxFeedbackFor) {\n      let field = el.getAttribute && el.getAttribute(phxFeedbackFor);\n      let input = field && container.querySelector(`[id=\"${field}\"], [name=\"${field}\"]`);\n\n      if (!input) {\n        return;\n      }\n\n      if (!(this.private(input, PHX_HAS_FOCUSED) || this.private(input.form, PHX_HAS_SUBMITTED))) {\n        el.classList.add(PHX_NO_FEEDBACK_CLASS);\n      }\n    },\n\n    showError(inputEl, phxFeedbackFor) {\n      if (inputEl.id || inputEl.name) {\n        this.all(inputEl.form, `[${phxFeedbackFor}=\"${inputEl.id}\"], [${phxFeedbackFor}=\"${inputEl.name}\"]`, el => {\n          this.removeClass(el, PHX_NO_FEEDBACK_CLASS);\n        });\n      }\n    },\n\n    isPhxChild(node) {\n      return node.getAttribute && node.getAttribute(PHX_PARENT_ID);\n    },\n\n    dispatchEvent(target, eventString, detail = {}) {\n      let event = new CustomEvent(eventString, {\n        bubbles: true,\n        cancelable: true,\n        detail\n      });\n      target.dispatchEvent(event);\n    },\n\n    cloneNode(node, html) {\n      if (typeof html === \"undefined\") {\n        return node.cloneNode(true);\n      } else {\n        let cloned = node.cloneNode(false);\n        cloned.innerHTML = html;\n        return cloned;\n      }\n    },\n\n    mergeAttrs(target, source, opts = {}) {\n      let exclude = opts.exclude || [];\n      let isIgnored = opts.isIgnored;\n      let sourceAttrs = source.attributes;\n\n      for (let i = sourceAttrs.length - 1; i >= 0; i--) {\n        let name = sourceAttrs[i].name;\n\n        if (exclude.indexOf(name) < 0) {\n          target.setAttribute(name, source.getAttribute(name));\n        }\n      }\n\n      let targetAttrs = target.attributes;\n\n      for (let i = targetAttrs.length - 1; i >= 0; i--) {\n        let name = targetAttrs[i].name;\n\n        if (isIgnored) {\n          if (name.startsWith(\"data-\") && !source.hasAttribute(name)) {\n            target.removeAttribute(name);\n          }\n        } else {\n          if (!source.hasAttribute(name)) {\n            target.removeAttribute(name);\n          }\n        }\n      }\n    },\n\n    mergeFocusedInput(target, source) {\n      if (!(target instanceof HTMLSelectElement)) {\n        DOM.mergeAttrs(target, source, {\n          except: [\"value\"]\n        });\n      }\n\n      if (source.readOnly) {\n        target.setAttribute(\"readonly\", true);\n      } else {\n        target.removeAttribute(\"readonly\");\n      }\n    },\n\n    hasSelectionRange(el) {\n      return el.setSelectionRange && (el.type === \"text\" || el.type === \"textarea\");\n    },\n\n    restoreFocus(focused, selectionStart, selectionEnd) {\n      if (!DOM.isTextualInput(focused)) {\n        return;\n      }\n\n      let wasFocused = focused.matches(\":focus\");\n\n      if (focused.readOnly) {\n        focused.blur();\n      }\n\n      if (!wasFocused) {\n        focused.focus();\n      }\n\n      if (this.hasSelectionRange(focused)) {\n        focused.setSelectionRange(selectionStart, selectionEnd);\n      }\n    },\n\n    isFormInput(el) {\n      return /^(?:input|select|textarea)$/i.test(el.tagName) && el.type !== \"button\";\n    },\n\n    syncAttrsToProps(el) {\n      if (el instanceof HTMLInputElement && CHECKABLE_INPUTS.indexOf(el.type.toLocaleLowerCase()) >= 0) {\n        el.checked = el.getAttribute(\"checked\") !== null;\n      }\n    },\n\n    syncPropsToAttrs(el) {\n      if (el instanceof HTMLSelectElement) {\n        let selectedItem = el.options.item(el.selectedIndex);\n\n        if (selectedItem && selectedItem.getAttribute(\"selected\") === null) {\n          selectedItem.setAttribute(\"selected\", \"\");\n        }\n      }\n    },\n\n    isTextualInput(el) {\n      return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;\n    },\n\n    isNowTriggerFormExternal(el, phxTriggerExternal) {\n      return el.getAttribute && el.getAttribute(phxTriggerExternal) !== null;\n    },\n\n    syncPendingRef(fromEl, toEl, disableWith) {\n      let ref = fromEl.getAttribute(PHX_REF);\n\n      if (ref === null) {\n        return true;\n      }\n\n      if (DOM.isFormInput(fromEl) || fromEl.getAttribute(disableWith) !== null) {\n        if (DOM.isUploadInput(fromEl)) {\n          DOM.mergeAttrs(fromEl, toEl, {\n            isIgnored: true\n          });\n        }\n\n        DOM.putPrivate(fromEl, PHX_REF, toEl);\n        return false;\n      } else {\n        PHX_EVENT_CLASSES.forEach(className => {\n          fromEl.classList.contains(className) && toEl.classList.add(className);\n        });\n        toEl.setAttribute(PHX_REF, ref);\n        return true;\n      }\n    },\n\n    cleanChildNodes(container, phxUpdate) {\n      if (DOM.isPhxUpdate(container, phxUpdate, [\"append\", \"prepend\"])) {\n        let toRemove = [];\n        container.childNodes.forEach(childNode => {\n          if (!childNode.id) {\n            let isEmptyTextNode = childNode.nodeType === Node.TEXT_NODE && childNode.nodeValue.trim() === \"\";\n\n            if (!isEmptyTextNode) {\n              logError(`only HTML element tags with an id are allowed inside containers with phx-update.\n\nremoving illegal node: \"${(childNode.outerHTML || childNode.nodeValue).trim()}\"\n\n`);\n            }\n\n            toRemove.push(childNode);\n          }\n        });\n        toRemove.forEach(childNode => childNode.remove());\n      }\n    },\n\n    replaceRootContainer(container, tagName, attrs) {\n      let retainedAttrs = new Set([\"id\", PHX_SESSION, PHX_STATIC, PHX_MAIN]);\n\n      if (container.tagName.toLowerCase() === tagName.toLowerCase()) {\n        Array.from(container.attributes).filter(attr => !retainedAttrs.has(attr.name.toLowerCase())).forEach(attr => container.removeAttribute(attr.name));\n        Object.keys(attrs).filter(name => !retainedAttrs.has(name.toLowerCase())).forEach(attr => container.setAttribute(attr, attrs[attr]));\n        return container;\n      } else {\n        let newContainer = document.createElement(tagName);\n        Object.keys(attrs).forEach(attr => newContainer.setAttribute(attr, attrs[attr]));\n        retainedAttrs.forEach(attr => newContainer.setAttribute(attr, container.getAttribute(attr)));\n        newContainer.innerHTML = container.innerHTML;\n        container.replaceWith(newContainer);\n        return newContainer;\n      }\n    }\n\n  };\n  var dom_default = DOM; // js/phoenix_live_view/upload_entry.js\n\n  var UploadEntry = class {\n    static isActive(fileEl, file) {\n      let isNew = file._phxRef === void 0;\n      let activeRefs = fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(\",\");\n      let isActive = activeRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;\n      return file.size > 0 && (isNew || isActive);\n    }\n\n    static isPreflighted(fileEl, file) {\n      let preflightedRefs = fileEl.getAttribute(PHX_PREFLIGHTED_REFS).split(\",\");\n      let isPreflighted = preflightedRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;\n      return isPreflighted && this.isActive(fileEl, file);\n    }\n\n    constructor(fileEl, file, view) {\n      this.ref = LiveUploader.genFileRef(file);\n      this.fileEl = fileEl;\n      this.file = file;\n      this.view = view;\n      this.meta = null;\n      this._isCancelled = false;\n      this._isDone = false;\n      this._progress = 0;\n      this._lastProgressSent = -1;\n\n      this._onDone = function () {};\n\n      this._onElUpdated = this.onElUpdated.bind(this);\n      this.fileEl.addEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);\n    }\n\n    metadata() {\n      return this.meta;\n    }\n\n    progress(progress) {\n      this._progress = Math.floor(progress);\n\n      if (this._progress > this._lastProgressSent) {\n        if (this._progress >= 100) {\n          this._progress = 100;\n          this._lastProgressSent = 100;\n          this._isDone = true;\n          this.view.pushFileProgress(this.fileEl, this.ref, 100, () => {\n            LiveUploader.untrackFile(this.fileEl, this.file);\n\n            this._onDone();\n          });\n        } else {\n          this._lastProgressSent = this._progress;\n          this.view.pushFileProgress(this.fileEl, this.ref, this._progress);\n        }\n      }\n    }\n\n    cancel() {\n      this._isCancelled = true;\n      this._isDone = true;\n\n      this._onDone();\n    }\n\n    isDone() {\n      return this._isDone;\n    }\n\n    error(reason = \"failed\") {\n      this.view.pushFileProgress(this.fileEl, this.ref, {\n        error: reason\n      });\n      LiveUploader.clearFiles(this.fileEl);\n    }\n\n    onDone(callback) {\n      this._onDone = () => {\n        this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);\n        callback();\n      };\n    }\n\n    onElUpdated() {\n      let activeRefs = this.fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(\",\");\n\n      if (activeRefs.indexOf(this.ref) === -1) {\n        this.cancel();\n      }\n    }\n\n    toPreflightPayload() {\n      return {\n        last_modified: this.file.lastModified,\n        name: this.file.name,\n        size: this.file.size,\n        type: this.file.type,\n        ref: this.ref\n      };\n    }\n\n    uploader(uploaders) {\n      if (this.meta.uploader) {\n        let callback = uploaders[this.meta.uploader] || logError(`no uploader configured for ${this.meta.uploader}`);\n        return {\n          name: this.meta.uploader,\n          callback\n        };\n      } else {\n        return {\n          name: \"channel\",\n          callback: channelUploader\n        };\n      }\n    }\n\n    zipPostFlight(resp) {\n      this.meta = resp.entries[this.ref];\n\n      if (!this.meta) {\n        logError(`no preflight upload response returned with ref ${this.ref}`, {\n          input: this.fileEl,\n          response: resp\n        });\n      }\n    }\n\n  }; // js/phoenix_live_view/live_uploader.js\n\n  var liveUploaderFileRef = 0;\n  var LiveUploader = class {\n    static genFileRef(file) {\n      let ref = file._phxRef;\n\n      if (ref !== void 0) {\n        return ref;\n      } else {\n        file._phxRef = (liveUploaderFileRef++).toString();\n        return file._phxRef;\n      }\n    }\n\n    static getEntryDataURL(inputEl, ref, callback) {\n      let file = this.activeFiles(inputEl).find(file2 => this.genFileRef(file2) === ref);\n      callback(URL.createObjectURL(file));\n    }\n\n    static hasUploadsInProgress(formEl) {\n      let active = 0;\n      dom_default.findUploadInputs(formEl).forEach(input => {\n        if (input.getAttribute(PHX_PREFLIGHTED_REFS) !== input.getAttribute(PHX_DONE_REFS)) {\n          active++;\n        }\n      });\n      return active > 0;\n    }\n\n    static serializeUploads(inputEl) {\n      let files = this.activeFiles(inputEl);\n      let fileData = {};\n      files.forEach(file => {\n        let entry = {\n          path: inputEl.name\n        };\n        let uploadRef = inputEl.getAttribute(PHX_UPLOAD_REF);\n        fileData[uploadRef] = fileData[uploadRef] || [];\n        entry.ref = this.genFileRef(file);\n        entry.name = file.name || entry.ref;\n        entry.type = file.type;\n        entry.size = file.size;\n        fileData[uploadRef].push(entry);\n      });\n      return fileData;\n    }\n\n    static clearFiles(inputEl) {\n      inputEl.value = null;\n      inputEl.removeAttribute(PHX_UPLOAD_REF);\n      dom_default.putPrivate(inputEl, \"files\", []);\n    }\n\n    static untrackFile(inputEl, file) {\n      dom_default.putPrivate(inputEl, \"files\", dom_default.private(inputEl, \"files\").filter(f => !Object.is(f, file)));\n    }\n\n    static trackFiles(inputEl, files) {\n      if (inputEl.getAttribute(\"multiple\") !== null) {\n        let newFiles = files.filter(file => !this.activeFiles(inputEl).find(f => Object.is(f, file)));\n        dom_default.putPrivate(inputEl, \"files\", this.activeFiles(inputEl).concat(newFiles));\n        inputEl.value = null;\n      } else {\n        dom_default.putPrivate(inputEl, \"files\", files);\n      }\n    }\n\n    static activeFileInputs(formEl) {\n      let fileInputs = dom_default.findUploadInputs(formEl);\n      return Array.from(fileInputs).filter(el => el.files && this.activeFiles(el).length > 0);\n    }\n\n    static activeFiles(input) {\n      return (dom_default.private(input, \"files\") || []).filter(f => UploadEntry.isActive(input, f));\n    }\n\n    static inputsAwaitingPreflight(formEl) {\n      let fileInputs = dom_default.findUploadInputs(formEl);\n      return Array.from(fileInputs).filter(input => this.filesAwaitingPreflight(input).length > 0);\n    }\n\n    static filesAwaitingPreflight(input) {\n      return this.activeFiles(input).filter(f => !UploadEntry.isPreflighted(input, f));\n    }\n\n    constructor(inputEl, view, onComplete) {\n      this.view = view;\n      this.onComplete = onComplete;\n      this._entries = Array.from(LiveUploader.filesAwaitingPreflight(inputEl) || []).map(file => new UploadEntry(inputEl, file, view));\n      this.numEntriesInProgress = this._entries.length;\n    }\n\n    entries() {\n      return this._entries;\n    }\n\n    initAdapterUpload(resp, onError, liveSocket) {\n      this._entries = this._entries.map(entry => {\n        entry.zipPostFlight(resp);\n        entry.onDone(() => {\n          this.numEntriesInProgress--;\n\n          if (this.numEntriesInProgress === 0) {\n            this.onComplete();\n          }\n        });\n        return entry;\n      });\n\n      let groupedEntries = this._entries.reduce((acc, entry) => {\n        let {\n          name,\n          callback\n        } = entry.uploader(liveSocket.uploaders);\n        acc[name] = acc[name] || {\n          callback,\n          entries: []\n        };\n        acc[name].entries.push(entry);\n        return acc;\n      }, {});\n\n      for (let name in groupedEntries) {\n        let {\n          callback,\n          entries\n        } = groupedEntries[name];\n        callback(entries, onError, resp, liveSocket);\n      }\n    }\n\n  }; // js/phoenix_live_view/hooks.js\n\n  var Hooks = {\n    LiveFileUpload: {\n      activeRefs() {\n        return this.el.getAttribute(PHX_ACTIVE_ENTRY_REFS);\n      },\n\n      preflightedRefs() {\n        return this.el.getAttribute(PHX_PREFLIGHTED_REFS);\n      },\n\n      mounted() {\n        this.preflightedWas = this.preflightedRefs();\n      },\n\n      updated() {\n        let newPreflights = this.preflightedRefs();\n\n        if (this.preflightedWas !== newPreflights) {\n          this.preflightedWas = newPreflights;\n\n          if (newPreflights === \"\") {\n            this.__view.cancelSubmit(this.el.form);\n          }\n        }\n\n        if (this.activeRefs() === \"\") {\n          this.el.value = null;\n        }\n\n        this.el.dispatchEvent(new CustomEvent(PHX_LIVE_FILE_UPDATED));\n      }\n\n    },\n    LiveImgPreview: {\n      mounted() {\n        this.ref = this.el.getAttribute(\"data-phx-entry-ref\");\n        this.inputEl = document.getElementById(this.el.getAttribute(PHX_UPLOAD_REF));\n        LiveUploader.getEntryDataURL(this.inputEl, this.ref, url => {\n          this.url = url;\n          this.el.src = url;\n        });\n      },\n\n      destroyed() {\n        URL.revokeObjectURL(this.url);\n      }\n\n    }\n  };\n  var hooks_default = Hooks; // js/phoenix_live_view/dom_post_morph_restorer.js\n\n  var DOMPostMorphRestorer = class {\n    constructor(containerBefore, containerAfter, updateType) {\n      let idsBefore = new Set();\n      let idsAfter = new Set([...containerAfter.children].map(child => child.id));\n      let elementsToModify = [];\n      Array.from(containerBefore.children).forEach(child => {\n        if (child.id) {\n          idsBefore.add(child.id);\n\n          if (idsAfter.has(child.id)) {\n            let previousElementId = child.previousElementSibling && child.previousElementSibling.id;\n            elementsToModify.push({\n              elementId: child.id,\n              previousElementId\n            });\n          }\n        }\n      });\n      this.containerId = containerAfter.id;\n      this.updateType = updateType;\n      this.elementsToModify = elementsToModify;\n      this.elementIdsToAdd = [...idsAfter].filter(id => !idsBefore.has(id));\n    }\n\n    perform() {\n      let container = dom_default.byId(this.containerId);\n      this.elementsToModify.forEach(elementToModify => {\n        if (elementToModify.previousElementId) {\n          maybe(document.getElementById(elementToModify.previousElementId), previousElem => {\n            maybe(document.getElementById(elementToModify.elementId), elem => {\n              let isInRightPlace = elem.previousElementSibling && elem.previousElementSibling.id == previousElem.id;\n\n              if (!isInRightPlace) {\n                previousElem.insertAdjacentElement(\"afterend\", elem);\n              }\n            });\n          });\n        } else {\n          maybe(document.getElementById(elementToModify.elementId), elem => {\n            let isInRightPlace = elem.previousElementSibling == null;\n\n            if (!isInRightPlace) {\n              container.insertAdjacentElement(\"afterbegin\", elem);\n            }\n          });\n        }\n      });\n\n      if (this.updateType == \"prepend\") {\n        this.elementIdsToAdd.reverse().forEach(elemId => {\n          maybe(document.getElementById(elemId), elem => container.insertAdjacentElement(\"afterbegin\", elem));\n        });\n      }\n    }\n\n  }; // node_modules/morphdom/dist/morphdom-esm.js\n\n  var DOCUMENT_FRAGMENT_NODE = 11;\n\n  function morphAttrs(fromNode, toNode) {\n    var toNodeAttrs = toNode.attributes;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      return;\n    }\n\n    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {\n      attr = toNodeAttrs[i];\n      attrName = attr.name;\n      attrNamespaceURI = attr.namespaceURI;\n      attrValue = attr.value;\n\n      if (attrNamespaceURI) {\n        attrName = attr.localName || attrName;\n        fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n        if (fromValue !== attrValue) {\n          if (attr.prefix === \"xmlns\") {\n            attrName = attr.name;\n          }\n\n          fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n        }\n      } else {\n        fromValue = fromNode.getAttribute(attrName);\n\n        if (fromValue !== attrValue) {\n          fromNode.setAttribute(attrName, attrValue);\n        }\n      }\n    }\n\n    var fromNodeAttrs = fromNode.attributes;\n\n    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {\n      attr = fromNodeAttrs[d];\n      attrName = attr.name;\n      attrNamespaceURI = attr.namespaceURI;\n\n      if (attrNamespaceURI) {\n        attrName = attr.localName || attrName;\n\n        if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n          fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n        }\n      } else {\n        if (!toNode.hasAttribute(attrName)) {\n          fromNode.removeAttribute(attrName);\n        }\n      }\n    }\n  }\n\n  var range;\n  var NS_XHTML = \"http://www.w3.org/1999/xhtml\";\n  var doc = typeof document === \"undefined\" ? void 0 : document;\n  var HAS_TEMPLATE_SUPPORT = !!doc && \"content\" in doc.createElement(\"template\");\n  var HAS_RANGE_SUPPORT = !!doc && doc.createRange && \"createContextualFragment\" in doc.createRange();\n\n  function createFragmentFromTemplate(str) {\n    var template = doc.createElement(\"template\");\n    template.innerHTML = str;\n    return template.content.childNodes[0];\n  }\n\n  function createFragmentFromRange(str) {\n    if (!range) {\n      range = doc.createRange();\n      range.selectNode(doc.body);\n    }\n\n    var fragment = range.createContextualFragment(str);\n    return fragment.childNodes[0];\n  }\n\n  function createFragmentFromWrap(str) {\n    var fragment = doc.createElement(\"body\");\n    fragment.innerHTML = str;\n    return fragment.childNodes[0];\n  }\n\n  function toElement(str) {\n    str = str.trim();\n\n    if (HAS_TEMPLATE_SUPPORT) {\n      return createFragmentFromTemplate(str);\n    } else if (HAS_RANGE_SUPPORT) {\n      return createFragmentFromRange(str);\n    }\n\n    return createFragmentFromWrap(str);\n  }\n\n  function compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n    var fromCodeStart, toCodeStart;\n\n    if (fromNodeName === toNodeName) {\n      return true;\n    }\n\n    fromCodeStart = fromNodeName.charCodeAt(0);\n    toCodeStart = toNodeName.charCodeAt(0);\n\n    if (fromCodeStart <= 90 && toCodeStart >= 97) {\n      return fromNodeName === toNodeName.toUpperCase();\n    } else if (toCodeStart <= 90 && fromCodeStart >= 97) {\n      return toNodeName === fromNodeName.toUpperCase();\n    } else {\n      return false;\n    }\n  }\n\n  function createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);\n  }\n\n  function moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n\n    while (curChild) {\n      var nextChild = curChild.nextSibling;\n      toEl.appendChild(curChild);\n      curChild = nextChild;\n    }\n\n    return toEl;\n  }\n\n  function syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n      fromEl[name] = toEl[name];\n\n      if (fromEl[name]) {\n        fromEl.setAttribute(name, \"\");\n      } else {\n        fromEl.removeAttribute(name);\n      }\n    }\n  }\n\n  var specialElHandlers = {\n    OPTION: function (fromEl, toEl) {\n      var parentNode = fromEl.parentNode;\n\n      if (parentNode) {\n        var parentName = parentNode.nodeName.toUpperCase();\n\n        if (parentName === \"OPTGROUP\") {\n          parentNode = parentNode.parentNode;\n          parentName = parentNode && parentNode.nodeName.toUpperCase();\n        }\n\n        if (parentName === \"SELECT\" && !parentNode.hasAttribute(\"multiple\")) {\n          if (fromEl.hasAttribute(\"selected\") && !toEl.selected) {\n            fromEl.setAttribute(\"selected\", \"selected\");\n            fromEl.removeAttribute(\"selected\");\n          }\n\n          parentNode.selectedIndex = -1;\n        }\n      }\n\n      syncBooleanAttrProp(fromEl, toEl, \"selected\");\n    },\n    INPUT: function (fromEl, toEl) {\n      syncBooleanAttrProp(fromEl, toEl, \"checked\");\n      syncBooleanAttrProp(fromEl, toEl, \"disabled\");\n\n      if (fromEl.value !== toEl.value) {\n        fromEl.value = toEl.value;\n      }\n\n      if (!toEl.hasAttribute(\"value\")) {\n        fromEl.removeAttribute(\"value\");\n      }\n    },\n    TEXTAREA: function (fromEl, toEl) {\n      var newValue = toEl.value;\n\n      if (fromEl.value !== newValue) {\n        fromEl.value = newValue;\n      }\n\n      var firstChild = fromEl.firstChild;\n\n      if (firstChild) {\n        var oldValue = firstChild.nodeValue;\n\n        if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {\n          return;\n        }\n\n        firstChild.nodeValue = newValue;\n      }\n    },\n    SELECT: function (fromEl, toEl) {\n      if (!toEl.hasAttribute(\"multiple\")) {\n        var selectedIndex = -1;\n        var i = 0;\n        var curChild = fromEl.firstChild;\n        var optgroup;\n        var nodeName;\n\n        while (curChild) {\n          nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\n\n          if (nodeName === \"OPTGROUP\") {\n            optgroup = curChild;\n            curChild = optgroup.firstChild;\n          } else {\n            if (nodeName === \"OPTION\") {\n              if (curChild.hasAttribute(\"selected\")) {\n                selectedIndex = i;\n                break;\n              }\n\n              i++;\n            }\n\n            curChild = curChild.nextSibling;\n\n            if (!curChild && optgroup) {\n              curChild = optgroup.nextSibling;\n              optgroup = null;\n            }\n          }\n        }\n\n        fromEl.selectedIndex = selectedIndex;\n      }\n    }\n  };\n  var ELEMENT_NODE = 1;\n  var DOCUMENT_FRAGMENT_NODE$1 = 11;\n  var TEXT_NODE = 3;\n  var COMMENT_NODE = 8;\n\n  function noop() {}\n\n  function defaultGetNodeKey(node) {\n    if (node) {\n      return node.getAttribute && node.getAttribute(\"id\") || node.id;\n    }\n  }\n\n  function morphdomFactory(morphAttrs2) {\n    return function morphdom2(fromNode, toNode, options) {\n      if (!options) {\n        options = {};\n      }\n\n      if (typeof toNode === \"string\") {\n        if (fromNode.nodeName === \"#document\" || fromNode.nodeName === \"HTML\" || fromNode.nodeName === \"BODY\") {\n          var toNodeHtml = toNode;\n          toNode = doc.createElement(\"html\");\n          toNode.innerHTML = toNodeHtml;\n        } else {\n          toNode = toElement(toNode);\n        }\n      }\n\n      var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n      var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n      var onNodeAdded = options.onNodeAdded || noop;\n      var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n      var onElUpdated = options.onElUpdated || noop;\n      var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n      var onNodeDiscarded = options.onNodeDiscarded || noop;\n      var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n      var childrenOnly = options.childrenOnly === true;\n      var fromNodesLookup = Object.create(null);\n      var keyedRemovalList = [];\n\n      function addKeyedRemoval(key) {\n        keyedRemovalList.push(key);\n      }\n\n      function walkDiscardedChildNodes(node, skipKeyedNodes) {\n        if (node.nodeType === ELEMENT_NODE) {\n          var curChild = node.firstChild;\n\n          while (curChild) {\n            var key = void 0;\n\n            if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n              addKeyedRemoval(key);\n            } else {\n              onNodeDiscarded(curChild);\n\n              if (curChild.firstChild) {\n                walkDiscardedChildNodes(curChild, skipKeyedNodes);\n              }\n            }\n\n            curChild = curChild.nextSibling;\n          }\n        }\n      }\n\n      function removeNode(node, parentNode, skipKeyedNodes) {\n        if (onBeforeNodeDiscarded(node) === false) {\n          return;\n        }\n\n        if (parentNode) {\n          parentNode.removeChild(node);\n        }\n\n        onNodeDiscarded(node);\n        walkDiscardedChildNodes(node, skipKeyedNodes);\n      }\n\n      function indexTree(node) {\n        if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {\n          var curChild = node.firstChild;\n\n          while (curChild) {\n            var key = getNodeKey(curChild);\n\n            if (key) {\n              fromNodesLookup[key] = curChild;\n            }\n\n            indexTree(curChild);\n            curChild = curChild.nextSibling;\n          }\n        }\n      }\n\n      indexTree(fromNode);\n\n      function handleNodeAdded(el) {\n        onNodeAdded(el);\n        var curChild = el.firstChild;\n\n        while (curChild) {\n          var nextSibling = curChild.nextSibling;\n          var key = getNodeKey(curChild);\n\n          if (key) {\n            var unmatchedFromEl = fromNodesLookup[key];\n\n            if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n              curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n              morphEl(unmatchedFromEl, curChild);\n            } else {\n              handleNodeAdded(curChild);\n            }\n          } else {\n            handleNodeAdded(curChild);\n          }\n\n          curChild = nextSibling;\n        }\n      }\n\n      function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {\n        while (curFromNodeChild) {\n          var fromNextSibling = curFromNodeChild.nextSibling;\n\n          if (curFromNodeKey = getNodeKey(curFromNodeChild)) {\n            addKeyedRemoval(curFromNodeKey);\n          } else {\n            removeNode(curFromNodeChild, fromEl, true);\n          }\n\n          curFromNodeChild = fromNextSibling;\n        }\n      }\n\n      function morphEl(fromEl, toEl, childrenOnly2) {\n        var toElKey = getNodeKey(toEl);\n\n        if (toElKey) {\n          delete fromNodesLookup[toElKey];\n        }\n\n        if (!childrenOnly2) {\n          if (onBeforeElUpdated(fromEl, toEl) === false) {\n            return;\n          }\n\n          morphAttrs2(fromEl, toEl);\n          onElUpdated(fromEl);\n\n          if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n            return;\n          }\n        }\n\n        if (fromEl.nodeName !== \"TEXTAREA\") {\n          morphChildren(fromEl, toEl);\n        } else {\n          specialElHandlers.TEXTAREA(fromEl, toEl);\n        }\n      }\n\n      function morphChildren(fromEl, toEl) {\n        var curToNodeChild = toEl.firstChild;\n        var curFromNodeChild = fromEl.firstChild;\n        var curToNodeKey;\n        var curFromNodeKey;\n        var fromNextSibling;\n        var toNextSibling;\n        var matchingFromEl;\n\n        outer: while (curToNodeChild) {\n          toNextSibling = curToNodeChild.nextSibling;\n          curToNodeKey = getNodeKey(curToNodeChild);\n\n          while (curFromNodeChild) {\n            fromNextSibling = curFromNodeChild.nextSibling;\n\n            if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n              curToNodeChild = toNextSibling;\n              curFromNodeChild = fromNextSibling;\n              continue outer;\n            }\n\n            curFromNodeKey = getNodeKey(curFromNodeChild);\n            var curFromNodeType = curFromNodeChild.nodeType;\n            var isCompatible = void 0;\n\n            if (curFromNodeType === curToNodeChild.nodeType) {\n              if (curFromNodeType === ELEMENT_NODE) {\n                if (curToNodeKey) {\n                  if (curToNodeKey !== curFromNodeKey) {\n                    if (matchingFromEl = fromNodesLookup[curToNodeKey]) {\n                      if (fromNextSibling === matchingFromEl) {\n                        isCompatible = false;\n                      } else {\n                        fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                        if (curFromNodeKey) {\n                          addKeyedRemoval(curFromNodeKey);\n                        } else {\n                          removeNode(curFromNodeChild, fromEl, true);\n                        }\n\n                        curFromNodeChild = matchingFromEl;\n                      }\n                    } else {\n                      isCompatible = false;\n                    }\n                  }\n                } else if (curFromNodeKey) {\n                  isCompatible = false;\n                }\n\n                isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n\n                if (isCompatible) {\n                  morphEl(curFromNodeChild, curToNodeChild);\n                }\n              } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                isCompatible = true;\n\n                if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                  curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                }\n              }\n            }\n\n            if (isCompatible) {\n              curToNodeChild = toNextSibling;\n              curFromNodeChild = fromNextSibling;\n              continue outer;\n            }\n\n            if (curFromNodeKey) {\n              addKeyedRemoval(curFromNodeKey);\n            } else {\n              removeNode(curFromNodeChild, fromEl, true);\n            }\n\n            curFromNodeChild = fromNextSibling;\n          }\n\n          if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n            fromEl.appendChild(matchingFromEl);\n            morphEl(matchingFromEl, curToNodeChild);\n          } else {\n            var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n\n            if (onBeforeNodeAddedResult !== false) {\n              if (onBeforeNodeAddedResult) {\n                curToNodeChild = onBeforeNodeAddedResult;\n              }\n\n              if (curToNodeChild.actualize) {\n                curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n              }\n\n              fromEl.appendChild(curToNodeChild);\n              handleNodeAdded(curToNodeChild);\n            }\n          }\n\n          curToNodeChild = toNextSibling;\n          curFromNodeChild = fromNextSibling;\n        }\n\n        cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);\n        var specialElHandler = specialElHandlers[fromEl.nodeName];\n\n        if (specialElHandler) {\n          specialElHandler(fromEl, toEl);\n        }\n      }\n\n      var morphedNode = fromNode;\n      var morphedNodeType = morphedNode.nodeType;\n      var toNodeType = toNode.nodeType;\n\n      if (!childrenOnly) {\n        if (morphedNodeType === ELEMENT_NODE) {\n          if (toNodeType === ELEMENT_NODE) {\n            if (!compareNodeNames(fromNode, toNode)) {\n              onNodeDiscarded(fromNode);\n              morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n            }\n          } else {\n            morphedNode = toNode;\n          }\n        } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {\n          if (toNodeType === morphedNodeType) {\n            if (morphedNode.nodeValue !== toNode.nodeValue) {\n              morphedNode.nodeValue = toNode.nodeValue;\n            }\n\n            return morphedNode;\n          } else {\n            morphedNode = toNode;\n          }\n        }\n      }\n\n      if (morphedNode === toNode) {\n        onNodeDiscarded(fromNode);\n      } else {\n        if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {\n          return;\n        }\n\n        morphEl(morphedNode, toNode, childrenOnly);\n\n        if (keyedRemovalList) {\n          for (var i = 0, len = keyedRemovalList.length; i < len; i++) {\n            var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n\n            if (elToRemove) {\n              removeNode(elToRemove, elToRemove.parentNode, false);\n            }\n          }\n        }\n      }\n\n      if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n        if (morphedNode.actualize) {\n          morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n        }\n\n        fromNode.parentNode.replaceChild(morphedNode, fromNode);\n      }\n\n      return morphedNode;\n    };\n  }\n\n  var morphdom = morphdomFactory(morphAttrs);\n  var morphdom_esm_default = morphdom; // js/phoenix_live_view/dom_patch.js\n\n  var DOMPatch = class {\n    static patchEl(fromEl, toEl, activeElement) {\n      morphdom_esm_default(fromEl, toEl, {\n        childrenOnly: false,\n        onBeforeElUpdated: (fromEl2, toEl2) => {\n          if (activeElement && activeElement.isSameNode(fromEl2) && dom_default.isFormInput(fromEl2)) {\n            dom_default.mergeFocusedInput(fromEl2, toEl2);\n            return false;\n          }\n        }\n      });\n    }\n\n    constructor(view, container, id, html, targetCID) {\n      this.view = view;\n      this.liveSocket = view.liveSocket;\n      this.container = container;\n      this.id = id;\n      this.rootID = view.root.id;\n      this.html = html;\n      this.targetCID = targetCID;\n      this.cidPatch = isCid(this.targetCID);\n      this.callbacks = {\n        beforeadded: [],\n        beforeupdated: [],\n        beforephxChildAdded: [],\n        afteradded: [],\n        afterupdated: [],\n        afterdiscarded: [],\n        afterphxChildAdded: []\n      };\n    }\n\n    before(kind, callback) {\n      this.callbacks[`before${kind}`].push(callback);\n    }\n\n    after(kind, callback) {\n      this.callbacks[`after${kind}`].push(callback);\n    }\n\n    trackBefore(kind, ...args) {\n      this.callbacks[`before${kind}`].forEach(callback => callback(...args));\n    }\n\n    trackAfter(kind, ...args) {\n      this.callbacks[`after${kind}`].forEach(callback => callback(...args));\n    }\n\n    markPrunableContentForRemoval() {\n      dom_default.all(this.container, \"[phx-update=append] > *, [phx-update=prepend] > *\", el => {\n        el.setAttribute(PHX_REMOVE, \"\");\n      });\n    }\n\n    perform() {\n      let {\n        view,\n        liveSocket,\n        container,\n        html\n      } = this;\n      let targetContainer = this.isCIDPatch() ? this.targetCIDContainer(html) : container;\n\n      if (this.isCIDPatch() && !targetContainer) {\n        return;\n      }\n\n      let focused = liveSocket.getActiveElement();\n      let {\n        selectionStart,\n        selectionEnd\n      } = focused && dom_default.hasSelectionRange(focused) ? focused : {};\n      let phxUpdate = liveSocket.binding(PHX_UPDATE);\n      let phxFeedbackFor = liveSocket.binding(PHX_FEEDBACK_FOR);\n      let disableWith = liveSocket.binding(PHX_DISABLE_WITH);\n      let phxTriggerExternal = liveSocket.binding(PHX_TRIGGER_ACTION);\n      let added = [];\n      let updates = [];\n      let appendPrependUpdates = [];\n      let externalFormTriggered = null;\n      let diffHTML = liveSocket.time(\"premorph container prep\", () => {\n        return this.buildDiffHTML(container, html, phxUpdate, targetContainer);\n      });\n      this.trackBefore(\"added\", container);\n      this.trackBefore(\"updated\", container, container);\n      liveSocket.time(\"morphdom\", () => {\n        morphdom_esm_default(targetContainer, diffHTML, {\n          childrenOnly: targetContainer.getAttribute(PHX_COMPONENT) === null,\n          getNodeKey: node => {\n            return dom_default.isPhxDestroyed(node) ? null : node.id;\n          },\n          onBeforeNodeAdded: el => {\n            this.trackBefore(\"added\", el);\n            return el;\n          },\n          onNodeAdded: el => {\n            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {\n              externalFormTriggered = el;\n            }\n\n            dom_default.discardError(targetContainer, el, phxFeedbackFor);\n\n            if (dom_default.isPhxChild(el) && view.ownsElement(el)) {\n              this.trackAfter(\"phxChildAdded\", el);\n            }\n\n            added.push(el);\n          },\n          onNodeDiscarded: el => {\n            if (dom_default.isPhxChild(el)) {\n              liveSocket.destroyViewByEl(el);\n            }\n\n            this.trackAfter(\"discarded\", el);\n          },\n          onBeforeNodeDiscarded: el => {\n            if (el.getAttribute && el.getAttribute(PHX_REMOVE) !== null) {\n              return true;\n            }\n\n            if (el.parentNode !== null && dom_default.isPhxUpdate(el.parentNode, phxUpdate, [\"append\", \"prepend\"]) && el.id) {\n              return false;\n            }\n\n            if (this.skipCIDSibling(el)) {\n              return false;\n            }\n\n            return true;\n          },\n          onElUpdated: el => {\n            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {\n              externalFormTriggered = el;\n            }\n\n            updates.push(el);\n          },\n          onBeforeElUpdated: (fromEl, toEl) => {\n            dom_default.cleanChildNodes(toEl, phxUpdate);\n\n            if (this.skipCIDSibling(toEl)) {\n              return false;\n            }\n\n            if (dom_default.isIgnored(fromEl, phxUpdate)) {\n              this.trackBefore(\"updated\", fromEl, toEl);\n              dom_default.mergeAttrs(fromEl, toEl, {\n                isIgnored: true\n              });\n              updates.push(fromEl);\n              return false;\n            }\n\n            if (fromEl.type === \"number\" && fromEl.validity && fromEl.validity.badInput) {\n              return false;\n            }\n\n            if (!dom_default.syncPendingRef(fromEl, toEl, disableWith)) {\n              if (dom_default.isUploadInput(fromEl)) {\n                this.trackBefore(\"updated\", fromEl, toEl);\n                updates.push(fromEl);\n              }\n\n              return false;\n            }\n\n            if (dom_default.isPhxChild(toEl)) {\n              let prevSession = fromEl.getAttribute(PHX_SESSION);\n              dom_default.mergeAttrs(fromEl, toEl, {\n                exclude: [PHX_STATIC]\n              });\n\n              if (prevSession !== \"\") {\n                fromEl.setAttribute(PHX_SESSION, prevSession);\n              }\n\n              fromEl.setAttribute(PHX_ROOT_ID, this.rootID);\n              return false;\n            }\n\n            dom_default.copyPrivates(toEl, fromEl);\n            dom_default.discardError(targetContainer, toEl, phxFeedbackFor);\n            dom_default.syncPropsToAttrs(toEl);\n            let isFocusedFormEl = focused && fromEl.isSameNode(focused) && dom_default.isFormInput(fromEl);\n\n            if (isFocusedFormEl && !this.forceFocusedSelectUpdate(fromEl, toEl)) {\n              this.trackBefore(\"updated\", fromEl, toEl);\n              dom_default.mergeFocusedInput(fromEl, toEl);\n              dom_default.syncAttrsToProps(fromEl);\n              updates.push(fromEl);\n              return false;\n            } else {\n              if (dom_default.isPhxUpdate(toEl, phxUpdate, [\"append\", \"prepend\"])) {\n                appendPrependUpdates.push(new DOMPostMorphRestorer(fromEl, toEl, toEl.getAttribute(phxUpdate)));\n              }\n\n              dom_default.syncAttrsToProps(toEl);\n              this.trackBefore(\"updated\", fromEl, toEl);\n              return true;\n            }\n          }\n        });\n      });\n\n      if (liveSocket.isDebugEnabled()) {\n        detectDuplicateIds();\n      }\n\n      if (appendPrependUpdates.length > 0) {\n        liveSocket.time(\"post-morph append/prepend restoration\", () => {\n          appendPrependUpdates.forEach(update => update.perform());\n        });\n      }\n\n      liveSocket.silenceEvents(() => dom_default.restoreFocus(focused, selectionStart, selectionEnd));\n      dom_default.dispatchEvent(document, \"phx:update\");\n      added.forEach(el => this.trackAfter(\"added\", el));\n      updates.forEach(el => this.trackAfter(\"updated\", el));\n\n      if (externalFormTriggered) {\n        liveSocket.disconnect();\n        externalFormTriggered.submit();\n      }\n\n      return true;\n    }\n\n    forceFocusedSelectUpdate(fromEl, toEl) {\n      let isSelect = [\"select\", \"select-one\", \"select-multiple\"].find(t => t === fromEl.type);\n      return fromEl.multiple === true || isSelect && fromEl.innerHTML != toEl.innerHTML;\n    }\n\n    isCIDPatch() {\n      return this.cidPatch;\n    }\n\n    skipCIDSibling(el) {\n      return el.nodeType === Node.ELEMENT_NODE && el.getAttribute(PHX_SKIP) !== null;\n    }\n\n    targetCIDContainer(html) {\n      if (!this.isCIDPatch()) {\n        return;\n      }\n\n      let [first, ...rest] = dom_default.findComponentNodeList(this.container, this.targetCID);\n\n      if (rest.length === 0 && dom_default.childNodeLength(html) === 1) {\n        return first;\n      } else {\n        return first && first.parentNode;\n      }\n    }\n\n    buildDiffHTML(container, html, phxUpdate, targetContainer) {\n      let isCIDPatch = this.isCIDPatch();\n      let isCIDWithSingleRoot = isCIDPatch && targetContainer.getAttribute(PHX_COMPONENT) === this.targetCID.toString();\n\n      if (!isCIDPatch || isCIDWithSingleRoot) {\n        return html;\n      } else {\n        let diffContainer = null;\n        let template = document.createElement(\"template\");\n        diffContainer = dom_default.cloneNode(targetContainer);\n        let [firstComponent, ...rest] = dom_default.findComponentNodeList(diffContainer, this.targetCID);\n        template.innerHTML = html;\n        rest.forEach(el => el.remove());\n        Array.from(diffContainer.childNodes).forEach(child => {\n          if (child.id && child.nodeType === Node.ELEMENT_NODE && child.getAttribute(PHX_COMPONENT) !== this.targetCID.toString()) {\n            child.setAttribute(PHX_SKIP, \"\");\n            child.innerHTML = \"\";\n          }\n        });\n        Array.from(template.content.childNodes).forEach(el => diffContainer.insertBefore(el, firstComponent));\n        firstComponent.remove();\n        return diffContainer.outerHTML;\n      }\n    }\n\n  }; // js/phoenix_live_view/rendered.js\n\n  var Rendered = class {\n    static extract(diff) {\n      let {\n        [REPLY]: reply,\n        [EVENTS]: events,\n        [TITLE]: title\n      } = diff;\n      delete diff[REPLY];\n      delete diff[EVENTS];\n      delete diff[TITLE];\n      return {\n        diff,\n        title,\n        reply: reply || null,\n        events: events || []\n      };\n    }\n\n    constructor(viewId, rendered) {\n      this.viewId = viewId;\n      this.rendered = {};\n      this.mergeDiff(rendered);\n    }\n\n    parentViewId() {\n      return this.viewId;\n    }\n\n    toString(onlyCids) {\n      return this.recursiveToString(this.rendered, this.rendered[COMPONENTS], onlyCids);\n    }\n\n    recursiveToString(rendered, components = rendered[COMPONENTS], onlyCids) {\n      onlyCids = onlyCids ? new Set(onlyCids) : null;\n      let output = {\n        buffer: \"\",\n        components,\n        onlyCids\n      };\n      this.toOutputBuffer(rendered, output);\n      return output.buffer;\n    }\n\n    componentCIDs(diff) {\n      return Object.keys(diff[COMPONENTS] || {}).map(i => parseInt(i));\n    }\n\n    isComponentOnlyDiff(diff) {\n      if (!diff[COMPONENTS]) {\n        return false;\n      }\n\n      return Object.keys(diff).length === 1;\n    }\n\n    getComponent(diff, cid) {\n      return diff[COMPONENTS][cid];\n    }\n\n    mergeDiff(diff) {\n      let newc = diff[COMPONENTS];\n      let cache = {};\n      delete diff[COMPONENTS];\n      this.rendered = this.mutableMerge(this.rendered, diff);\n      this.rendered[COMPONENTS] = this.rendered[COMPONENTS] || {};\n\n      if (newc) {\n        let oldc = this.rendered[COMPONENTS];\n\n        for (let cid in newc) {\n          newc[cid] = this.cachedFindComponent(cid, newc[cid], oldc, newc, cache);\n        }\n\n        for (var key in newc) {\n          oldc[key] = newc[key];\n        }\n\n        diff[COMPONENTS] = newc;\n      }\n    }\n\n    cachedFindComponent(cid, cdiff, oldc, newc, cache) {\n      if (cache[cid]) {\n        return cache[cid];\n      } else {\n        let ndiff,\n            stat,\n            scid = cdiff[STATIC];\n\n        if (isCid(scid)) {\n          let tdiff;\n\n          if (scid > 0) {\n            tdiff = this.cachedFindComponent(scid, newc[scid], oldc, newc, cache);\n          } else {\n            tdiff = oldc[-scid];\n          }\n\n          stat = tdiff[STATIC];\n          ndiff = this.cloneMerge(tdiff, cdiff);\n          ndiff[STATIC] = stat;\n        } else {\n          ndiff = cdiff[STATIC] !== void 0 ? cdiff : this.cloneMerge(oldc[cid] || {}, cdiff);\n        }\n\n        cache[cid] = ndiff;\n        return ndiff;\n      }\n    }\n\n    mutableMerge(target, source) {\n      if (source[STATIC] !== void 0) {\n        return source;\n      } else {\n        this.doMutableMerge(target, source);\n        return target;\n      }\n    }\n\n    doMutableMerge(target, source) {\n      for (let key in source) {\n        let val = source[key];\n        let targetVal = target[key];\n\n        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {\n          this.doMutableMerge(targetVal, val);\n        } else {\n          target[key] = val;\n        }\n      }\n    }\n\n    cloneMerge(target, source) {\n      let merged = __spreadValues(__spreadValues({}, target), source);\n\n      for (let key in merged) {\n        let val = source[key];\n        let targetVal = target[key];\n\n        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {\n          merged[key] = this.cloneMerge(targetVal, val);\n        }\n      }\n\n      return merged;\n    }\n\n    componentToString(cid) {\n      return this.recursiveCIDToString(this.rendered[COMPONENTS], cid);\n    }\n\n    pruneCIDs(cids) {\n      cids.forEach(cid => delete this.rendered[COMPONENTS][cid]);\n    }\n\n    get() {\n      return this.rendered;\n    }\n\n    isNewFingerprint(diff = {}) {\n      return !!diff[STATIC];\n    }\n\n    toOutputBuffer(rendered, output) {\n      if (rendered[DYNAMICS]) {\n        return this.comprehensionToBuffer(rendered, output);\n      }\n\n      let {\n        [STATIC]: statics\n      } = rendered;\n      output.buffer += statics[0];\n\n      for (let i = 1; i < statics.length; i++) {\n        this.dynamicToBuffer(rendered[i - 1], output);\n        output.buffer += statics[i];\n      }\n    }\n\n    comprehensionToBuffer(rendered, output) {\n      let {\n        [DYNAMICS]: dynamics,\n        [STATIC]: statics\n      } = rendered;\n\n      for (let d = 0; d < dynamics.length; d++) {\n        let dynamic = dynamics[d];\n        output.buffer += statics[0];\n\n        for (let i = 1; i < statics.length; i++) {\n          this.dynamicToBuffer(dynamic[i - 1], output);\n          output.buffer += statics[i];\n        }\n      }\n    }\n\n    dynamicToBuffer(rendered, output) {\n      if (typeof rendered === \"number\") {\n        output.buffer += this.recursiveCIDToString(output.components, rendered, output.onlyCids);\n      } else if (isObject(rendered)) {\n        this.toOutputBuffer(rendered, output);\n      } else {\n        output.buffer += rendered;\n      }\n    }\n\n    recursiveCIDToString(components, cid, onlyCids) {\n      let component = components[cid] || logError(`no component for CID ${cid}`, components);\n      let template = document.createElement(\"template\");\n      template.innerHTML = this.recursiveToString(component, components, onlyCids);\n      let container = template.content;\n      let skip = onlyCids && !onlyCids.has(cid);\n      let [hasChildNodes, hasChildComponents] = Array.from(container.childNodes).reduce(([hasNodes, hasComponents], child, i) => {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n          if (child.getAttribute(PHX_COMPONENT)) {\n            return [hasNodes, true];\n          }\n\n          child.setAttribute(PHX_COMPONENT, cid);\n\n          if (!child.id) {\n            child.id = `${this.parentViewId()}-${cid}-${i}`;\n          }\n\n          if (skip) {\n            child.setAttribute(PHX_SKIP, \"\");\n            child.innerHTML = \"\";\n          }\n\n          return [true, hasComponents];\n        } else {\n          if (child.nodeValue.trim() !== \"\") {\n            logError(`only HTML element tags are allowed at the root of components.\n\ngot: \"${child.nodeValue.trim()}\"\n\nwithin:\n`, template.innerHTML.trim());\n            child.replaceWith(this.createSpan(child.nodeValue, cid));\n            return [true, hasComponents];\n          } else {\n            child.remove();\n            return [hasNodes, hasComponents];\n          }\n        }\n      }, [false, false]);\n\n      if (!hasChildNodes && !hasChildComponents) {\n        logError(\"expected at least one HTML element tag inside a component, but the component is empty:\\n\", template.innerHTML.trim());\n        return this.createSpan(\"\", cid).outerHTML;\n      } else if (!hasChildNodes && hasChildComponents) {\n        logError(\"expected at least one HTML element tag directly inside a component, but only subcomponents were found. A component must render at least one HTML tag directly inside itself.\", template.innerHTML.trim());\n        return template.innerHTML;\n      } else {\n        return template.innerHTML;\n      }\n    }\n\n    createSpan(text, cid) {\n      let span = document.createElement(\"span\");\n      span.innerText = text;\n      span.setAttribute(PHX_COMPONENT, cid);\n      return span;\n    }\n\n  }; // js/phoenix_live_view/view_hook.js\n\n  var viewHookID = 1;\n  var ViewHook = class {\n    static makeID() {\n      return viewHookID++;\n    }\n\n    static elementID(el) {\n      return el.phxHookId;\n    }\n\n    constructor(view, el, callbacks) {\n      this.__view = view;\n      this.__liveSocket = view.liveSocket;\n      this.__callbacks = callbacks;\n      this.__listeners = new Set();\n      this.__isDisconnected = false;\n      this.el = el;\n      this.el.phxHookId = this.constructor.makeID();\n\n      for (let key in this.__callbacks) {\n        this[key] = this.__callbacks[key];\n      }\n    }\n\n    __mounted() {\n      this.mounted && this.mounted();\n    }\n\n    __updated() {\n      this.updated && this.updated();\n    }\n\n    __beforeUpdate() {\n      this.beforeUpdate && this.beforeUpdate();\n    }\n\n    __destroyed() {\n      this.destroyed && this.destroyed();\n    }\n\n    __reconnected() {\n      if (this.__isDisconnected) {\n        this.__isDisconnected = false;\n        this.reconnected && this.reconnected();\n      }\n    }\n\n    __disconnected() {\n      this.__isDisconnected = true;\n      this.disconnected && this.disconnected();\n    }\n\n    pushEvent(event, payload = {}, onReply = function () {}) {\n      return this.__view.pushHookEvent(null, event, payload, onReply);\n    }\n\n    pushEventTo(phxTarget, event, payload = {}, onReply = function () {}) {\n      return this.__view.withinTargets(phxTarget, (view, targetCtx) => {\n        return view.pushHookEvent(targetCtx, event, payload, onReply);\n      });\n    }\n\n    handleEvent(event, callback) {\n      let callbackRef = (customEvent, bypass) => bypass ? event : callback(customEvent.detail);\n\n      window.addEventListener(`phx:hook:${event}`, callbackRef);\n\n      this.__listeners.add(callbackRef);\n\n      return callbackRef;\n    }\n\n    removeHandleEvent(callbackRef) {\n      let event = callbackRef(null, true);\n      window.removeEventListener(`phx:hook:${event}`, callbackRef);\n\n      this.__listeners.delete(callbackRef);\n    }\n\n    upload(name, files) {\n      return this.__view.dispatchUploads(name, files);\n    }\n\n    uploadTo(phxTarget, name, files) {\n      return this.__view.withinTargets(phxTarget, view => view.dispatchUploads(name, files));\n    }\n\n    __cleanup__() {\n      this.__listeners.forEach(callbackRef => this.removeHandleEvent(callbackRef));\n    }\n\n  }; // js/phoenix_live_view/view.js\n\n  var serializeForm = (form, meta = {}) => {\n    let formData = new FormData(form);\n    let toRemove = [];\n    formData.forEach((val, key, _index) => {\n      if (val instanceof File) {\n        toRemove.push(key);\n      }\n    });\n    toRemove.forEach(key => formData.delete(key));\n    let params = new URLSearchParams();\n\n    for (let [key, val] of formData.entries()) {\n      params.append(key, val);\n    }\n\n    for (let metaKey in meta) {\n      params.append(metaKey, meta[metaKey]);\n    }\n\n    return params.toString();\n  };\n\n  var View = class {\n    constructor(el, liveSocket, parentView, flash) {\n      this.liveSocket = liveSocket;\n      this.flash = flash;\n      this.parent = parentView;\n      this.root = parentView ? parentView.root : this;\n      this.el = el;\n      this.id = this.el.id;\n      this.ref = 0;\n      this.childJoins = 0;\n      this.loaderTimer = null;\n      this.pendingDiffs = [];\n      this.pruningCIDs = [];\n      this.redirect = false;\n      this.href = null;\n      this.joinCount = this.parent ? this.parent.joinCount - 1 : 0;\n      this.joinPending = true;\n      this.destroyed = false;\n\n      this.joinCallback = function () {};\n\n      this.stopCallback = function () {};\n\n      this.pendingJoinOps = this.parent ? null : [];\n      this.viewHooks = {};\n      this.uploaders = {};\n      this.formSubmits = [];\n      this.children = this.parent ? null : {};\n      this.root.children[this.id] = {};\n      this.channel = this.liveSocket.channel(`lv:${this.id}`, () => {\n        return {\n          redirect: this.redirect ? this.href : void 0,\n          url: this.redirect ? void 0 : this.href || void 0,\n          params: this.connectParams(),\n          session: this.getSession(),\n          static: this.getStatic(),\n          flash: this.flash\n        };\n      });\n      this.showLoader(this.liveSocket.loaderTimeout);\n      this.bindChannel();\n    }\n\n    setHref(href) {\n      this.href = href;\n    }\n\n    setRedirect(href) {\n      this.redirect = true;\n      this.href = href;\n    }\n\n    isMain() {\n      return this.liveSocket.main === this;\n    }\n\n    connectParams() {\n      let params = this.liveSocket.params(this.el);\n      let manifest = dom_default.all(document, `[${this.binding(PHX_TRACK_STATIC)}]`).map(node => node.src || node.href).filter(url => typeof url === \"string\");\n\n      if (manifest.length > 0) {\n        params[\"_track_static\"] = manifest;\n      }\n\n      params[\"_mounts\"] = this.joinCount;\n      return params;\n    }\n\n    isConnected() {\n      return this.channel.canPush();\n    }\n\n    getSession() {\n      return this.el.getAttribute(PHX_SESSION);\n    }\n\n    getStatic() {\n      let val = this.el.getAttribute(PHX_STATIC);\n      return val === \"\" ? null : val;\n    }\n\n    destroy(callback = function () {}) {\n      this.destroyAllChildren();\n      this.destroyed = true;\n      delete this.root.children[this.id];\n\n      if (this.parent) {\n        delete this.root.children[this.parent.id][this.id];\n      }\n\n      clearTimeout(this.loaderTimer);\n\n      let onFinished = () => {\n        callback();\n\n        for (let id in this.viewHooks) {\n          this.destroyHook(this.viewHooks[id]);\n        }\n      };\n\n      dom_default.markPhxChildDestroyed(this.el);\n      this.log(\"destroyed\", () => [\"the child has been removed from the parent\"]);\n      this.channel.leave().receive(\"ok\", onFinished).receive(\"error\", onFinished).receive(\"timeout\", onFinished);\n    }\n\n    setContainerClasses(...classes) {\n      this.el.classList.remove(PHX_CONNECTED_CLASS, PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);\n      this.el.classList.add(...classes);\n    }\n\n    isLoading() {\n      return this.el.classList.contains(PHX_DISCONNECTED_CLASS);\n    }\n\n    showLoader(timeout) {\n      clearTimeout(this.loaderTimer);\n\n      if (timeout) {\n        this.loaderTimer = setTimeout(() => this.showLoader(), timeout);\n      } else {\n        for (let id in this.viewHooks) {\n          this.viewHooks[id].__disconnected();\n        }\n\n        this.setContainerClasses(PHX_DISCONNECTED_CLASS);\n      }\n    }\n\n    hideLoader() {\n      clearTimeout(this.loaderTimer);\n      this.setContainerClasses(PHX_CONNECTED_CLASS);\n    }\n\n    triggerReconnected() {\n      for (let id in this.viewHooks) {\n        this.viewHooks[id].__reconnected();\n      }\n    }\n\n    log(kind, msgCallback) {\n      this.liveSocket.log(this, kind, msgCallback);\n    }\n\n    withinTargets(phxTarget, callback) {\n      if (phxTarget instanceof HTMLElement) {\n        return this.liveSocket.owner(phxTarget, view => callback(view, phxTarget));\n      }\n\n      if (/^(0|[1-9]\\d*)$/.test(phxTarget)) {\n        let targets = dom_default.findComponentNodeList(this.el, phxTarget);\n\n        if (targets.length === 0) {\n          logError(`no component found matching phx-target of ${phxTarget}`);\n        } else {\n          callback(this, targets[0]);\n        }\n      } else {\n        let targets = Array.from(document.querySelectorAll(phxTarget));\n\n        if (targets.length === 0) {\n          logError(`nothing found matching the phx-target selector \"${phxTarget}\"`);\n        }\n\n        targets.forEach(target => this.liveSocket.owner(target, view => callback(view, target)));\n      }\n    }\n\n    applyDiff(type, rawDiff, callback) {\n      this.log(type, () => [\"\", clone(rawDiff)]);\n      let {\n        diff,\n        reply,\n        events,\n        title\n      } = Rendered.extract(rawDiff);\n\n      if (title) {\n        dom_default.putTitle(title);\n      }\n\n      callback({\n        diff,\n        reply,\n        events\n      });\n      return reply;\n    }\n\n    onJoin(resp) {\n      let {\n        rendered,\n        container\n      } = resp;\n\n      if (container) {\n        let [tag, attrs] = container;\n        this.el = dom_default.replaceRootContainer(this.el, tag, attrs);\n      }\n\n      this.childJoins = 0;\n      this.joinPending = true;\n      this.flash = null;\n      browser_default.dropLocal(this.liveSocket.localStorage, window.location.pathname, CONSECUTIVE_RELOADS);\n      this.applyDiff(\"mount\", rendered, ({\n        diff,\n        events\n      }) => {\n        this.rendered = new Rendered(this.id, diff);\n        let html = this.renderContainer(null, \"join\");\n        this.dropPendingRefs();\n        let forms = this.formsForRecovery(html);\n        this.joinCount++;\n\n        if (forms.length > 0) {\n          forms.forEach(([form, newForm, newCid], i) => {\n            this.pushFormRecovery(form, newCid, resp2 => {\n              if (i === forms.length - 1) {\n                this.onJoinComplete(resp2, html, events);\n              }\n            });\n          });\n        } else {\n          this.onJoinComplete(resp, html, events);\n        }\n      });\n    }\n\n    dropPendingRefs() {\n      dom_default.all(this.el, `[${PHX_REF}]`, el => el.removeAttribute(PHX_REF));\n    }\n\n    onJoinComplete({\n      live_patch\n    }, html, events) {\n      if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) {\n        return this.applyJoinPatch(live_patch, html, events);\n      }\n\n      let newChildren = dom_default.findPhxChildrenInFragment(html, this.id).filter(toEl => {\n        let fromEl = toEl.id && this.el.querySelector(`[id=\"${toEl.id}\"]`);\n        let phxStatic = fromEl && fromEl.getAttribute(PHX_STATIC);\n\n        if (phxStatic) {\n          toEl.setAttribute(PHX_STATIC, phxStatic);\n        }\n\n        return this.joinChild(toEl);\n      });\n\n      if (newChildren.length === 0) {\n        if (this.parent) {\n          this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);\n          this.parent.ackJoin(this);\n        } else {\n          this.onAllChildJoinsComplete();\n          this.applyJoinPatch(live_patch, html, events);\n        }\n      } else {\n        this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, events)]);\n      }\n    }\n\n    attachTrueDocEl() {\n      this.el = dom_default.byId(this.id);\n      this.el.setAttribute(PHX_ROOT_ID, this.root.id);\n    }\n\n    dispatchEvents(events) {\n      events.forEach(([event, payload]) => {\n        window.dispatchEvent(new CustomEvent(`phx:hook:${event}`, {\n          detail: payload\n        }));\n      });\n    }\n\n    applyJoinPatch(live_patch, html, events) {\n      this.attachTrueDocEl();\n      let patch = new DOMPatch(this, this.el, this.id, html, null);\n      patch.markPrunableContentForRemoval();\n      this.performPatch(patch, false);\n      this.joinNewChildren();\n      dom_default.all(this.el, `[${this.binding(PHX_HOOK)}], [data-phx-${PHX_HOOK}]`, hookEl => {\n        let hook = this.addHook(hookEl);\n\n        if (hook) {\n          hook.__mounted();\n        }\n      });\n      this.joinPending = false;\n      this.dispatchEvents(events);\n      this.applyPendingUpdates();\n\n      if (live_patch) {\n        let {\n          kind,\n          to\n        } = live_patch;\n        this.liveSocket.historyPatch(to, kind);\n      }\n\n      this.hideLoader();\n\n      if (this.joinCount > 1) {\n        this.triggerReconnected();\n      }\n\n      this.stopCallback();\n    }\n\n    triggerBeforeUpdateHook(fromEl, toEl) {\n      this.liveSocket.triggerDOM(\"onBeforeElUpdated\", [fromEl, toEl]);\n      let hook = this.getHook(fromEl);\n      let isIgnored = hook && dom_default.isIgnored(fromEl, this.binding(PHX_UPDATE));\n\n      if (hook && !fromEl.isEqualNode(toEl) && !(isIgnored && isEqualObj(fromEl.dataset, toEl.dataset))) {\n        hook.__beforeUpdate();\n\n        return hook;\n      }\n    }\n\n    performPatch(patch, pruneCids) {\n      let destroyedCIDs = [];\n      let phxChildrenAdded = false;\n      let updatedHookIds = new Set();\n      patch.after(\"added\", el => {\n        this.liveSocket.triggerDOM(\"onNodeAdded\", [el]);\n        let newHook = this.addHook(el);\n\n        if (newHook) {\n          newHook.__mounted();\n        }\n      });\n      patch.after(\"phxChildAdded\", _el => phxChildrenAdded = true);\n      patch.before(\"updated\", (fromEl, toEl) => {\n        let hook = this.triggerBeforeUpdateHook(fromEl, toEl);\n\n        if (hook) {\n          updatedHookIds.add(fromEl.id);\n        }\n      });\n      patch.after(\"updated\", el => {\n        if (updatedHookIds.has(el.id)) {\n          this.getHook(el).__updated();\n        }\n      });\n      patch.after(\"discarded\", el => {\n        let cid = this.componentID(el);\n\n        if (isCid(cid) && destroyedCIDs.indexOf(cid) === -1) {\n          destroyedCIDs.push(cid);\n        }\n\n        let hook = this.getHook(el);\n        hook && this.destroyHook(hook);\n      });\n      patch.perform();\n\n      if (pruneCids) {\n        this.maybePushComponentsDestroyed(destroyedCIDs);\n      }\n\n      return phxChildrenAdded;\n    }\n\n    joinNewChildren() {\n      dom_default.findPhxChildren(this.el, this.id).forEach(el => this.joinChild(el));\n    }\n\n    getChildById(id) {\n      return this.root.children[this.id][id];\n    }\n\n    getDescendentByEl(el) {\n      if (el.id === this.id) {\n        return this;\n      } else {\n        return this.children[el.getAttribute(PHX_PARENT_ID)][el.id];\n      }\n    }\n\n    destroyDescendent(id) {\n      for (let parentId in this.root.children) {\n        for (let childId in this.root.children[parentId]) {\n          if (childId === id) {\n            return this.root.children[parentId][childId].destroy();\n          }\n        }\n      }\n    }\n\n    joinChild(el) {\n      let child = this.getChildById(el.id);\n\n      if (!child) {\n        let view = new View(el, this.liveSocket, this);\n        this.root.children[this.id][view.id] = view;\n        view.join();\n        this.childJoins++;\n        return true;\n      }\n    }\n\n    isJoinPending() {\n      return this.joinPending;\n    }\n\n    ackJoin(_child) {\n      this.childJoins--;\n\n      if (this.childJoins === 0) {\n        if (this.parent) {\n          this.parent.ackJoin(this);\n        } else {\n          this.onAllChildJoinsComplete();\n        }\n      }\n    }\n\n    onAllChildJoinsComplete() {\n      this.joinCallback();\n      this.pendingJoinOps.forEach(([view, op]) => {\n        if (!view.isDestroyed()) {\n          op();\n        }\n      });\n      this.pendingJoinOps = [];\n    }\n\n    update(diff, events) {\n      if (this.isJoinPending() || this.liveSocket.hasPendingLink()) {\n        return this.pendingDiffs.push({\n          diff,\n          events\n        });\n      }\n\n      this.rendered.mergeDiff(diff);\n      let phxChildrenAdded = false;\n\n      if (this.rendered.isComponentOnlyDiff(diff)) {\n        this.liveSocket.time(\"component patch complete\", () => {\n          let parentCids = dom_default.findParentCIDs(this.el, this.rendered.componentCIDs(diff));\n          parentCids.forEach(parentCID => {\n            if (this.componentPatch(this.rendered.getComponent(diff, parentCID), parentCID)) {\n              phxChildrenAdded = true;\n            }\n          });\n        });\n      } else if (!isEmpty(diff)) {\n        this.liveSocket.time(\"full patch complete\", () => {\n          let html = this.renderContainer(diff, \"update\");\n          let patch = new DOMPatch(this, this.el, this.id, html, null);\n          phxChildrenAdded = this.performPatch(patch, true);\n        });\n      }\n\n      this.dispatchEvents(events);\n\n      if (phxChildrenAdded) {\n        this.joinNewChildren();\n      }\n    }\n\n    renderContainer(diff, kind) {\n      return this.liveSocket.time(`toString diff (${kind})`, () => {\n        let tag = this.el.tagName;\n        let cids = diff ? this.rendered.componentCIDs(diff).concat(this.pruningCIDs) : null;\n        let html = this.rendered.toString(cids);\n        return `<${tag}>${html}</${tag}>`;\n      });\n    }\n\n    componentPatch(diff, cid) {\n      if (isEmpty(diff)) return false;\n      let html = this.rendered.componentToString(cid);\n      let patch = new DOMPatch(this, this.el, this.id, html, cid);\n      let childrenAdded = this.performPatch(patch, true);\n      return childrenAdded;\n    }\n\n    getHook(el) {\n      return this.viewHooks[ViewHook.elementID(el)];\n    }\n\n    addHook(el) {\n      if (ViewHook.elementID(el) || !el.getAttribute) {\n        return;\n      }\n\n      let hookName = el.getAttribute(`data-phx-${PHX_HOOK}`) || el.getAttribute(this.binding(PHX_HOOK));\n\n      if (hookName && !this.ownsElement(el)) {\n        return;\n      }\n\n      let callbacks = this.liveSocket.getHookCallbacks(hookName);\n\n      if (callbacks) {\n        if (!el.id) {\n          logError(`no DOM ID for hook \"${hookName}\". Hooks require a unique ID on each element.`, el);\n        }\n\n        let hook = new ViewHook(this, el, callbacks);\n        this.viewHooks[ViewHook.elementID(hook.el)] = hook;\n        return hook;\n      } else if (hookName !== null) {\n        logError(`unknown hook found for \"${hookName}\"`, el);\n      }\n    }\n\n    destroyHook(hook) {\n      hook.__destroyed();\n\n      hook.__cleanup__();\n\n      delete this.viewHooks[ViewHook.elementID(hook.el)];\n    }\n\n    applyPendingUpdates() {\n      this.pendingDiffs.forEach(({\n        diff,\n        events\n      }) => this.update(diff, events));\n      this.pendingDiffs = [];\n    }\n\n    onChannel(event, cb) {\n      this.liveSocket.onChannel(this.channel, event, resp => {\n        if (this.isJoinPending()) {\n          this.root.pendingJoinOps.push([this, () => cb(resp)]);\n        } else {\n          cb(resp);\n        }\n      });\n    }\n\n    bindChannel() {\n      this.liveSocket.onChannel(this.channel, \"diff\", rawDiff => {\n        this.applyDiff(\"update\", rawDiff, ({\n          diff,\n          events\n        }) => this.update(diff, events));\n      });\n      this.onChannel(\"redirect\", ({\n        to,\n        flash\n      }) => this.onRedirect({\n        to,\n        flash\n      }));\n      this.onChannel(\"live_patch\", redir => this.onLivePatch(redir));\n      this.onChannel(\"live_redirect\", redir => this.onLiveRedirect(redir));\n      this.channel.onError(reason => this.onError(reason));\n      this.channel.onClose(reason => this.onClose(reason));\n    }\n\n    destroyAllChildren() {\n      for (let id in this.root.children[this.id]) {\n        this.getChildById(id).destroy();\n      }\n    }\n\n    onLiveRedirect(redir) {\n      let {\n        to,\n        kind,\n        flash\n      } = redir;\n      let url = this.expandURL(to);\n      this.liveSocket.historyRedirect(url, kind, flash);\n    }\n\n    onLivePatch(redir) {\n      let {\n        to,\n        kind\n      } = redir;\n      this.href = this.expandURL(to);\n      this.liveSocket.historyPatch(to, kind);\n    }\n\n    expandURL(to) {\n      return to.startsWith(\"/\") ? `${window.location.protocol}//${window.location.host}${to}` : to;\n    }\n\n    onRedirect({\n      to,\n      flash\n    }) {\n      this.liveSocket.redirect(to, flash);\n    }\n\n    isDestroyed() {\n      return this.destroyed;\n    }\n\n    join(callback) {\n      if (!this.parent) {\n        this.stopCallback = this.liveSocket.withPageLoading({\n          to: this.href,\n          kind: \"initial\"\n        });\n      }\n\n      this.joinCallback = () => callback && callback(this.joinCount);\n\n      this.liveSocket.wrapPush(this, {\n        timeout: false\n      }, () => {\n        return this.channel.join().receive(\"ok\", data => !this.isDestroyed() && this.onJoin(data)).receive(\"error\", resp => !this.isDestroyed() && this.onJoinError(resp)).receive(\"timeout\", () => !this.isDestroyed() && this.onJoinError({\n          reason: \"timeout\"\n        }));\n      });\n    }\n\n    onJoinError(resp) {\n      if (resp.reason === \"unauthorized\" || resp.reason === \"stale\") {\n        this.log(\"error\", () => [\"unauthorized live_redirect. Falling back to page request\", resp]);\n        return this.onRedirect({\n          to: this.href\n        });\n      }\n\n      if (resp.redirect || resp.live_redirect) {\n        this.joinPending = false;\n        this.channel.leave();\n      }\n\n      if (resp.redirect) {\n        return this.onRedirect(resp.redirect);\n      }\n\n      if (resp.live_redirect) {\n        return this.onLiveRedirect(resp.live_redirect);\n      }\n\n      this.log(\"error\", () => [\"unable to join\", resp]);\n      return this.liveSocket.reloadWithJitter(this);\n    }\n\n    onClose(reason) {\n      if (this.isDestroyed()) {\n        return;\n      }\n\n      if (this.isJoinPending() && document.visibilityState !== \"hidden\" || this.liveSocket.hasPendingLink() && reason !== \"leave\") {\n        return this.liveSocket.reloadWithJitter(this);\n      }\n\n      this.destroyAllChildren();\n      this.liveSocket.dropActiveElement(this);\n\n      if (document.activeElement) {\n        document.activeElement.blur();\n      }\n\n      if (this.liveSocket.isUnloaded()) {\n        this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);\n      }\n    }\n\n    onError(reason) {\n      this.onClose(reason);\n      this.log(\"error\", () => [\"view crashed\", reason]);\n\n      if (!this.liveSocket.isUnloaded()) {\n        this.displayError();\n      }\n    }\n\n    displayError() {\n      if (this.isMain()) {\n        dom_default.dispatchEvent(window, \"phx:page-loading-start\", {\n          to: this.href,\n          kind: \"error\"\n        });\n      }\n\n      this.showLoader();\n      this.setContainerClasses(PHX_DISCONNECTED_CLASS, PHX_ERROR_CLASS);\n    }\n\n    pushWithReply(refGenerator, event, payload, onReply = function () {}) {\n      if (!this.isConnected()) {\n        return;\n      }\n\n      let [ref, [el]] = refGenerator ? refGenerator() : [null, []];\n\n      let onLoadingDone = function () {};\n\n      if (el && el.getAttribute(this.binding(PHX_PAGE_LOADING)) !== null) {\n        onLoadingDone = this.liveSocket.withPageLoading({\n          kind: \"element\",\n          target: el\n        });\n      }\n\n      if (typeof payload.cid !== \"number\") {\n        delete payload.cid;\n      }\n\n      return this.liveSocket.wrapPush(this, {\n        timeout: true\n      }, () => {\n        return this.channel.push(event, payload, PUSH_TIMEOUT).receive(\"ok\", resp => {\n          let hookReply = null;\n\n          if (ref !== null) {\n            this.undoRefs(ref);\n          }\n\n          if (resp.diff) {\n            hookReply = this.applyDiff(\"update\", resp.diff, ({\n              diff,\n              events\n            }) => {\n              this.update(diff, events);\n            });\n          }\n\n          if (resp.redirect) {\n            this.onRedirect(resp.redirect);\n          }\n\n          if (resp.live_patch) {\n            this.onLivePatch(resp.live_patch);\n          }\n\n          if (resp.live_redirect) {\n            this.onLiveRedirect(resp.live_redirect);\n          }\n\n          onLoadingDone();\n          onReply(resp, hookReply);\n        });\n      });\n    }\n\n    undoRefs(ref) {\n      dom_default.all(this.el, `[${PHX_REF}=\"${ref}\"]`, el => {\n        let disabledVal = el.getAttribute(PHX_DISABLED);\n        el.removeAttribute(PHX_REF);\n\n        if (el.getAttribute(PHX_READONLY) !== null) {\n          el.readOnly = false;\n          el.removeAttribute(PHX_READONLY);\n        }\n\n        if (disabledVal !== null) {\n          el.disabled = disabledVal === \"true\" ? true : false;\n          el.removeAttribute(PHX_DISABLED);\n        }\n\n        PHX_EVENT_CLASSES.forEach(className => dom_default.removeClass(el, className));\n        let disableRestore = el.getAttribute(PHX_DISABLE_WITH_RESTORE);\n\n        if (disableRestore !== null) {\n          el.innerText = disableRestore;\n          el.removeAttribute(PHX_DISABLE_WITH_RESTORE);\n        }\n\n        let toEl = dom_default.private(el, PHX_REF);\n\n        if (toEl) {\n          let hook = this.triggerBeforeUpdateHook(el, toEl);\n          DOMPatch.patchEl(el, toEl, this.liveSocket.getActiveElement());\n\n          if (hook) {\n            hook.__updated();\n          }\n\n          dom_default.deletePrivate(el, PHX_REF);\n        }\n      });\n    }\n\n    putRef(elements, event) {\n      let newRef = this.ref++;\n      let disableWith = this.binding(PHX_DISABLE_WITH);\n      elements.forEach(el => {\n        el.classList.add(`phx-${event}-loading`);\n        el.setAttribute(PHX_REF, newRef);\n        let disableText = el.getAttribute(disableWith);\n\n        if (disableText !== null) {\n          if (!el.getAttribute(PHX_DISABLE_WITH_RESTORE)) {\n            el.setAttribute(PHX_DISABLE_WITH_RESTORE, el.innerText);\n          }\n\n          el.innerText = disableText;\n        }\n      });\n      return [newRef, elements];\n    }\n\n    componentID(el) {\n      let cid = el.getAttribute && el.getAttribute(PHX_COMPONENT);\n      return cid ? parseInt(cid) : null;\n    }\n\n    targetComponentID(target, targetCtx) {\n      if (target.getAttribute(this.binding(\"target\"))) {\n        return this.closestComponentID(targetCtx);\n      } else {\n        return null;\n      }\n    }\n\n    closestComponentID(targetCtx) {\n      if (targetCtx) {\n        return maybe(targetCtx.closest(`[${PHX_COMPONENT}]`), el => this.ownsElement(el) && this.componentID(el));\n      } else {\n        return null;\n      }\n    }\n\n    pushHookEvent(targetCtx, event, payload, onReply) {\n      if (!this.isConnected()) {\n        this.log(\"hook\", () => [\"unable to push hook event. LiveView not connected\", event, payload]);\n        return false;\n      }\n\n      let [ref, els] = this.putRef([], \"hook\");\n      this.pushWithReply(() => [ref, els], \"event\", {\n        type: \"hook\",\n        event,\n        value: payload,\n        cid: this.closestComponentID(targetCtx)\n      }, (resp, reply) => onReply(reply, ref));\n      return ref;\n    }\n\n    extractMeta(el, meta) {\n      let prefix = this.binding(\"value-\");\n\n      for (let i = 0; i < el.attributes.length; i++) {\n        let name = el.attributes[i].name;\n\n        if (name.startsWith(prefix)) {\n          meta[name.replace(prefix, \"\")] = el.getAttribute(name);\n        }\n      }\n\n      if (el.value !== void 0) {\n        meta.value = el.value;\n\n        if (el.tagName === \"INPUT\" && CHECKABLE_INPUTS.indexOf(el.type) >= 0 && !el.checked) {\n          delete meta.value;\n        }\n      }\n\n      return meta;\n    }\n\n    pushEvent(type, el, targetCtx, phxEvent, meta) {\n      this.pushWithReply(() => this.putRef([el], type), \"event\", {\n        type,\n        event: phxEvent,\n        value: this.extractMeta(el, meta),\n        cid: this.targetComponentID(el, targetCtx)\n      });\n    }\n\n    pushKey(keyElement, targetCtx, kind, phxEvent, meta) {\n      this.pushWithReply(() => this.putRef([keyElement], kind), \"event\", {\n        type: kind,\n        event: phxEvent,\n        value: this.extractMeta(keyElement, meta),\n        cid: this.targetComponentID(keyElement, targetCtx)\n      });\n    }\n\n    pushFileProgress(fileEl, entryRef, progress, onReply = function () {}) {\n      this.liveSocket.withinOwners(fileEl.form, (view, targetCtx) => {\n        view.pushWithReply(null, \"progress\", {\n          event: fileEl.getAttribute(view.binding(PHX_PROGRESS)),\n          ref: fileEl.getAttribute(PHX_UPLOAD_REF),\n          entry_ref: entryRef,\n          progress,\n          cid: view.targetComponentID(fileEl.form, targetCtx)\n        }, onReply);\n      });\n    }\n\n    pushInput(inputEl, targetCtx, forceCid, phxEvent, eventTarget, callback) {\n      let uploads;\n      let cid = isCid(forceCid) ? forceCid : this.targetComponentID(inputEl.form, targetCtx);\n\n      let refGenerator = () => this.putRef([inputEl, inputEl.form], \"change\");\n\n      let formData = serializeForm(inputEl.form, {\n        _target: eventTarget.name\n      });\n\n      if (inputEl.files && inputEl.files.length > 0) {\n        LiveUploader.trackFiles(inputEl, Array.from(inputEl.files));\n      }\n\n      uploads = LiveUploader.serializeUploads(inputEl);\n      let event = {\n        type: \"form\",\n        event: phxEvent,\n        value: formData,\n        uploads,\n        cid\n      };\n      this.pushWithReply(refGenerator, \"event\", event, resp => {\n        dom_default.showError(inputEl, this.liveSocket.binding(PHX_FEEDBACK_FOR));\n\n        if (dom_default.isUploadInput(inputEl) && inputEl.getAttribute(\"data-phx-auto-upload\") !== null) {\n          if (LiveUploader.filesAwaitingPreflight(inputEl).length > 0) {\n            let [ref, _els] = refGenerator();\n            this.uploadFiles(inputEl.form, targetCtx, ref, cid, _uploads => {\n              callback && callback(resp);\n              this.triggerAwaitingSubmit(inputEl.form);\n            });\n          }\n        } else {\n          callback && callback(resp);\n        }\n      });\n    }\n\n    triggerAwaitingSubmit(formEl) {\n      let awaitingSubmit = this.getScheduledSubmit(formEl);\n\n      if (awaitingSubmit) {\n        let [_el, _ref, callback] = awaitingSubmit;\n        this.cancelSubmit(formEl);\n        callback();\n      }\n    }\n\n    getScheduledSubmit(formEl) {\n      return this.formSubmits.find(([el, _callback]) => el.isSameNode(formEl));\n    }\n\n    scheduleSubmit(formEl, ref, callback) {\n      if (this.getScheduledSubmit(formEl)) {\n        return true;\n      }\n\n      this.formSubmits.push([formEl, ref, callback]);\n    }\n\n    cancelSubmit(formEl) {\n      this.formSubmits = this.formSubmits.filter(([el, ref, _callback]) => {\n        if (el.isSameNode(formEl)) {\n          this.undoRefs(ref);\n          return false;\n        } else {\n          return true;\n        }\n      });\n    }\n\n    pushFormSubmit(formEl, targetCtx, phxEvent, onReply) {\n      let filterIgnored = el => {\n        let userIgnored = closestPhxBinding(el, `${this.binding(PHX_UPDATE)}=ignore`, el.form);\n        return !(userIgnored || closestPhxBinding(el, \"data-phx-update=ignore\", el.form));\n      };\n\n      let filterDisables = el => {\n        return el.hasAttribute(this.binding(PHX_DISABLE_WITH));\n      };\n\n      let filterButton = el => el.tagName == \"BUTTON\";\n\n      let filterInput = el => [\"INPUT\", \"TEXTAREA\", \"SELECT\"].includes(el.tagName);\n\n      let refGenerator = () => {\n        let formElements = Array.from(formEl.elements);\n        let disables = formElements.filter(filterDisables);\n        let buttons = formElements.filter(filterButton).filter(filterIgnored);\n        let inputs = formElements.filter(filterInput).filter(filterIgnored);\n        buttons.forEach(button => {\n          button.setAttribute(PHX_DISABLED, button.disabled);\n          button.disabled = true;\n        });\n        inputs.forEach(input => {\n          input.setAttribute(PHX_READONLY, input.readOnly);\n          input.readOnly = true;\n\n          if (input.files) {\n            input.setAttribute(PHX_DISABLED, input.disabled);\n            input.disabled = true;\n          }\n        });\n        formEl.setAttribute(this.binding(PHX_PAGE_LOADING), \"\");\n        return this.putRef([formEl].concat(disables).concat(buttons).concat(inputs), \"submit\");\n      };\n\n      let cid = this.targetComponentID(formEl, targetCtx);\n\n      if (LiveUploader.hasUploadsInProgress(formEl)) {\n        let [ref, _els] = refGenerator();\n        return this.scheduleSubmit(formEl, ref, () => this.pushFormSubmit(formEl, targetCtx, phxEvent, onReply));\n      } else if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {\n        let [ref, els] = refGenerator();\n\n        let proxyRefGen = () => [ref, els];\n\n        this.uploadFiles(formEl, targetCtx, ref, cid, _uploads => {\n          let formData = serializeForm(formEl, {});\n          this.pushWithReply(proxyRefGen, \"event\", {\n            type: \"form\",\n            event: phxEvent,\n            value: formData,\n            cid\n          }, onReply);\n        });\n      } else {\n        let formData = serializeForm(formEl);\n        this.pushWithReply(refGenerator, \"event\", {\n          type: \"form\",\n          event: phxEvent,\n          value: formData,\n          cid\n        }, onReply);\n      }\n    }\n\n    uploadFiles(formEl, targetCtx, ref, cid, onComplete) {\n      let joinCountAtUpload = this.joinCount;\n      let inputEls = LiveUploader.activeFileInputs(formEl);\n      let numFileInputsInProgress = inputEls.length;\n      inputEls.forEach(inputEl => {\n        let uploader = new LiveUploader(inputEl, this, () => {\n          numFileInputsInProgress--;\n\n          if (numFileInputsInProgress === 0) {\n            onComplete();\n          }\n        });\n        this.uploaders[inputEl] = uploader;\n        let entries = uploader.entries().map(entry => entry.toPreflightPayload());\n        let payload = {\n          ref: inputEl.getAttribute(PHX_UPLOAD_REF),\n          entries,\n          cid: this.targetComponentID(inputEl.form, targetCtx)\n        };\n        this.log(\"upload\", () => [\"sending preflight request\", payload]);\n        this.pushWithReply(null, \"allow_upload\", payload, resp => {\n          this.log(\"upload\", () => [\"got preflight response\", resp]);\n\n          if (resp.error) {\n            this.undoRefs(ref);\n            let [entry_ref, reason] = resp.error;\n            this.log(\"upload\", () => [`error for entry ${entry_ref}`, reason]);\n          } else {\n            let onError = callback => {\n              this.channel.onError(() => {\n                if (this.joinCount === joinCountAtUpload) {\n                  callback();\n                }\n              });\n            };\n\n            uploader.initAdapterUpload(resp, onError, this.liveSocket);\n          }\n        });\n      });\n    }\n\n    dispatchUploads(name, filesOrBlobs) {\n      let inputs = dom_default.findUploadInputs(this.el).filter(el => el.name === name);\n\n      if (inputs.length === 0) {\n        logError(`no live file inputs found matching the name \"${name}\"`);\n      } else if (inputs.length > 1) {\n        logError(`duplicate live file inputs found matching the name \"${name}\"`);\n      } else {\n        dom_default.dispatchEvent(inputs[0], PHX_TRACK_UPLOADS, {\n          files: filesOrBlobs\n        });\n      }\n    }\n\n    pushFormRecovery(form, newCid, callback) {\n      this.liveSocket.withinOwners(form, (view, targetCtx) => {\n        let input = form.elements[0];\n        let phxEvent = form.getAttribute(this.binding(PHX_AUTO_RECOVER)) || form.getAttribute(this.binding(\"change\"));\n        view.pushInput(input, targetCtx, newCid, phxEvent, input, callback);\n      });\n    }\n\n    pushLinkPatch(href, targetEl, callback) {\n      let linkRef = this.liveSocket.setPendingLink(href);\n      let refGen = targetEl ? () => this.putRef([targetEl], \"click\") : null;\n      this.pushWithReply(refGen, \"live_patch\", {\n        url: href\n      }, resp => {\n        if (resp.link_redirect) {\n          this.liveSocket.replaceMain(href, null, callback, linkRef);\n        } else {\n          if (this.liveSocket.commitPendingLink(linkRef)) {\n            this.href = href;\n          }\n\n          this.applyPendingUpdates();\n          callback && callback(linkRef);\n        }\n      }).receive(\"timeout\", () => this.liveSocket.redirect(window.location.href));\n    }\n\n    formsForRecovery(html) {\n      if (this.joinCount === 0) {\n        return [];\n      }\n\n      let phxChange = this.binding(\"change\");\n      let template = document.createElement(\"template\");\n      template.innerHTML = html;\n      return dom_default.all(this.el, `form[${phxChange}]`).filter(form => form.id && this.ownsElement(form)).filter(form => form.elements.length > 0).filter(form => form.getAttribute(this.binding(PHX_AUTO_RECOVER)) !== \"ignore\").map(form => {\n        let newForm = template.content.querySelector(`form[id=\"${form.id}\"][${phxChange}=\"${form.getAttribute(phxChange)}\"]`);\n\n        if (newForm) {\n          return [form, newForm, this.componentID(newForm)];\n        } else {\n          return [form, null, null];\n        }\n      }).filter(([form, newForm, newCid]) => newForm);\n    }\n\n    maybePushComponentsDestroyed(destroyedCIDs) {\n      let willDestroyCIDs = destroyedCIDs.filter(cid => {\n        return dom_default.findComponentNodeList(this.el, cid).length === 0;\n      });\n\n      if (willDestroyCIDs.length > 0) {\n        this.pruningCIDs.push(...willDestroyCIDs);\n        this.pushWithReply(null, \"cids_will_destroy\", {\n          cids: willDestroyCIDs\n        }, () => {\n          this.pruningCIDs = this.pruningCIDs.filter(cid => willDestroyCIDs.indexOf(cid) !== -1);\n          let completelyDestroyCIDs = willDestroyCIDs.filter(cid => {\n            return dom_default.findComponentNodeList(this.el, cid).length === 0;\n          });\n\n          if (completelyDestroyCIDs.length > 0) {\n            this.pushWithReply(null, \"cids_destroyed\", {\n              cids: completelyDestroyCIDs\n            }, resp => {\n              this.rendered.pruneCIDs(resp.cids);\n            });\n          }\n        });\n      }\n    }\n\n    ownsElement(el) {\n      return el.getAttribute(PHX_PARENT_ID) === this.id || maybe(el.closest(PHX_VIEW_SELECTOR), node => node.id) === this.id;\n    }\n\n    submitForm(form, targetCtx, phxEvent) {\n      dom_default.putPrivate(form, PHX_HAS_SUBMITTED, true);\n      this.liveSocket.blurActiveElement(this);\n      this.pushFormSubmit(form, targetCtx, phxEvent, () => {\n        this.liveSocket.restorePreviouslyActiveFocus();\n      });\n    }\n\n    binding(kind) {\n      return this.liveSocket.binding(kind);\n    }\n\n  }; // js/phoenix_live_view/live_socket.js\n\n  var LiveSocket = class {\n    constructor(url, phxSocket, opts = {}) {\n      this.unloaded = false;\n\n      if (!phxSocket || phxSocket.constructor.name === \"Object\") {\n        throw new Error(`\n      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:\n\n          import {Socket} from \"phoenix\"\n          import LiveSocket from \"phoenix_live_view\"\n          let liveSocket = new LiveSocket(\"/live\", Socket, {...})\n      `);\n      }\n\n      this.socket = new phxSocket(url, opts);\n      this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;\n      this.opts = opts;\n      this.params = closure(opts.params || {});\n      this.viewLogger = opts.viewLogger;\n      this.metadataCallbacks = opts.metadata || {};\n      this.defaults = Object.assign(clone(DEFAULTS), opts.defaults || {});\n      this.activeElement = null;\n      this.prevActive = null;\n      this.silenced = false;\n      this.main = null;\n      this.linkRef = 1;\n      this.roots = {};\n      this.href = window.location.href;\n      this.pendingLink = null;\n      this.currentLocation = clone(window.location);\n      this.hooks = opts.hooks || {};\n      this.uploaders = opts.uploaders || {};\n      this.loaderTimeout = opts.loaderTimeout || LOADER_TIMEOUT;\n      this.localStorage = opts.localStorage || window.localStorage;\n      this.sessionStorage = opts.sessionStorage || window.sessionStorage;\n      this.boundTopLevelEvents = false;\n      this.domCallbacks = Object.assign({\n        onNodeAdded: closure(),\n        onBeforeElUpdated: closure()\n      }, opts.dom || {});\n      window.addEventListener(\"pagehide\", _e => {\n        this.unloaded = true;\n      });\n      this.socket.onOpen(() => {\n        if (this.isUnloaded()) {\n          window.location.reload();\n        }\n      });\n    }\n\n    isProfileEnabled() {\n      return this.sessionStorage.getItem(PHX_LV_PROFILE) === \"true\";\n    }\n\n    isDebugEnabled() {\n      return this.sessionStorage.getItem(PHX_LV_DEBUG) === \"true\";\n    }\n\n    enableDebug() {\n      this.sessionStorage.setItem(PHX_LV_DEBUG, \"true\");\n    }\n\n    enableProfiling() {\n      this.sessionStorage.setItem(PHX_LV_PROFILE, \"true\");\n    }\n\n    disableDebug() {\n      this.sessionStorage.removeItem(PHX_LV_DEBUG);\n    }\n\n    disableProfiling() {\n      this.sessionStorage.removeItem(PHX_LV_PROFILE);\n    }\n\n    enableLatencySim(upperBoundMs) {\n      this.enableDebug();\n      console.log(\"latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable\");\n      this.sessionStorage.setItem(PHX_LV_LATENCY_SIM, upperBoundMs);\n    }\n\n    disableLatencySim() {\n      this.sessionStorage.removeItem(PHX_LV_LATENCY_SIM);\n    }\n\n    getLatencySim() {\n      let str = this.sessionStorage.getItem(PHX_LV_LATENCY_SIM);\n      return str ? parseInt(str) : null;\n    }\n\n    getSocket() {\n      return this.socket;\n    }\n\n    connect() {\n      let doConnect = () => {\n        if (this.joinRootViews()) {\n          this.bindTopLevelEvents();\n          this.socket.connect();\n        }\n      };\n\n      if ([\"complete\", \"loaded\", \"interactive\"].indexOf(document.readyState) >= 0) {\n        doConnect();\n      } else {\n        document.addEventListener(\"DOMContentLoaded\", () => doConnect());\n      }\n    }\n\n    disconnect(callback) {\n      this.socket.disconnect(callback);\n    }\n\n    triggerDOM(kind, args) {\n      this.domCallbacks[kind](...args);\n    }\n\n    time(name, func) {\n      if (!this.isProfileEnabled() || !console.time) {\n        return func();\n      }\n\n      console.time(name);\n      let result = func();\n      console.timeEnd(name);\n      return result;\n    }\n\n    log(view, kind, msgCallback) {\n      if (this.viewLogger) {\n        let [msg, obj] = msgCallback();\n        this.viewLogger(view, kind, msg, obj);\n      } else if (this.isDebugEnabled()) {\n        let [msg, obj] = msgCallback();\n        debug(view, kind, msg, obj);\n      }\n    }\n\n    onChannel(channel, event, cb) {\n      channel.on(event, data => {\n        let latency = this.getLatencySim();\n\n        if (!latency) {\n          cb(data);\n        } else {\n          console.log(`simulating ${latency}ms of latency from server to client`);\n          setTimeout(() => cb(data), latency);\n        }\n      });\n    }\n\n    wrapPush(view, opts, push) {\n      let latency = this.getLatencySim();\n      let oldJoinCount = view.joinCount;\n\n      if (!latency) {\n        if (opts.timeout) {\n          return push().receive(\"timeout\", () => {\n            if (view.joinCount === oldJoinCount && !view.isDestroyed()) {\n              this.reloadWithJitter(view, () => {\n                this.log(view, \"timeout\", () => [\"received timeout while communicating with server. Falling back to hard refresh for recovery\"]);\n              });\n            }\n          });\n        } else {\n          return push();\n        }\n      }\n\n      console.log(`simulating ${latency}ms of latency from client to server`);\n      let fakePush = {\n        receives: [],\n\n        receive(kind, cb) {\n          this.receives.push([kind, cb]);\n        }\n\n      };\n      setTimeout(() => {\n        if (view.isDestroyed()) {\n          return;\n        }\n\n        fakePush.receives.reduce((acc, [kind, cb]) => acc.receive(kind, cb), push());\n      }, latency);\n      return fakePush;\n    }\n\n    reloadWithJitter(view, log) {\n      view.destroy();\n      this.disconnect();\n      let [minMs, maxMs] = RELOAD_JITTER;\n      let afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;\n      let tries = browser_default.updateLocal(this.localStorage, window.location.pathname, CONSECUTIVE_RELOADS, 0, count => count + 1);\n      log ? log() : this.log(view, \"join\", () => [`encountered ${tries} consecutive reloads`]);\n\n      if (tries > MAX_RELOADS) {\n        this.log(view, \"join\", () => [`exceeded ${MAX_RELOADS} consecutive reloads. Entering failsafe mode`]);\n        afterMs = FAILSAFE_JITTER;\n      }\n\n      setTimeout(() => {\n        if (this.hasPendingLink()) {\n          window.location = this.pendingLink;\n        } else {\n          window.location.reload();\n        }\n      }, afterMs);\n    }\n\n    getHookCallbacks(name) {\n      return name && name.startsWith(\"Phoenix.\") ? hooks_default[name.split(\".\")[1]] : this.hooks[name];\n    }\n\n    isUnloaded() {\n      return this.unloaded;\n    }\n\n    isConnected() {\n      return this.socket.isConnected();\n    }\n\n    getBindingPrefix() {\n      return this.bindingPrefix;\n    }\n\n    binding(kind) {\n      return `${this.getBindingPrefix()}${kind}`;\n    }\n\n    channel(topic, params) {\n      return this.socket.channel(topic, params);\n    }\n\n    joinRootViews() {\n      let rootsFound = false;\n      dom_default.all(document, `${PHX_VIEW_SELECTOR}:not([${PHX_PARENT_ID}])`, rootEl => {\n        if (!this.getRootById(rootEl.id)) {\n          let view = this.newRootView(rootEl);\n          view.setHref(this.getHref());\n          view.join();\n\n          if (rootEl.getAttribute(PHX_MAIN)) {\n            this.main = view;\n          }\n        }\n\n        rootsFound = true;\n      });\n      return rootsFound;\n    }\n\n    redirect(to, flash) {\n      this.disconnect();\n      browser_default.redirect(to, flash);\n    }\n\n    replaceMain(href, flash, callback = null, linkRef = this.setPendingLink(href)) {\n      let oldMainEl = this.main.el;\n      let newMainEl = dom_default.cloneNode(oldMainEl, \"\");\n      this.main.showLoader(this.loaderTimeout);\n      this.main.destroy();\n      this.main = this.newRootView(newMainEl, flash);\n      this.main.setRedirect(href);\n      this.main.join(joinCount => {\n        if (joinCount === 1 && this.commitPendingLink(linkRef)) {\n          oldMainEl.replaceWith(newMainEl);\n          callback && callback();\n        }\n      });\n    }\n\n    isPhxView(el) {\n      return el.getAttribute && el.getAttribute(PHX_SESSION) !== null;\n    }\n\n    newRootView(el, flash) {\n      let view = new View(el, this, null, flash);\n      this.roots[view.id] = view;\n      return view;\n    }\n\n    owner(childEl, callback) {\n      let view = maybe(childEl.closest(PHX_VIEW_SELECTOR), el => this.getViewByEl(el));\n\n      if (view) {\n        callback(view);\n      }\n    }\n\n    withinOwners(childEl, callback) {\n      this.owner(childEl, view => {\n        let phxTarget = childEl.getAttribute(this.binding(\"target\"));\n\n        if (phxTarget === null) {\n          callback(view, childEl);\n        } else {\n          view.withinTargets(phxTarget, callback);\n        }\n      });\n    }\n\n    getViewByEl(el) {\n      let rootId = el.getAttribute(PHX_ROOT_ID);\n      return maybe(this.getRootById(rootId), root => root.getDescendentByEl(el));\n    }\n\n    getRootById(id) {\n      return this.roots[id];\n    }\n\n    destroyAllViews() {\n      for (let id in this.roots) {\n        this.roots[id].destroy();\n        delete this.roots[id];\n      }\n    }\n\n    destroyViewByEl(el) {\n      let root = this.getRootById(el.getAttribute(PHX_ROOT_ID));\n\n      if (root) {\n        root.destroyDescendent(el.id);\n      }\n    }\n\n    setActiveElement(target) {\n      if (this.activeElement === target) {\n        return;\n      }\n\n      this.activeElement = target;\n\n      let cancel = () => {\n        if (target === this.activeElement) {\n          this.activeElement = null;\n        }\n\n        target.removeEventListener(\"mouseup\", this);\n        target.removeEventListener(\"touchend\", this);\n      };\n\n      target.addEventListener(\"mouseup\", cancel);\n      target.addEventListener(\"touchend\", cancel);\n    }\n\n    getActiveElement() {\n      if (document.activeElement === document.body) {\n        return this.activeElement || document.activeElement;\n      } else {\n        return document.activeElement || document.body;\n      }\n    }\n\n    dropActiveElement(view) {\n      if (this.prevActive && view.ownsElement(this.prevActive)) {\n        this.prevActive = null;\n      }\n    }\n\n    restorePreviouslyActiveFocus() {\n      if (this.prevActive && this.prevActive !== document.body) {\n        this.prevActive.focus();\n      }\n    }\n\n    blurActiveElement() {\n      this.prevActive = this.getActiveElement();\n\n      if (this.prevActive !== document.body) {\n        this.prevActive.blur();\n      }\n    }\n\n    bindTopLevelEvents() {\n      if (this.boundTopLevelEvents) {\n        return;\n      }\n\n      this.boundTopLevelEvents = true;\n      document.body.addEventListener(\"click\", function () {});\n      window.addEventListener(\"pageshow\", e => {\n        if (e.persisted) {\n          this.getSocket().disconnect();\n          this.withPageLoading({\n            to: window.location.href,\n            kind: \"redirect\"\n          });\n          window.location.reload();\n        }\n      }, true);\n      this.bindNav();\n      this.bindClicks();\n      this.bindForms();\n      this.bind({\n        keyup: \"keyup\",\n        keydown: \"keydown\"\n      }, (e, type, view, target, targetCtx, phxEvent, _phxTarget) => {\n        let matchKey = target.getAttribute(this.binding(PHX_KEY));\n        let pressedKey = e.key && e.key.toLowerCase();\n\n        if (matchKey && matchKey.toLowerCase() !== pressedKey) {\n          return;\n        }\n\n        view.pushKey(target, targetCtx, type, phxEvent, __spreadValues({\n          key: e.key\n        }, this.eventMeta(type, e, target)));\n      });\n      this.bind({\n        blur: \"focusout\",\n        focus: \"focusin\"\n      }, (e, type, view, targetEl, targetCtx, phxEvent, phxTarget) => {\n        if (!phxTarget) {\n          view.pushEvent(type, targetEl, targetCtx, phxEvent, this.eventMeta(type, e, targetEl));\n        }\n      });\n      this.bind({\n        blur: \"blur\",\n        focus: \"focus\"\n      }, (e, type, view, targetEl, targetCtx, phxEvent, phxTarget) => {\n        if (phxTarget && !phxTarget !== \"window\") {\n          view.pushEvent(type, targetEl, targetCtx, phxEvent, this.eventMeta(type, e, targetEl));\n        }\n      });\n      window.addEventListener(\"dragover\", e => e.preventDefault());\n      window.addEventListener(\"drop\", e => {\n        e.preventDefault();\n        let dropTargetId = maybe(closestPhxBinding(e.target, this.binding(PHX_DROP_TARGET)), trueTarget => {\n          return trueTarget.getAttribute(this.binding(PHX_DROP_TARGET));\n        });\n        let dropTarget = dropTargetId && document.getElementById(dropTargetId);\n        let files = Array.from(e.dataTransfer.files || []);\n\n        if (!dropTarget || dropTarget.disabled || files.length === 0 || !(dropTarget.files instanceof FileList)) {\n          return;\n        }\n\n        LiveUploader.trackFiles(dropTarget, files);\n        dropTarget.dispatchEvent(new Event(\"input\", {\n          bubbles: true\n        }));\n      });\n      this.on(PHX_TRACK_UPLOADS, e => {\n        let uploadTarget = e.target;\n\n        if (!dom_default.isUploadInput(uploadTarget)) {\n          return;\n        }\n\n        let files = Array.from(e.detail.files || []).filter(f => f instanceof File || f instanceof Blob);\n        LiveUploader.trackFiles(uploadTarget, files);\n        uploadTarget.dispatchEvent(new Event(\"input\", {\n          bubbles: true\n        }));\n      });\n    }\n\n    eventMeta(eventName, e, targetEl) {\n      let callback = this.metadataCallbacks[eventName];\n      return callback ? callback(e, targetEl) : {};\n    }\n\n    setPendingLink(href) {\n      this.linkRef++;\n      this.pendingLink = href;\n      return this.linkRef;\n    }\n\n    commitPendingLink(linkRef) {\n      if (this.linkRef !== linkRef) {\n        return false;\n      } else {\n        this.href = this.pendingLink;\n        this.pendingLink = null;\n        return true;\n      }\n    }\n\n    getHref() {\n      return this.href;\n    }\n\n    hasPendingLink() {\n      return !!this.pendingLink;\n    }\n\n    bind(events, callback) {\n      for (let event in events) {\n        let browserEventName = events[event];\n        this.on(browserEventName, e => {\n          let binding = this.binding(event);\n          let windowBinding = this.binding(`window-${event}`);\n          let targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding);\n\n          if (targetPhxEvent) {\n            this.debounce(e.target, e, () => {\n              this.withinOwners(e.target, (view, targetCtx) => {\n                callback(e, event, view, e.target, targetCtx, targetPhxEvent, null);\n              });\n            });\n          } else {\n            dom_default.all(document, `[${windowBinding}]`, el => {\n              let phxEvent = el.getAttribute(windowBinding);\n              this.debounce(el, e, () => {\n                this.withinOwners(el, (view, targetCtx) => {\n                  callback(e, event, view, el, targetCtx, phxEvent, \"window\");\n                });\n              });\n            });\n          }\n        });\n      }\n    }\n\n    bindClicks() {\n      this.bindClick(\"click\", \"click\", false);\n      this.bindClick(\"mousedown\", \"capture-click\", true);\n    }\n\n    bindClick(eventName, bindingName, capture) {\n      let click = this.binding(bindingName);\n      window.addEventListener(eventName, e => {\n        if (!this.isConnected()) {\n          return;\n        }\n\n        let target = null;\n\n        if (capture) {\n          target = e.target.matches(`[${click}]`) ? e.target : e.target.querySelector(`[${click}]`);\n        } else {\n          target = closestPhxBinding(e.target, click);\n        }\n\n        let phxEvent = target && target.getAttribute(click);\n\n        if (!phxEvent) {\n          return;\n        }\n\n        if (target.getAttribute(\"href\") === \"#\") {\n          e.preventDefault();\n        }\n\n        this.debounce(target, e, () => {\n          this.withinOwners(target, (view, targetCtx) => {\n            view.pushEvent(\"click\", target, targetCtx, phxEvent, this.eventMeta(\"click\", e, target));\n          });\n        });\n      }, capture);\n    }\n\n    bindNav() {\n      if (!browser_default.canPushState()) {\n        return;\n      }\n\n      if (history.scrollRestoration) {\n        history.scrollRestoration = \"manual\";\n      }\n\n      let scrollTimer = null;\n      window.addEventListener(\"scroll\", _e => {\n        clearTimeout(scrollTimer);\n        scrollTimer = setTimeout(() => {\n          browser_default.updateCurrentState(state => Object.assign(state, {\n            scroll: window.scrollY\n          }));\n        }, 100);\n      });\n      window.addEventListener(\"popstate\", event => {\n        if (!this.registerNewLocation(window.location)) {\n          return;\n        }\n\n        let {\n          type,\n          id,\n          root,\n          scroll\n        } = event.state || {};\n        let href = window.location.href;\n\n        if (this.main.isConnected() && type === \"patch\" && id === this.main.id) {\n          this.main.pushLinkPatch(href, null);\n        } else {\n          this.replaceMain(href, null, () => {\n            if (root) {\n              this.replaceRootHistory();\n            }\n\n            if (typeof scroll === \"number\") {\n              setTimeout(() => {\n                window.scrollTo(0, scroll);\n              }, 0);\n            }\n          });\n        }\n      }, false);\n      window.addEventListener(\"click\", e => {\n        let target = closestPhxBinding(e.target, PHX_LIVE_LINK);\n        let type = target && target.getAttribute(PHX_LIVE_LINK);\n        let wantsNewTab = e.metaKey || e.ctrlKey || e.button === 1;\n\n        if (!type || !this.isConnected() || !this.main || wantsNewTab) {\n          return;\n        }\n\n        let href = target.href;\n        let linkState = target.getAttribute(PHX_LINK_STATE);\n        e.preventDefault();\n\n        if (this.pendingLink === href) {\n          return;\n        }\n\n        if (type === \"patch\") {\n          this.pushHistoryPatch(href, linkState, target);\n        } else if (type === \"redirect\") {\n          this.historyRedirect(href, linkState);\n        } else {\n          throw new Error(`expected ${PHX_LIVE_LINK} to be \"patch\" or \"redirect\", got: ${type}`);\n        }\n      }, false);\n    }\n\n    withPageLoading(info, callback) {\n      dom_default.dispatchEvent(window, \"phx:page-loading-start\", info);\n\n      let done = () => dom_default.dispatchEvent(window, \"phx:page-loading-stop\", info);\n\n      return callback ? callback(done) : done;\n    }\n\n    pushHistoryPatch(href, linkState, targetEl) {\n      this.withPageLoading({\n        to: href,\n        kind: \"patch\"\n      }, done => {\n        this.main.pushLinkPatch(href, targetEl, linkRef => {\n          this.historyPatch(href, linkState, linkRef);\n          done();\n        });\n      });\n    }\n\n    historyPatch(href, linkState, linkRef = this.setPendingLink(href)) {\n      if (!this.commitPendingLink(linkRef)) {\n        return;\n      }\n\n      browser_default.pushState(linkState, {\n        type: \"patch\",\n        id: this.main.id\n      }, href);\n      this.registerNewLocation(window.location);\n    }\n\n    historyRedirect(href, linkState, flash) {\n      let scroll = window.scrollY;\n      this.withPageLoading({\n        to: href,\n        kind: \"redirect\"\n      }, done => {\n        this.replaceMain(href, flash, () => {\n          browser_default.pushState(linkState, {\n            type: \"redirect\",\n            id: this.main.id,\n            scroll\n          }, href);\n          this.registerNewLocation(window.location);\n          done();\n        });\n      });\n    }\n\n    replaceRootHistory() {\n      browser_default.pushState(\"replace\", {\n        root: true,\n        type: \"patch\",\n        id: this.main.id\n      });\n    }\n\n    registerNewLocation(newLocation) {\n      let {\n        pathname,\n        search\n      } = this.currentLocation;\n\n      if (pathname + search === newLocation.pathname + newLocation.search) {\n        return false;\n      } else {\n        this.currentLocation = clone(newLocation);\n        return true;\n      }\n    }\n\n    bindForms() {\n      let iterations = 0;\n      this.on(\"submit\", e => {\n        let phxEvent = e.target.getAttribute(this.binding(\"submit\"));\n\n        if (!phxEvent) {\n          return;\n        }\n\n        e.preventDefault();\n        e.target.disabled = true;\n        this.withinOwners(e.target, (view, targetCtx) => view.submitForm(e.target, targetCtx, phxEvent));\n      }, false);\n\n      for (let type of [\"change\", \"input\"]) {\n        this.on(type, e => {\n          let input = e.target;\n          let phxEvent = input.form && input.form.getAttribute(this.binding(\"change\"));\n\n          if (!phxEvent) {\n            return;\n          }\n\n          if (input.type === \"number\" && input.validity && input.validity.badInput) {\n            return;\n          }\n\n          let currentIterations = iterations;\n          iterations++;\n          let {\n            at,\n            type: lastType\n          } = dom_default.private(input, \"prev-iteration\") || {};\n\n          if (at === currentIterations - 1 && type !== lastType) {\n            return;\n          }\n\n          dom_default.putPrivate(input, \"prev-iteration\", {\n            at: currentIterations,\n            type\n          });\n          this.debounce(input, e, () => {\n            this.withinOwners(input.form, (view, targetCtx) => {\n              dom_default.putPrivate(input, PHX_HAS_FOCUSED, true);\n\n              if (!dom_default.isTextualInput(input)) {\n                this.setActiveElement(input);\n              }\n\n              view.pushInput(input, targetCtx, null, phxEvent, e.target);\n            });\n          });\n        }, false);\n      }\n    }\n\n    debounce(el, event, callback) {\n      let phxDebounce = this.binding(PHX_DEBOUNCE);\n      let phxThrottle = this.binding(PHX_THROTTLE);\n      let defaultDebounce = this.defaults.debounce.toString();\n      let defaultThrottle = this.defaults.throttle.toString();\n      dom_default.debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, callback);\n    }\n\n    silenceEvents(callback) {\n      this.silenced = true;\n      callback();\n      this.silenced = false;\n    }\n\n    on(event, callback) {\n      window.addEventListener(event, e => {\n        if (!this.silenced) {\n          callback(e);\n        }\n      });\n    }\n\n  };\n  return phoenix_live_view_exports;\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9wcml2L3N0YXRpYy9waG9lbml4X2xpdmVfdmlldy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L3ByaXYvc3RhdGljL3Bob2VuaXhfbGl2ZV92aWV3LmpzPzJjOTAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIExpdmVWaWV3ID0gKCgpID0+IHtcbiAgdmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgdmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuICB2YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbiAgdmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuICB2YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgdmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gICAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG4gIH07XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvaW5kZXguanNcbiAgdmFyIHBob2VuaXhfbGl2ZV92aWV3X2V4cG9ydHMgPSB7fTtcbiAgX19leHBvcnQocGhvZW5peF9saXZlX3ZpZXdfZXhwb3J0cywge1xuICAgIExpdmVTb2NrZXQ6ICgpID0+IExpdmVTb2NrZXRcbiAgfSk7XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvY29uc3RhbnRzLmpzXG4gIHZhciBDT05TRUNVVElWRV9SRUxPQURTID0gXCJjb25zZWN1dGl2ZS1yZWxvYWRzXCI7XG4gIHZhciBNQVhfUkVMT0FEUyA9IDEwO1xuICB2YXIgUkVMT0FEX0pJVFRFUiA9IFsxZTMsIDNlM107XG4gIHZhciBGQUlMU0FGRV9KSVRURVIgPSAzZTQ7XG4gIHZhciBQSFhfRVZFTlRfQ0xBU1NFUyA9IFtcbiAgICBcInBoeC1jbGljay1sb2FkaW5nXCIsXG4gICAgXCJwaHgtY2hhbmdlLWxvYWRpbmdcIixcbiAgICBcInBoeC1zdWJtaXQtbG9hZGluZ1wiLFxuICAgIFwicGh4LWtleWRvd24tbG9hZGluZ1wiLFxuICAgIFwicGh4LWtleXVwLWxvYWRpbmdcIixcbiAgICBcInBoeC1ibHVyLWxvYWRpbmdcIixcbiAgICBcInBoeC1mb2N1cy1sb2FkaW5nXCJcbiAgXTtcbiAgdmFyIFBIWF9DT01QT05FTlQgPSBcImRhdGEtcGh4LWNvbXBvbmVudFwiO1xuICB2YXIgUEhYX0xJVkVfTElOSyA9IFwiZGF0YS1waHgtbGlua1wiO1xuICB2YXIgUEhYX1RSQUNLX1NUQVRJQyA9IFwidHJhY2stc3RhdGljXCI7XG4gIHZhciBQSFhfTElOS19TVEFURSA9IFwiZGF0YS1waHgtbGluay1zdGF0ZVwiO1xuICB2YXIgUEhYX1JFRiA9IFwiZGF0YS1waHgtcmVmXCI7XG4gIHZhciBQSFhfVFJBQ0tfVVBMT0FEUyA9IFwidHJhY2stdXBsb2Fkc1wiO1xuICB2YXIgUEhYX1VQTE9BRF9SRUYgPSBcImRhdGEtcGh4LXVwbG9hZC1yZWZcIjtcbiAgdmFyIFBIWF9QUkVGTElHSFRFRF9SRUZTID0gXCJkYXRhLXBoeC1wcmVmbGlnaHRlZC1yZWZzXCI7XG4gIHZhciBQSFhfRE9ORV9SRUZTID0gXCJkYXRhLXBoeC1kb25lLXJlZnNcIjtcbiAgdmFyIFBIWF9EUk9QX1RBUkdFVCA9IFwiZHJvcC10YXJnZXRcIjtcbiAgdmFyIFBIWF9BQ1RJVkVfRU5UUllfUkVGUyA9IFwiZGF0YS1waHgtYWN0aXZlLXJlZnNcIjtcbiAgdmFyIFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCA9IFwicGh4OmxpdmUtZmlsZTp1cGRhdGVkXCI7XG4gIHZhciBQSFhfU0tJUCA9IFwiZGF0YS1waHgtc2tpcFwiO1xuICB2YXIgUEhYX1JFTU9WRSA9IFwiZGF0YS1waHgtcmVtb3ZlXCI7XG4gIHZhciBQSFhfUEFHRV9MT0FESU5HID0gXCJwYWdlLWxvYWRpbmdcIjtcbiAgdmFyIFBIWF9DT05ORUNURURfQ0xBU1MgPSBcInBoeC1jb25uZWN0ZWRcIjtcbiAgdmFyIFBIWF9ESVNDT05ORUNURURfQ0xBU1MgPSBcInBoeC1kaXNjb25uZWN0ZWRcIjtcbiAgdmFyIFBIWF9OT19GRUVEQkFDS19DTEFTUyA9IFwicGh4LW5vLWZlZWRiYWNrXCI7XG4gIHZhciBQSFhfRVJST1JfQ0xBU1MgPSBcInBoeC1lcnJvclwiO1xuICB2YXIgUEhYX1BBUkVOVF9JRCA9IFwiZGF0YS1waHgtcGFyZW50LWlkXCI7XG4gIHZhciBQSFhfTUFJTiA9IFwiZGF0YS1waHgtbWFpblwiO1xuICB2YXIgUEhYX1JPT1RfSUQgPSBcImRhdGEtcGh4LXJvb3QtaWRcIjtcbiAgdmFyIFBIWF9UUklHR0VSX0FDVElPTiA9IFwidHJpZ2dlci1hY3Rpb25cIjtcbiAgdmFyIFBIWF9GRUVEQkFDS19GT1IgPSBcImZlZWRiYWNrLWZvclwiO1xuICB2YXIgUEhYX0hBU19GT0NVU0VEID0gXCJwaHgtaGFzLWZvY3VzZWRcIjtcbiAgdmFyIEZPQ1VTQUJMRV9JTlBVVFMgPSBbXCJ0ZXh0XCIsIFwidGV4dGFyZWFcIiwgXCJudW1iZXJcIiwgXCJlbWFpbFwiLCBcInBhc3N3b3JkXCIsIFwic2VhcmNoXCIsIFwidGVsXCIsIFwidXJsXCIsIFwiZGF0ZVwiLCBcInRpbWVcIl07XG4gIHZhciBDSEVDS0FCTEVfSU5QVVRTID0gW1wiY2hlY2tib3hcIiwgXCJyYWRpb1wiXTtcbiAgdmFyIFBIWF9IQVNfU1VCTUlUVEVEID0gXCJwaHgtaGFzLXN1Ym1pdHRlZFwiO1xuICB2YXIgUEhYX1NFU1NJT04gPSBcImRhdGEtcGh4LXNlc3Npb25cIjtcbiAgdmFyIFBIWF9WSUVXX1NFTEVDVE9SID0gYFske1BIWF9TRVNTSU9OfV1gO1xuICB2YXIgUEhYX1NUQVRJQyA9IFwiZGF0YS1waHgtc3RhdGljXCI7XG4gIHZhciBQSFhfUkVBRE9OTFkgPSBcImRhdGEtcGh4LXJlYWRvbmx5XCI7XG4gIHZhciBQSFhfRElTQUJMRUQgPSBcImRhdGEtcGh4LWRpc2FibGVkXCI7XG4gIHZhciBQSFhfRElTQUJMRV9XSVRIID0gXCJkaXNhYmxlLXdpdGhcIjtcbiAgdmFyIFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSA9IFwiZGF0YS1waHgtZGlzYWJsZS13aXRoLXJlc3RvcmVcIjtcbiAgdmFyIFBIWF9IT09LID0gXCJob29rXCI7XG4gIHZhciBQSFhfREVCT1VOQ0UgPSBcImRlYm91bmNlXCI7XG4gIHZhciBQSFhfVEhST1RUTEUgPSBcInRocm90dGxlXCI7XG4gIHZhciBQSFhfVVBEQVRFID0gXCJ1cGRhdGVcIjtcbiAgdmFyIFBIWF9LRVkgPSBcImtleVwiO1xuICB2YXIgUEhYX1BSSVZBVEUgPSBcInBoeFByaXZhdGVcIjtcbiAgdmFyIFBIWF9BVVRPX1JFQ09WRVIgPSBcImF1dG8tcmVjb3ZlclwiO1xuICB2YXIgUEhYX0xWX0RFQlVHID0gXCJwaHg6bGl2ZS1zb2NrZXQ6ZGVidWdcIjtcbiAgdmFyIFBIWF9MVl9QUk9GSUxFID0gXCJwaHg6bGl2ZS1zb2NrZXQ6cHJvZmlsaW5nXCI7XG4gIHZhciBQSFhfTFZfTEFURU5DWV9TSU0gPSBcInBoeDpsaXZlLXNvY2tldDpsYXRlbmN5LXNpbVwiO1xuICB2YXIgUEhYX1BST0dSRVNTID0gXCJwcm9ncmVzc1wiO1xuICB2YXIgTE9BREVSX1RJTUVPVVQgPSAxO1xuICB2YXIgQkVGT1JFX1VOTE9BRF9MT0FERVJfVElNRU9VVCA9IDIwMDtcbiAgdmFyIEJJTkRJTkdfUFJFRklYID0gXCJwaHgtXCI7XG4gIHZhciBQVVNIX1RJTUVPVVQgPSAzZTQ7XG4gIHZhciBERUJPVU5DRV9UUklHR0VSID0gXCJkZWJvdW5jZS10cmlnZ2VyXCI7XG4gIHZhciBUSFJPVFRMRUQgPSBcInRocm90dGxlZFwiO1xuICB2YXIgREVCT1VOQ0VfUFJFVl9LRVkgPSBcImRlYm91bmNlLXByZXYta2V5XCI7XG4gIHZhciBERUZBVUxUUyA9IHtcbiAgICBkZWJvdW5jZTogMzAwLFxuICAgIHRocm90dGxlOiAzMDBcbiAgfTtcbiAgdmFyIERZTkFNSUNTID0gXCJkXCI7XG4gIHZhciBTVEFUSUMgPSBcInNcIjtcbiAgdmFyIENPTVBPTkVOVFMgPSBcImNcIjtcbiAgdmFyIEVWRU5UUyA9IFwiZVwiO1xuICB2YXIgUkVQTFkgPSBcInJcIjtcbiAgdmFyIFRJVExFID0gXCJ0XCI7XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvZW50cnlfdXBsb2FkZXIuanNcbiAgdmFyIEVudHJ5VXBsb2FkZXIgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoZW50cnksIGNodW5rU2l6ZSwgbGl2ZVNvY2tldCkge1xuICAgICAgdGhpcy5saXZlU29ja2V0ID0gbGl2ZVNvY2tldDtcbiAgICAgIHRoaXMuZW50cnkgPSBlbnRyeTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgIHRoaXMuY2h1bmtTaXplID0gY2h1bmtTaXplO1xuICAgICAgdGhpcy5jaHVua1RpbWVyID0gbnVsbDtcbiAgICAgIHRoaXMudXBsb2FkQ2hhbm5lbCA9IGxpdmVTb2NrZXQuY2hhbm5lbChgbHZ1OiR7ZW50cnkucmVmfWAsIHsgdG9rZW46IGVudHJ5Lm1ldGFkYXRhKCkgfSk7XG4gICAgfVxuICAgIGVycm9yKHJlYXNvbikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2h1bmtUaW1lcik7XG4gICAgICB0aGlzLnVwbG9hZENoYW5uZWwubGVhdmUoKTtcbiAgICAgIHRoaXMuZW50cnkuZXJyb3IocmVhc29uKTtcbiAgICB9XG4gICAgdXBsb2FkKCkge1xuICAgICAgdGhpcy51cGxvYWRDaGFubmVsLm9uRXJyb3IoKHJlYXNvbikgPT4gdGhpcy5lcnJvcihyZWFzb24pKTtcbiAgICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5qb2luKCkucmVjZWl2ZShcIm9rXCIsIChfZGF0YSkgPT4gdGhpcy5yZWFkTmV4dENodW5rKCkpLnJlY2VpdmUoXCJlcnJvclwiLCAocmVhc29uKSA9PiB0aGlzLmVycm9yKHJlYXNvbikpO1xuICAgIH1cbiAgICBpc0RvbmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vZmZzZXQgPj0gdGhpcy5lbnRyeS5maWxlLnNpemU7XG4gICAgfVxuICAgIHJlYWROZXh0Q2h1bmsoKSB7XG4gICAgICBsZXQgcmVhZGVyID0gbmV3IHdpbmRvdy5GaWxlUmVhZGVyKCk7XG4gICAgICBsZXQgYmxvYiA9IHRoaXMuZW50cnkuZmlsZS5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5jaHVua1NpemUgKyB0aGlzLm9mZnNldCk7XG4gICAgICByZWFkZXIub25sb2FkID0gKGUpID0+IHtcbiAgICAgICAgaWYgKGUudGFyZ2V0LmVycm9yID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5vZmZzZXQgKz0gZS50YXJnZXQucmVzdWx0LmJ5dGVMZW5ndGg7XG4gICAgICAgICAgdGhpcy5wdXNoQ2h1bmsoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbG9nRXJyb3IoXCJSZWFkIGVycm9yOiBcIiArIGUudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICB9XG4gICAgcHVzaENodW5rKGNodW5rKSB7XG4gICAgICBpZiAoIXRoaXMudXBsb2FkQ2hhbm5lbC5pc0pvaW5lZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5wdXNoKFwiY2h1bmtcIiwgY2h1bmspLnJlY2VpdmUoXCJva1wiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZW50cnkucHJvZ3Jlc3ModGhpcy5vZmZzZXQgLyB0aGlzLmVudHJ5LmZpbGUuc2l6ZSAqIDEwMCk7XG4gICAgICAgIGlmICghdGhpcy5pc0RvbmUoKSkge1xuICAgICAgICAgIHRoaXMuY2h1bmtUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5yZWFkTmV4dENodW5rKCksIHRoaXMubGl2ZVNvY2tldC5nZXRMYXRlbmN5U2ltKCkgfHwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy91dGlscy5qc1xuICB2YXIgbG9nRXJyb3IgPSAobXNnLCBvYmopID0+IGNvbnNvbGUuZXJyb3IgJiYgY29uc29sZS5lcnJvcihtc2csIG9iaik7XG4gIHZhciBpc0NpZCA9IChjaWQpID0+IHR5cGVvZiBjaWQgPT09IFwibnVtYmVyXCI7XG4gIGZ1bmN0aW9uIGRldGVjdER1cGxpY2F0ZUlkcygpIHtcbiAgICBsZXQgaWRzID0gbmV3IFNldCgpO1xuICAgIGxldCBlbGVtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqW2lkXVwiKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZWxlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChpZHMuaGFzKGVsZW1zW2ldLmlkKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBNdWx0aXBsZSBJRHMgZGV0ZWN0ZWQ6ICR7ZWxlbXNbaV0uaWR9LiBFbnN1cmUgdW5pcXVlIGVsZW1lbnQgaWRzLmApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWRzLmFkZChlbGVtc1tpXS5pZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBkZWJ1ZyA9ICh2aWV3LCBraW5kLCBtc2csIG9iaikgPT4ge1xuICAgIGlmICh2aWV3LmxpdmVTb2NrZXQuaXNEZWJ1Z0VuYWJsZWQoKSkge1xuICAgICAgY29uc29sZS5sb2coYCR7dmlldy5pZH0gJHtraW5kfTogJHttc2d9IC0gYCwgb2JqKTtcbiAgICB9XG4gIH07XG4gIHZhciBjbG9zdXJlID0gKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiID8gdmFsIDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcbiAgdmFyIGNsb25lID0gKG9iaikgPT4ge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICB9O1xuICB2YXIgY2xvc2VzdFBoeEJpbmRpbmcgPSAoZWwsIGJpbmRpbmcsIGJvcmRlckVsKSA9PiB7XG4gICAgZG8ge1xuICAgICAgaWYgKGVsLm1hdGNoZXMoYFske2JpbmRpbmd9XWApKSB7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICAgIH1cbiAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudCB8fCBlbC5wYXJlbnROb2RlO1xuICAgIH0gd2hpbGUgKGVsICE9PSBudWxsICYmIGVsLm5vZGVUeXBlID09PSAxICYmICEoYm9yZGVyRWwgJiYgYm9yZGVyRWwuaXNTYW1lTm9kZShlbCkgfHwgZWwubWF0Y2hlcyhQSFhfVklFV19TRUxFQ1RPUikpKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgdmFyIGlzT2JqZWN0ID0gKG9iaikgPT4ge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiAhKG9iaiBpbnN0YW5jZW9mIEFycmF5KTtcbiAgfTtcbiAgdmFyIGlzRXF1YWxPYmogPSAob2JqMSwgb2JqMikgPT4gSlNPTi5zdHJpbmdpZnkob2JqMSkgPT09IEpTT04uc3RyaW5naWZ5KG9iajIpO1xuICB2YXIgaXNFbXB0eSA9IChvYmopID0+IHtcbiAgICBmb3IgKGxldCB4IGluIG9iaikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgdmFyIG1heWJlID0gKGVsLCBjYWxsYmFjaykgPT4gZWwgJiYgY2FsbGJhY2soZWwpO1xuICB2YXIgY2hhbm5lbFVwbG9hZGVyID0gZnVuY3Rpb24oZW50cmllcywgb25FcnJvciwgcmVzcCwgbGl2ZVNvY2tldCkge1xuICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgIGxldCBlbnRyeVVwbG9hZGVyID0gbmV3IEVudHJ5VXBsb2FkZXIoZW50cnksIHJlc3AuY29uZmlnLmNodW5rX3NpemUsIGxpdmVTb2NrZXQpO1xuICAgICAgZW50cnlVcGxvYWRlci51cGxvYWQoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy9icm93c2VyLmpzXG4gIHZhciBCcm93c2VyID0ge1xuICAgIGNhblB1c2hTdGF0ZSgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgaGlzdG9yeS5wdXNoU3RhdGUgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgfSxcbiAgICBkcm9wTG9jYWwobG9jYWxTdG9yYWdlLCBuYW1lc3BhY2UsIHN1YmtleSkge1xuICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMubG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpKTtcbiAgICB9LFxuICAgIHVwZGF0ZUxvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXksIGluaXRpYWwsIGZ1bmMpIHtcbiAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5nZXRMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5KTtcbiAgICAgIGxldCBrZXkgPSB0aGlzLmxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KTtcbiAgICAgIGxldCBuZXdWYWwgPSBjdXJyZW50ID09PSBudWxsID8gaW5pdGlhbCA6IGZ1bmMoY3VycmVudCk7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KG5ld1ZhbCkpO1xuICAgICAgcmV0dXJuIG5ld1ZhbDtcbiAgICB9LFxuICAgIGdldExvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXkpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMubG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpKSk7XG4gICAgfSxcbiAgICB1cGRhdGVDdXJyZW50U3RhdGUoY2FsbGJhY2spIHtcbiAgICAgIGlmICghdGhpcy5jYW5QdXNoU3RhdGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShjYWxsYmFjayhoaXN0b3J5LnN0YXRlIHx8IHt9KSwgXCJcIiwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgIH0sXG4gICAgcHVzaFN0YXRlKGtpbmQsIG1ldGEsIHRvKSB7XG4gICAgICBpZiAodGhpcy5jYW5QdXNoU3RhdGUoKSkge1xuICAgICAgICBpZiAodG8gIT09IHdpbmRvdy5sb2NhdGlvbi5ocmVmKSB7XG4gICAgICAgICAgaWYgKG1ldGEudHlwZSA9PSBcInJlZGlyZWN0XCIgJiYgbWV0YS5zY3JvbGwpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50U3RhdGUgPSBoaXN0b3J5LnN0YXRlIHx8IHt9O1xuICAgICAgICAgICAgY3VycmVudFN0YXRlLnNjcm9sbCA9IG1ldGEuc2Nyb2xsO1xuICAgICAgICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoY3VycmVudFN0YXRlLCBcIlwiLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBtZXRhLnNjcm9sbDtcbiAgICAgICAgICBoaXN0b3J5W2tpbmQgKyBcIlN0YXRlXCJdKG1ldGEsIFwiXCIsIHRvIHx8IG51bGwpO1xuICAgICAgICAgIGxldCBoYXNoRWwgPSB0aGlzLmdldEhhc2hUYXJnZXRFbCh3aW5kb3cubG9jYXRpb24uaGFzaCk7XG4gICAgICAgICAgaWYgKGhhc2hFbCkge1xuICAgICAgICAgICAgaGFzaEVsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChtZXRhLnR5cGUgPT09IFwicmVkaXJlY3RcIikge1xuICAgICAgICAgICAgd2luZG93LnNjcm9sbCgwLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVkaXJlY3QodG8pO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0Q29va2llKG5hbWUsIHZhbHVlKSB7XG4gICAgICBkb2N1bWVudC5jb29raWUgPSBgJHtuYW1lfT0ke3ZhbHVlfWA7XG4gICAgfSxcbiAgICBnZXRDb29raWUobmFtZSkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNvb2tpZS5yZXBsYWNlKG5ldyBSZWdFeHAoYCg/Oig/Ol58Lio7cyopJHtuYW1lfXMqPXMqKFteO10qKS4qJCl8Xi4qJGApLCBcIiQxXCIpO1xuICAgIH0sXG4gICAgcmVkaXJlY3QodG9VUkwsIGZsYXNoKSB7XG4gICAgICBpZiAoZmxhc2gpIHtcbiAgICAgICAgQnJvd3Nlci5zZXRDb29raWUoXCJfX3Bob2VuaXhfZmxhc2hfX1wiLCBmbGFzaCArIFwiOyBtYXgtYWdlPTYwMDAwOyBwYXRoPS9cIik7XG4gICAgICB9XG4gICAgICB3aW5kb3cubG9jYXRpb24gPSB0b1VSTDtcbiAgICB9LFxuICAgIGxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KSB7XG4gICAgICByZXR1cm4gYCR7bmFtZXNwYWNlfS0ke3N1YmtleX1gO1xuICAgIH0sXG4gICAgZ2V0SGFzaFRhcmdldEVsKG1heWJlSGFzaCkge1xuICAgICAgbGV0IGhhc2ggPSBtYXliZUhhc2gudG9TdHJpbmcoKS5zdWJzdHJpbmcoMSk7XG4gICAgICBpZiAoaGFzaCA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaCkgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgYVtuYW1lPVwiJHtoYXNofVwiXWApO1xuICAgIH1cbiAgfTtcbiAgdmFyIGJyb3dzZXJfZGVmYXVsdCA9IEJyb3dzZXI7XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvZG9tLmpzXG4gIHZhciBET00gPSB7XG4gICAgYnlJZChpZCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSB8fCBsb2dFcnJvcihgbm8gaWQgZm91bmQgZm9yICR7aWR9YCk7XG4gICAgfSxcbiAgICByZW1vdmVDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICBpZiAoZWwuY2xhc3NMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFsbChub2RlLCBxdWVyeSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBsZXQgYXJyYXkgPSBBcnJheS5mcm9tKG5vZGUucXVlcnlTZWxlY3RvckFsbChxdWVyeSkpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrID8gYXJyYXkuZm9yRWFjaChjYWxsYmFjaykgOiBhcnJheTtcbiAgICB9LFxuICAgIGNoaWxkTm9kZUxlbmd0aChodG1sKSB7XG4gICAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG4gICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgcmV0dXJuIHRlbXBsYXRlLmNvbnRlbnQuY2hpbGRFbGVtZW50Q291bnQ7XG4gICAgfSxcbiAgICBpc1VwbG9hZElucHV0KGVsKSB7XG4gICAgICByZXR1cm4gZWwudHlwZSA9PT0gXCJmaWxlXCIgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKSAhPT0gbnVsbDtcbiAgICB9LFxuICAgIGZpbmRVcGxvYWRJbnB1dHMobm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuYWxsKG5vZGUsIGBpbnB1dFt0eXBlPVwiZmlsZVwiXVske1BIWF9VUExPQURfUkVGfV1gKTtcbiAgICB9LFxuICAgIGZpbmRDb21wb25lbnROb2RlTGlzdChub2RlLCBjaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcldpdGhpblNhbWVMaXZlVmlldyh0aGlzLmFsbChub2RlLCBgWyR7UEhYX0NPTVBPTkVOVH09XCIke2NpZH1cIl1gKSwgbm9kZSk7XG4gICAgfSxcbiAgICBpc1BoeERlc3Ryb3llZChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5pZCAmJiBET00ucHJpdmF0ZShub2RlLCBcImRlc3Ryb3llZFwiKSA/IHRydWUgOiBmYWxzZTtcbiAgICB9LFxuICAgIG1hcmtQaHhDaGlsZERlc3Ryb3llZChlbCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OLCBcIlwiKTtcbiAgICAgIHRoaXMucHV0UHJpdmF0ZShlbCwgXCJkZXN0cm95ZWRcIiwgdHJ1ZSk7XG4gICAgfSxcbiAgICBmaW5kUGh4Q2hpbGRyZW5JbkZyYWdtZW50KGh0bWwsIHBhcmVudElkKSB7XG4gICAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG4gICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgcmV0dXJuIHRoaXMuZmluZFBoeENoaWxkcmVuKHRlbXBsYXRlLmNvbnRlbnQsIHBhcmVudElkKTtcbiAgICB9LFxuICAgIGlzSWdub3JlZChlbCwgcGh4VXBkYXRlKSB7XG4gICAgICByZXR1cm4gKGVsLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpIHx8IGVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LXVwZGF0ZVwiKSkgPT09IFwiaWdub3JlXCI7XG4gICAgfSxcbiAgICBpc1BoeFVwZGF0ZShlbCwgcGh4VXBkYXRlLCB1cGRhdGVUeXBlcykge1xuICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiB1cGRhdGVUeXBlcy5pbmRleE9mKGVsLmdldEF0dHJpYnV0ZShwaHhVcGRhdGUpKSA+PSAwO1xuICAgIH0sXG4gICAgZmluZFBoeENoaWxkcmVuKGVsLCBwYXJlbnRJZCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWxsKGVsLCBgJHtQSFhfVklFV19TRUxFQ1RPUn1bJHtQSFhfUEFSRU5UX0lEfT1cIiR7cGFyZW50SWR9XCJdYCk7XG4gICAgfSxcbiAgICBmaW5kUGFyZW50Q0lEcyhub2RlLCBjaWRzKSB7XG4gICAgICBsZXQgaW5pdGlhbCA9IG5ldyBTZXQoY2lkcyk7XG4gICAgICByZXR1cm4gY2lkcy5yZWR1Y2UoKGFjYywgY2lkKSA9PiB7XG4gICAgICAgIGxldCBzZWxlY3RvciA9IGBbJHtQSFhfQ09NUE9ORU5UfT1cIiR7Y2lkfVwiXSBbJHtQSFhfQ09NUE9ORU5UfV1gO1xuICAgICAgICB0aGlzLmZpbHRlcldpdGhpblNhbWVMaXZlVmlldyh0aGlzLmFsbChub2RlLCBzZWxlY3RvciksIG5vZGUpLm1hcCgoZWwpID0+IHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSkpLmZvckVhY2goKGNoaWxkQ0lEKSA9PiBhY2MuZGVsZXRlKGNoaWxkQ0lEKSk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCBpbml0aWFsKTtcbiAgICB9LFxuICAgIGZpbHRlcldpdGhpblNhbWVMaXZlVmlldyhub2RlcywgcGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LnF1ZXJ5U2VsZWN0b3IoUEhYX1ZJRVdfU0VMRUNUT1IpKSB7XG4gICAgICAgIHJldHVybiBub2Rlcy5maWx0ZXIoKGVsKSA9PiB0aGlzLndpdGhpblNhbWVMaXZlVmlldyhlbCwgcGFyZW50KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICB9XG4gICAgfSxcbiAgICB3aXRoaW5TYW1lTGl2ZVZpZXcobm9kZSwgcGFyZW50KSB7XG4gICAgICB3aGlsZSAobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAobm9kZS5pc1NhbWVOb2RlKHBhcmVudCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBwcml2YXRlKGVsLCBrZXkpIHtcbiAgICAgIHJldHVybiBlbFtQSFhfUFJJVkFURV0gJiYgZWxbUEhYX1BSSVZBVEVdW2tleV07XG4gICAgfSxcbiAgICBkZWxldGVQcml2YXRlKGVsLCBrZXkpIHtcbiAgICAgIGVsW1BIWF9QUklWQVRFXSAmJiBkZWxldGUgZWxbUEhYX1BSSVZBVEVdW2tleV07XG4gICAgfSxcbiAgICBwdXRQcml2YXRlKGVsLCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoIWVsW1BIWF9QUklWQVRFXSkge1xuICAgICAgICBlbFtQSFhfUFJJVkFURV0gPSB7fTtcbiAgICAgIH1cbiAgICAgIGVsW1BIWF9QUklWQVRFXVtrZXldID0gdmFsdWU7XG4gICAgfSxcbiAgICBjb3B5UHJpdmF0ZXModGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2VbUEhYX1BSSVZBVEVdKSB7XG4gICAgICAgIHRhcmdldFtQSFhfUFJJVkFURV0gPSBjbG9uZShzb3VyY2VbUEhYX1BSSVZBVEVdKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHB1dFRpdGxlKHN0cikge1xuICAgICAgbGV0IHRpdGxlRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwidGl0bGVcIik7XG4gICAgICBsZXQgeyBwcmVmaXgsIHN1ZmZpeCB9ID0gdGl0bGVFbC5kYXRhc2V0O1xuICAgICAgZG9jdW1lbnQudGl0bGUgPSBgJHtwcmVmaXggfHwgXCJcIn0ke3N0cn0ke3N1ZmZpeCB8fCBcIlwifWA7XG4gICAgfSxcbiAgICBkZWJvdW5jZShlbCwgZXZlbnQsIHBoeERlYm91bmNlLCBkZWZhdWx0RGVib3VuY2UsIHBoeFRocm90dGxlLCBkZWZhdWx0VGhyb3R0bGUsIGNhbGxiYWNrKSB7XG4gICAgICBsZXQgZGVib3VuY2UgPSBlbC5nZXRBdHRyaWJ1dGUocGh4RGVib3VuY2UpO1xuICAgICAgbGV0IHRocm90dGxlID0gZWwuZ2V0QXR0cmlidXRlKHBoeFRocm90dGxlKTtcbiAgICAgIGlmIChkZWJvdW5jZSA9PT0gXCJcIikge1xuICAgICAgICBkZWJvdW5jZSA9IGRlZmF1bHREZWJvdW5jZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aHJvdHRsZSA9PT0gXCJcIikge1xuICAgICAgICB0aHJvdHRsZSA9IGRlZmF1bHRUaHJvdHRsZTtcbiAgICAgIH1cbiAgICAgIGxldCB2YWx1ZSA9IGRlYm91bmNlIHx8IHRocm90dGxlO1xuICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIGNhc2UgXCJibHVyXCI6XG4gICAgICAgICAgaWYgKHRoaXMub25jZShlbCwgXCJkZWJvdW5jZS1ibHVyXCIpKSB7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCAoKSA9PiBjYWxsYmFjaygpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCB0aW1lb3V0ID0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICAgIGxldCB0cmlnZ2VyID0gKCkgPT4gdGhyb3R0bGUgPyB0aGlzLmRlbGV0ZVByaXZhdGUoZWwsIFRIUk9UVExFRCkgOiBjYWxsYmFjaygpO1xuICAgICAgICAgIGxldCBjdXJyZW50Q3ljbGUgPSB0aGlzLmluY0N5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSLCB0cmlnZ2VyKTtcbiAgICAgICAgICBpZiAoaXNOYU4odGltZW91dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dFcnJvcihgaW52YWxpZCB0aHJvdHRsZS9kZWJvdW5jZSB2YWx1ZTogJHt2YWx1ZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRocm90dGxlKSB7XG4gICAgICAgICAgICBsZXQgbmV3S2V5RG93biA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwia2V5ZG93blwiKSB7XG4gICAgICAgICAgICAgIGxldCBwcmV2S2V5ID0gdGhpcy5wcml2YXRlKGVsLCBERUJPVU5DRV9QUkVWX0tFWSk7XG4gICAgICAgICAgICAgIHRoaXMucHV0UHJpdmF0ZShlbCwgREVCT1VOQ0VfUFJFVl9LRVksIGV2ZW50LmtleSk7XG4gICAgICAgICAgICAgIG5ld0tleURvd24gPSBwcmV2S2V5ICE9PSBldmVudC5rZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5ld0tleURvd24gJiYgdGhpcy5wcml2YXRlKGVsLCBUSFJPVFRMRUQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIHRoaXMucHV0UHJpdmF0ZShlbCwgVEhST1RUTEVELCB0cnVlKTtcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnRyaWdnZXJDeWNsZShlbCwgREVCT1VOQ0VfVFJJR0dFUiksIHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSLCBjdXJyZW50Q3ljbGUpLCB0aW1lb3V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGZvcm0gPSBlbC5mb3JtO1xuICAgICAgICAgIGlmIChmb3JtICYmIHRoaXMub25jZShmb3JtLCBcImJpbmQtZGVib3VuY2VcIikpIHtcbiAgICAgICAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgIEFycmF5LmZyb20obmV3IEZvcm1EYXRhKGZvcm0pLmVudHJpZXMoKSwgKFtuYW1lXSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpbnB1dCA9IGZvcm0ucXVlcnlTZWxlY3RvcihgW25hbWU9XCIke25hbWV9XCJdYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNDeWNsZShpbnB1dCwgREVCT1VOQ0VfVFJJR0dFUik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVQcml2YXRlKGlucHV0LCBUSFJPVFRMRUQpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5vbmNlKGVsLCBcImJpbmQtZGVib3VuY2VcIikpIHtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICgpID0+IHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSKSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgdHJpZ2dlckN5Y2xlKGVsLCBrZXksIGN1cnJlbnRDeWNsZSkge1xuICAgICAgbGV0IFtjeWNsZSwgdHJpZ2dlcl0gPSB0aGlzLnByaXZhdGUoZWwsIGtleSk7XG4gICAgICBpZiAoIWN1cnJlbnRDeWNsZSkge1xuICAgICAgICBjdXJyZW50Q3ljbGUgPSBjeWNsZTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50Q3ljbGUgPT09IGN5Y2xlKSB7XG4gICAgICAgIHRoaXMuaW5jQ3ljbGUoZWwsIGtleSk7XG4gICAgICAgIHRyaWdnZXIoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uY2UoZWwsIGtleSkge1xuICAgICAgaWYgKHRoaXMucHJpdmF0ZShlbCwga2V5KSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGluY0N5Y2xlKGVsLCBrZXksIHRyaWdnZXIgPSBmdW5jdGlvbigpIHtcbiAgICB9KSB7XG4gICAgICBsZXQgW2N1cnJlbnRDeWNsZV0gPSB0aGlzLnByaXZhdGUoZWwsIGtleSkgfHwgWzAsIHRyaWdnZXJdO1xuICAgICAgY3VycmVudEN5Y2xlKys7XG4gICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgW2N1cnJlbnRDeWNsZSwgdHJpZ2dlcl0pO1xuICAgICAgcmV0dXJuIGN1cnJlbnRDeWNsZTtcbiAgICB9LFxuICAgIGRpc2NhcmRFcnJvcihjb250YWluZXIsIGVsLCBwaHhGZWVkYmFja0Zvcikge1xuICAgICAgbGV0IGZpZWxkID0gZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShwaHhGZWVkYmFja0Zvcik7XG4gICAgICBsZXQgaW5wdXQgPSBmaWVsZCAmJiBjb250YWluZXIucXVlcnlTZWxlY3RvcihgW2lkPVwiJHtmaWVsZH1cIl0sIFtuYW1lPVwiJHtmaWVsZH1cIl1gKTtcbiAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCEodGhpcy5wcml2YXRlKGlucHV0LCBQSFhfSEFTX0ZPQ1VTRUQpIHx8IHRoaXMucHJpdmF0ZShpbnB1dC5mb3JtLCBQSFhfSEFTX1NVQk1JVFRFRCkpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoUEhYX05PX0ZFRURCQUNLX0NMQVNTKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3dFcnJvcihpbnB1dEVsLCBwaHhGZWVkYmFja0Zvcikge1xuICAgICAgaWYgKGlucHV0RWwuaWQgfHwgaW5wdXRFbC5uYW1lKSB7XG4gICAgICAgIHRoaXMuYWxsKGlucHV0RWwuZm9ybSwgYFske3BoeEZlZWRiYWNrRm9yfT1cIiR7aW5wdXRFbC5pZH1cIl0sIFske3BoeEZlZWRiYWNrRm9yfT1cIiR7aW5wdXRFbC5uYW1lfVwiXWAsIChlbCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVtb3ZlQ2xhc3MoZWwsIFBIWF9OT19GRUVEQkFDS19DTEFTUyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNQaHhDaGlsZChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRCk7XG4gICAgfSxcbiAgICBkaXNwYXRjaEV2ZW50KHRhcmdldCwgZXZlbnRTdHJpbmcsIGRldGFpbCA9IHt9KSB7XG4gICAgICBsZXQgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnRTdHJpbmcsIHsgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSwgZGV0YWlsIH0pO1xuICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH0sXG4gICAgY2xvbmVOb2RlKG5vZGUsIGh0bWwpIHtcbiAgICAgIGlmICh0eXBlb2YgaHRtbCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gbm9kZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgY2xvbmVkID0gbm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAgICBjbG9uZWQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1lcmdlQXR0cnModGFyZ2V0LCBzb3VyY2UsIG9wdHMgPSB7fSkge1xuICAgICAgbGV0IGV4Y2x1ZGUgPSBvcHRzLmV4Y2x1ZGUgfHwgW107XG4gICAgICBsZXQgaXNJZ25vcmVkID0gb3B0cy5pc0lnbm9yZWQ7XG4gICAgICBsZXQgc291cmNlQXR0cnMgPSBzb3VyY2UuYXR0cmlidXRlcztcbiAgICAgIGZvciAobGV0IGkgPSBzb3VyY2VBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBsZXQgbmFtZSA9IHNvdXJjZUF0dHJzW2ldLm5hbWU7XG4gICAgICAgIGlmIChleGNsdWRlLmluZGV4T2YobmFtZSkgPCAwKSB7XG4gICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShuYW1lLCBzb3VyY2UuZ2V0QXR0cmlidXRlKG5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IHRhcmdldEF0dHJzID0gdGFyZ2V0LmF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKGxldCBpID0gdGFyZ2V0QXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IG5hbWUgPSB0YXJnZXRBdHRyc1tpXS5uYW1lO1xuICAgICAgICBpZiAoaXNJZ25vcmVkKSB7XG4gICAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aChcImRhdGEtXCIpICYmICFzb3VyY2UuaGFzQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICAgICAgICB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXNvdXJjZS5oYXNBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgICAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtZXJnZUZvY3VzZWRJbnB1dCh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpKSB7XG4gICAgICAgIERPTS5tZXJnZUF0dHJzKHRhcmdldCwgc291cmNlLCB7IGV4Y2VwdDogW1widmFsdWVcIl0gfSk7XG4gICAgICB9XG4gICAgICBpZiAoc291cmNlLnJlYWRPbmx5KSB7XG4gICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJyZWFkb25seVwiLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJyZWFkb25seVwiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhc1NlbGVjdGlvblJhbmdlKGVsKSB7XG4gICAgICByZXR1cm4gZWwuc2V0U2VsZWN0aW9uUmFuZ2UgJiYgKGVsLnR5cGUgPT09IFwidGV4dFwiIHx8IGVsLnR5cGUgPT09IFwidGV4dGFyZWFcIik7XG4gICAgfSxcbiAgICByZXN0b3JlRm9jdXMoZm9jdXNlZCwgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCkge1xuICAgICAgaWYgKCFET00uaXNUZXh0dWFsSW5wdXQoZm9jdXNlZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHdhc0ZvY3VzZWQgPSBmb2N1c2VkLm1hdGNoZXMoXCI6Zm9jdXNcIik7XG4gICAgICBpZiAoZm9jdXNlZC5yZWFkT25seSkge1xuICAgICAgICBmb2N1c2VkLmJsdXIoKTtcbiAgICAgIH1cbiAgICAgIGlmICghd2FzRm9jdXNlZCkge1xuICAgICAgICBmb2N1c2VkLmZvY3VzKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNTZWxlY3Rpb25SYW5nZShmb2N1c2VkKSkge1xuICAgICAgICBmb2N1c2VkLnNldFNlbGVjdGlvblJhbmdlKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNGb3JtSW5wdXQoZWwpIHtcbiAgICAgIHJldHVybiAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYSkkL2kudGVzdChlbC50YWdOYW1lKSAmJiBlbC50eXBlICE9PSBcImJ1dHRvblwiO1xuICAgIH0sXG4gICAgc3luY0F0dHJzVG9Qcm9wcyhlbCkge1xuICAgICAgaWYgKGVsIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCAmJiBDSEVDS0FCTEVfSU5QVVRTLmluZGV4T2YoZWwudHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpKSA+PSAwKSB7XG4gICAgICAgIGVsLmNoZWNrZWQgPSBlbC5nZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIpICE9PSBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3luY1Byb3BzVG9BdHRycyhlbCkge1xuICAgICAgaWYgKGVsIGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpIHtcbiAgICAgICAgbGV0IHNlbGVjdGVkSXRlbSA9IGVsLm9wdGlvbnMuaXRlbShlbC5zZWxlY3RlZEluZGV4KTtcbiAgICAgICAgaWYgKHNlbGVjdGVkSXRlbSAmJiBzZWxlY3RlZEl0ZW0uZ2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIikgPT09IG51bGwpIHtcbiAgICAgICAgICBzZWxlY3RlZEl0ZW0uc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGlzVGV4dHVhbElucHV0KGVsKSB7XG4gICAgICByZXR1cm4gRk9DVVNBQkxFX0lOUFVUUy5pbmRleE9mKGVsLnR5cGUpID49IDA7XG4gICAgfSxcbiAgICBpc05vd1RyaWdnZXJGb3JtRXh0ZXJuYWwoZWwsIHBoeFRyaWdnZXJFeHRlcm5hbCkge1xuICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUocGh4VHJpZ2dlckV4dGVybmFsKSAhPT0gbnVsbDtcbiAgICB9LFxuICAgIHN5bmNQZW5kaW5nUmVmKGZyb21FbCwgdG9FbCwgZGlzYWJsZVdpdGgpIHtcbiAgICAgIGxldCByZWYgPSBmcm9tRWwuZ2V0QXR0cmlidXRlKFBIWF9SRUYpO1xuICAgICAgaWYgKHJlZiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChET00uaXNGb3JtSW5wdXQoZnJvbUVsKSB8fCBmcm9tRWwuZ2V0QXR0cmlidXRlKGRpc2FibGVXaXRoKSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoRE9NLmlzVXBsb2FkSW5wdXQoZnJvbUVsKSkge1xuICAgICAgICAgIERPTS5tZXJnZUF0dHJzKGZyb21FbCwgdG9FbCwgeyBpc0lnbm9yZWQ6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgRE9NLnB1dFByaXZhdGUoZnJvbUVsLCBQSFhfUkVGLCB0b0VsKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUEhYX0VWRU5UX0NMQVNTRVMuZm9yRWFjaCgoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgICAgZnJvbUVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpICYmIHRvRWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdG9FbC5zZXRBdHRyaWJ1dGUoUEhYX1JFRiwgcmVmKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGVhbkNoaWxkTm9kZXMoY29udGFpbmVyLCBwaHhVcGRhdGUpIHtcbiAgICAgIGlmIChET00uaXNQaHhVcGRhdGUoY29udGFpbmVyLCBwaHhVcGRhdGUsIFtcImFwcGVuZFwiLCBcInByZXBlbmRcIl0pKSB7XG4gICAgICAgIGxldCB0b1JlbW92ZSA9IFtdO1xuICAgICAgICBjb250YWluZXIuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICBpZiAoIWNoaWxkTm9kZS5pZCkge1xuICAgICAgICAgICAgbGV0IGlzRW1wdHlUZXh0Tm9kZSA9IGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgJiYgY2hpbGROb2RlLm5vZGVWYWx1ZS50cmltKCkgPT09IFwiXCI7XG4gICAgICAgICAgICBpZiAoIWlzRW1wdHlUZXh0Tm9kZSkge1xuICAgICAgICAgICAgICBsb2dFcnJvcihgb25seSBIVE1MIGVsZW1lbnQgdGFncyB3aXRoIGFuIGlkIGFyZSBhbGxvd2VkIGluc2lkZSBjb250YWluZXJzIHdpdGggcGh4LXVwZGF0ZS5cblxucmVtb3ZpbmcgaWxsZWdhbCBub2RlOiBcIiR7KGNoaWxkTm9kZS5vdXRlckhUTUwgfHwgY2hpbGROb2RlLm5vZGVWYWx1ZSkudHJpbSgpfVwiXG5cbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9SZW1vdmUucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRvUmVtb3ZlLmZvckVhY2goKGNoaWxkTm9kZSkgPT4gY2hpbGROb2RlLnJlbW92ZSgpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlcGxhY2VSb290Q29udGFpbmVyKGNvbnRhaW5lciwgdGFnTmFtZSwgYXR0cnMpIHtcbiAgICAgIGxldCByZXRhaW5lZEF0dHJzID0gbmV3IFNldChbXCJpZFwiLCBQSFhfU0VTU0lPTiwgUEhYX1NUQVRJQywgUEhYX01BSU5dKTtcbiAgICAgIGlmIChjb250YWluZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgQXJyYXkuZnJvbShjb250YWluZXIuYXR0cmlidXRlcykuZmlsdGVyKChhdHRyKSA9PiAhcmV0YWluZWRBdHRycy5oYXMoYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCkpKS5mb3JFYWNoKChhdHRyKSA9PiBjb250YWluZXIucmVtb3ZlQXR0cmlidXRlKGF0dHIubmFtZSkpO1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRycykuZmlsdGVyKChuYW1lKSA9PiAhcmV0YWluZWRBdHRycy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKSkuZm9yRWFjaCgoYXR0cikgPT4gY29udGFpbmVyLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSkpO1xuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IG5ld0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgICAgIE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKChhdHRyKSA9PiBuZXdDb250YWluZXIuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKSk7XG4gICAgICAgIHJldGFpbmVkQXR0cnMuZm9yRWFjaCgoYXR0cikgPT4gbmV3Q29udGFpbmVyLnNldEF0dHJpYnV0ZShhdHRyLCBjb250YWluZXIuZ2V0QXR0cmlidXRlKGF0dHIpKSk7XG4gICAgICAgIG5ld0NvbnRhaW5lci5pbm5lckhUTUwgPSBjb250YWluZXIuaW5uZXJIVE1MO1xuICAgICAgICBjb250YWluZXIucmVwbGFjZVdpdGgobmV3Q29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIG5ld0NvbnRhaW5lcjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBkb21fZGVmYXVsdCA9IERPTTtcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy91cGxvYWRfZW50cnkuanNcbiAgdmFyIFVwbG9hZEVudHJ5ID0gY2xhc3Mge1xuICAgIHN0YXRpYyBpc0FjdGl2ZShmaWxlRWwsIGZpbGUpIHtcbiAgICAgIGxldCBpc05ldyA9IGZpbGUuX3BoeFJlZiA9PT0gdm9pZCAwO1xuICAgICAgbGV0IGFjdGl2ZVJlZnMgPSBmaWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9BQ1RJVkVfRU5UUllfUkVGUykuc3BsaXQoXCIsXCIpO1xuICAgICAgbGV0IGlzQWN0aXZlID0gYWN0aXZlUmVmcy5pbmRleE9mKExpdmVVcGxvYWRlci5nZW5GaWxlUmVmKGZpbGUpKSA+PSAwO1xuICAgICAgcmV0dXJuIGZpbGUuc2l6ZSA+IDAgJiYgKGlzTmV3IHx8IGlzQWN0aXZlKTtcbiAgICB9XG4gICAgc3RhdGljIGlzUHJlZmxpZ2h0ZWQoZmlsZUVsLCBmaWxlKSB7XG4gICAgICBsZXQgcHJlZmxpZ2h0ZWRSZWZzID0gZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfUFJFRkxJR0hURURfUkVGUykuc3BsaXQoXCIsXCIpO1xuICAgICAgbGV0IGlzUHJlZmxpZ2h0ZWQgPSBwcmVmbGlnaHRlZFJlZnMuaW5kZXhPZihMaXZlVXBsb2FkZXIuZ2VuRmlsZVJlZihmaWxlKSkgPj0gMDtcbiAgICAgIHJldHVybiBpc1ByZWZsaWdodGVkICYmIHRoaXMuaXNBY3RpdmUoZmlsZUVsLCBmaWxlKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZmlsZUVsLCBmaWxlLCB2aWV3KSB7XG4gICAgICB0aGlzLnJlZiA9IExpdmVVcGxvYWRlci5nZW5GaWxlUmVmKGZpbGUpO1xuICAgICAgdGhpcy5maWxlRWwgPSBmaWxlRWw7XG4gICAgICB0aGlzLmZpbGUgPSBmaWxlO1xuICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgIHRoaXMubWV0YSA9IG51bGw7XG4gICAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5faXNEb25lID0gZmFsc2U7XG4gICAgICB0aGlzLl9wcm9ncmVzcyA9IDA7XG4gICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3NTZW50ID0gLTE7XG4gICAgICB0aGlzLl9vbkRvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIH07XG4gICAgICB0aGlzLl9vbkVsVXBkYXRlZCA9IHRoaXMub25FbFVwZGF0ZWQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuZmlsZUVsLmFkZEV2ZW50TGlzdGVuZXIoUEhYX0xJVkVfRklMRV9VUERBVEVELCB0aGlzLl9vbkVsVXBkYXRlZCk7XG4gICAgfVxuICAgIG1ldGFkYXRhKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWV0YTtcbiAgICB9XG4gICAgcHJvZ3Jlc3MocHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMuX3Byb2dyZXNzID0gTWF0aC5mbG9vcihwcm9ncmVzcyk7XG4gICAgICBpZiAodGhpcy5fcHJvZ3Jlc3MgPiB0aGlzLl9sYXN0UHJvZ3Jlc3NTZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm9ncmVzcyA+PSAxMDApIHtcbiAgICAgICAgICB0aGlzLl9wcm9ncmVzcyA9IDEwMDtcbiAgICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3NTZW50ID0gMTAwO1xuICAgICAgICAgIHRoaXMuX2lzRG9uZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy52aWV3LnB1c2hGaWxlUHJvZ3Jlc3ModGhpcy5maWxlRWwsIHRoaXMucmVmLCAxMDAsICgpID0+IHtcbiAgICAgICAgICAgIExpdmVVcGxvYWRlci51bnRyYWNrRmlsZSh0aGlzLmZpbGVFbCwgdGhpcy5maWxlKTtcbiAgICAgICAgICAgIHRoaXMuX29uRG9uZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2xhc3RQcm9ncmVzc1NlbnQgPSB0aGlzLl9wcm9ncmVzcztcbiAgICAgICAgICB0aGlzLnZpZXcucHVzaEZpbGVQcm9ncmVzcyh0aGlzLmZpbGVFbCwgdGhpcy5yZWYsIHRoaXMuX3Byb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICB0aGlzLl9pc0RvbmUgPSB0cnVlO1xuICAgICAgdGhpcy5fb25Eb25lKCk7XG4gICAgfVxuICAgIGlzRG9uZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc0RvbmU7XG4gICAgfVxuICAgIGVycm9yKHJlYXNvbiA9IFwiZmFpbGVkXCIpIHtcbiAgICAgIHRoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLCB0aGlzLnJlZiwgeyBlcnJvcjogcmVhc29uIH0pO1xuICAgICAgTGl2ZVVwbG9hZGVyLmNsZWFyRmlsZXModGhpcy5maWxlRWwpO1xuICAgIH1cbiAgICBvbkRvbmUoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuX29uRG9uZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5maWxlRWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihQSFhfTElWRV9GSUxFX1VQREFURUQsIHRoaXMuX29uRWxVcGRhdGVkKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH07XG4gICAgfVxuICAgIG9uRWxVcGRhdGVkKCkge1xuICAgICAgbGV0IGFjdGl2ZVJlZnMgPSB0aGlzLmZpbGVFbC5nZXRBdHRyaWJ1dGUoUEhYX0FDVElWRV9FTlRSWV9SRUZTKS5zcGxpdChcIixcIik7XG4gICAgICBpZiAoYWN0aXZlUmVmcy5pbmRleE9mKHRoaXMucmVmKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdG9QcmVmbGlnaHRQYXlsb2FkKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGFzdF9tb2RpZmllZDogdGhpcy5maWxlLmxhc3RNb2RpZmllZCxcbiAgICAgICAgbmFtZTogdGhpcy5maWxlLm5hbWUsXG4gICAgICAgIHNpemU6IHRoaXMuZmlsZS5zaXplLFxuICAgICAgICB0eXBlOiB0aGlzLmZpbGUudHlwZSxcbiAgICAgICAgcmVmOiB0aGlzLnJlZlxuICAgICAgfTtcbiAgICB9XG4gICAgdXBsb2FkZXIodXBsb2FkZXJzKSB7XG4gICAgICBpZiAodGhpcy5tZXRhLnVwbG9hZGVyKSB7XG4gICAgICAgIGxldCBjYWxsYmFjayA9IHVwbG9hZGVyc1t0aGlzLm1ldGEudXBsb2FkZXJdIHx8IGxvZ0Vycm9yKGBubyB1cGxvYWRlciBjb25maWd1cmVkIGZvciAke3RoaXMubWV0YS51cGxvYWRlcn1gKTtcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogdGhpcy5tZXRhLnVwbG9hZGVyLCBjYWxsYmFjayB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogXCJjaGFubmVsXCIsIGNhbGxiYWNrOiBjaGFubmVsVXBsb2FkZXIgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgemlwUG9zdEZsaWdodChyZXNwKSB7XG4gICAgICB0aGlzLm1ldGEgPSByZXNwLmVudHJpZXNbdGhpcy5yZWZdO1xuICAgICAgaWYgKCF0aGlzLm1ldGEpIHtcbiAgICAgICAgbG9nRXJyb3IoYG5vIHByZWZsaWdodCB1cGxvYWQgcmVzcG9uc2UgcmV0dXJuZWQgd2l0aCByZWYgJHt0aGlzLnJlZn1gLCB7IGlucHV0OiB0aGlzLmZpbGVFbCwgcmVzcG9uc2U6IHJlc3AgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGpzL3Bob2VuaXhfbGl2ZV92aWV3L2xpdmVfdXBsb2FkZXIuanNcbiAgdmFyIGxpdmVVcGxvYWRlckZpbGVSZWYgPSAwO1xuICB2YXIgTGl2ZVVwbG9hZGVyID0gY2xhc3Mge1xuICAgIHN0YXRpYyBnZW5GaWxlUmVmKGZpbGUpIHtcbiAgICAgIGxldCByZWYgPSBmaWxlLl9waHhSZWY7XG4gICAgICBpZiAocmVmICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbGUuX3BoeFJlZiA9IChsaXZlVXBsb2FkZXJGaWxlUmVmKyspLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBmaWxlLl9waHhSZWY7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBnZXRFbnRyeURhdGFVUkwoaW5wdXRFbCwgcmVmLCBjYWxsYmFjaykge1xuICAgICAgbGV0IGZpbGUgPSB0aGlzLmFjdGl2ZUZpbGVzKGlucHV0RWwpLmZpbmQoKGZpbGUyKSA9PiB0aGlzLmdlbkZpbGVSZWYoZmlsZTIpID09PSByZWYpO1xuICAgICAgY2FsbGJhY2soVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKSk7XG4gICAgfVxuICAgIHN0YXRpYyBoYXNVcGxvYWRzSW5Qcm9ncmVzcyhmb3JtRWwpIHtcbiAgICAgIGxldCBhY3RpdmUgPSAwO1xuICAgICAgZG9tX2RlZmF1bHQuZmluZFVwbG9hZElucHV0cyhmb3JtRWwpLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICAgIGlmIChpbnB1dC5nZXRBdHRyaWJ1dGUoUEhYX1BSRUZMSUdIVEVEX1JFRlMpICE9PSBpbnB1dC5nZXRBdHRyaWJ1dGUoUEhYX0RPTkVfUkVGUykpIHtcbiAgICAgICAgICBhY3RpdmUrKztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWN0aXZlID4gMDtcbiAgICB9XG4gICAgc3RhdGljIHNlcmlhbGl6ZVVwbG9hZHMoaW5wdXRFbCkge1xuICAgICAgbGV0IGZpbGVzID0gdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKTtcbiAgICAgIGxldCBmaWxlRGF0YSA9IHt9O1xuICAgICAgZmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgICAgICBsZXQgZW50cnkgPSB7IHBhdGg6IGlucHV0RWwubmFtZSB9O1xuICAgICAgICBsZXQgdXBsb2FkUmVmID0gaW5wdXRFbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpO1xuICAgICAgICBmaWxlRGF0YVt1cGxvYWRSZWZdID0gZmlsZURhdGFbdXBsb2FkUmVmXSB8fCBbXTtcbiAgICAgICAgZW50cnkucmVmID0gdGhpcy5nZW5GaWxlUmVmKGZpbGUpO1xuICAgICAgICBlbnRyeS5uYW1lID0gZmlsZS5uYW1lIHx8IGVudHJ5LnJlZjtcbiAgICAgICAgZW50cnkudHlwZSA9IGZpbGUudHlwZTtcbiAgICAgICAgZW50cnkuc2l6ZSA9IGZpbGUuc2l6ZTtcbiAgICAgICAgZmlsZURhdGFbdXBsb2FkUmVmXS5wdXNoKGVudHJ5KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZpbGVEYXRhO1xuICAgIH1cbiAgICBzdGF0aWMgY2xlYXJGaWxlcyhpbnB1dEVsKSB7XG4gICAgICBpbnB1dEVsLnZhbHVlID0gbnVsbDtcbiAgICAgIGlucHV0RWwucmVtb3ZlQXR0cmlidXRlKFBIWF9VUExPQURfUkVGKTtcbiAgICAgIGRvbV9kZWZhdWx0LnB1dFByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiLCBbXSk7XG4gICAgfVxuICAgIHN0YXRpYyB1bnRyYWNrRmlsZShpbnB1dEVsLCBmaWxlKSB7XG4gICAgICBkb21fZGVmYXVsdC5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgZG9tX2RlZmF1bHQucHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIpLmZpbHRlcigoZikgPT4gIU9iamVjdC5pcyhmLCBmaWxlKSkpO1xuICAgIH1cbiAgICBzdGF0aWMgdHJhY2tGaWxlcyhpbnB1dEVsLCBmaWxlcykge1xuICAgICAgaWYgKGlucHV0RWwuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIikgIT09IG51bGwpIHtcbiAgICAgICAgbGV0IG5ld0ZpbGVzID0gZmlsZXMuZmlsdGVyKChmaWxlKSA9PiAhdGhpcy5hY3RpdmVGaWxlcyhpbnB1dEVsKS5maW5kKChmKSA9PiBPYmplY3QuaXMoZiwgZmlsZSkpKTtcbiAgICAgICAgZG9tX2RlZmF1bHQucHV0UHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIsIHRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbCkuY29uY2F0KG5ld0ZpbGVzKSk7XG4gICAgICAgIGlucHV0RWwudmFsdWUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tX2RlZmF1bHQucHV0UHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIsIGZpbGVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGFjdGl2ZUZpbGVJbnB1dHMoZm9ybUVsKSB7XG4gICAgICBsZXQgZmlsZUlucHV0cyA9IGRvbV9kZWZhdWx0LmZpbmRVcGxvYWRJbnB1dHMoZm9ybUVsKTtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGZpbGVJbnB1dHMpLmZpbHRlcigoZWwpID0+IGVsLmZpbGVzICYmIHRoaXMuYWN0aXZlRmlsZXMoZWwpLmxlbmd0aCA+IDApO1xuICAgIH1cbiAgICBzdGF0aWMgYWN0aXZlRmlsZXMoaW5wdXQpIHtcbiAgICAgIHJldHVybiAoZG9tX2RlZmF1bHQucHJpdmF0ZShpbnB1dCwgXCJmaWxlc1wiKSB8fCBbXSkuZmlsdGVyKChmKSA9PiBVcGxvYWRFbnRyeS5pc0FjdGl2ZShpbnB1dCwgZikpO1xuICAgIH1cbiAgICBzdGF0aWMgaW5wdXRzQXdhaXRpbmdQcmVmbGlnaHQoZm9ybUVsKSB7XG4gICAgICBsZXQgZmlsZUlucHV0cyA9IGRvbV9kZWZhdWx0LmZpbmRVcGxvYWRJbnB1dHMoZm9ybUVsKTtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGZpbGVJbnB1dHMpLmZpbHRlcigoaW5wdXQpID0+IHRoaXMuZmlsZXNBd2FpdGluZ1ByZWZsaWdodChpbnB1dCkubGVuZ3RoID4gMCk7XG4gICAgfVxuICAgIHN0YXRpYyBmaWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0KSB7XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmVGaWxlcyhpbnB1dCkuZmlsdGVyKChmKSA9PiAhVXBsb2FkRW50cnkuaXNQcmVmbGlnaHRlZChpbnB1dCwgZikpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihpbnB1dEVsLCB2aWV3LCBvbkNvbXBsZXRlKSB7XG4gICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgdGhpcy5vbkNvbXBsZXRlID0gb25Db21wbGV0ZTtcbiAgICAgIHRoaXMuX2VudHJpZXMgPSBBcnJheS5mcm9tKExpdmVVcGxvYWRlci5maWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0RWwpIHx8IFtdKS5tYXAoKGZpbGUpID0+IG5ldyBVcGxvYWRFbnRyeShpbnB1dEVsLCBmaWxlLCB2aWV3KSk7XG4gICAgICB0aGlzLm51bUVudHJpZXNJblByb2dyZXNzID0gdGhpcy5fZW50cmllcy5sZW5ndGg7XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW50cmllcztcbiAgICB9XG4gICAgaW5pdEFkYXB0ZXJVcGxvYWQocmVzcCwgb25FcnJvciwgbGl2ZVNvY2tldCkge1xuICAgICAgdGhpcy5fZW50cmllcyA9IHRoaXMuX2VudHJpZXMubWFwKChlbnRyeSkgPT4ge1xuICAgICAgICBlbnRyeS56aXBQb3N0RmxpZ2h0KHJlc3ApO1xuICAgICAgICBlbnRyeS5vbkRvbmUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3MtLTtcbiAgICAgICAgICBpZiAodGhpcy5udW1FbnRyaWVzSW5Qcm9ncmVzcyA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5vbkNvbXBsZXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgfSk7XG4gICAgICBsZXQgZ3JvdXBlZEVudHJpZXMgPSB0aGlzLl9lbnRyaWVzLnJlZHVjZSgoYWNjLCBlbnRyeSkgPT4ge1xuICAgICAgICBsZXQgeyBuYW1lLCBjYWxsYmFjayB9ID0gZW50cnkudXBsb2FkZXIobGl2ZVNvY2tldC51cGxvYWRlcnMpO1xuICAgICAgICBhY2NbbmFtZV0gPSBhY2NbbmFtZV0gfHwgeyBjYWxsYmFjaywgZW50cmllczogW10gfTtcbiAgICAgICAgYWNjW25hbWVdLmVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSk7XG4gICAgICBmb3IgKGxldCBuYW1lIGluIGdyb3VwZWRFbnRyaWVzKSB7XG4gICAgICAgIGxldCB7IGNhbGxiYWNrLCBlbnRyaWVzIH0gPSBncm91cGVkRW50cmllc1tuYW1lXTtcbiAgICAgICAgY2FsbGJhY2soZW50cmllcywgb25FcnJvciwgcmVzcCwgbGl2ZVNvY2tldCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGpzL3Bob2VuaXhfbGl2ZV92aWV3L2hvb2tzLmpzXG4gIHZhciBIb29rcyA9IHtcbiAgICBMaXZlRmlsZVVwbG9hZDoge1xuICAgICAgYWN0aXZlUmVmcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9BQ1RJVkVfRU5UUllfUkVGUyk7XG4gICAgICB9LFxuICAgICAgcHJlZmxpZ2h0ZWRSZWZzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1BSRUZMSUdIVEVEX1JFRlMpO1xuICAgICAgfSxcbiAgICAgIG1vdW50ZWQoKSB7XG4gICAgICAgIHRoaXMucHJlZmxpZ2h0ZWRXYXMgPSB0aGlzLnByZWZsaWdodGVkUmVmcygpO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZWQoKSB7XG4gICAgICAgIGxldCBuZXdQcmVmbGlnaHRzID0gdGhpcy5wcmVmbGlnaHRlZFJlZnMoKTtcbiAgICAgICAgaWYgKHRoaXMucHJlZmxpZ2h0ZWRXYXMgIT09IG5ld1ByZWZsaWdodHMpIHtcbiAgICAgICAgICB0aGlzLnByZWZsaWdodGVkV2FzID0gbmV3UHJlZmxpZ2h0cztcbiAgICAgICAgICBpZiAobmV3UHJlZmxpZ2h0cyA9PT0gXCJcIikge1xuICAgICAgICAgICAgdGhpcy5fX3ZpZXcuY2FuY2VsU3VibWl0KHRoaXMuZWwuZm9ybSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVJlZnMoKSA9PT0gXCJcIikge1xuICAgICAgICAgIHRoaXMuZWwudmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoUEhYX0xJVkVfRklMRV9VUERBVEVEKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBMaXZlSW1nUHJldmlldzoge1xuICAgICAgbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy5yZWYgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWVudHJ5LXJlZlwiKTtcbiAgICAgICAgdGhpcy5pbnB1dEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpKTtcbiAgICAgICAgTGl2ZVVwbG9hZGVyLmdldEVudHJ5RGF0YVVSTCh0aGlzLmlucHV0RWwsIHRoaXMucmVmLCAodXJsKSA9PiB7XG4gICAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgICAgdGhpcy5lbC5zcmMgPSB1cmw7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3llZCgpIHtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLnVybCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgaG9va3NfZGVmYXVsdCA9IEhvb2tzO1xuXG4gIC8vIGpzL3Bob2VuaXhfbGl2ZV92aWV3L2RvbV9wb3N0X21vcnBoX3Jlc3RvcmVyLmpzXG4gIHZhciBET01Qb3N0TW9ycGhSZXN0b3JlciA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXJCZWZvcmUsIGNvbnRhaW5lckFmdGVyLCB1cGRhdGVUeXBlKSB7XG4gICAgICBsZXQgaWRzQmVmb3JlID0gbmV3IFNldCgpO1xuICAgICAgbGV0IGlkc0FmdGVyID0gbmV3IFNldChbLi4uY29udGFpbmVyQWZ0ZXIuY2hpbGRyZW5dLm1hcCgoY2hpbGQpID0+IGNoaWxkLmlkKSk7XG4gICAgICBsZXQgZWxlbWVudHNUb01vZGlmeSA9IFtdO1xuICAgICAgQXJyYXkuZnJvbShjb250YWluZXJCZWZvcmUuY2hpbGRyZW4pLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC5pZCkge1xuICAgICAgICAgIGlkc0JlZm9yZS5hZGQoY2hpbGQuaWQpO1xuICAgICAgICAgIGlmIChpZHNBZnRlci5oYXMoY2hpbGQuaWQpKSB7XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNFbGVtZW50SWQgPSBjaGlsZC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICYmIGNoaWxkLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuaWQ7XG4gICAgICAgICAgICBlbGVtZW50c1RvTW9kaWZ5LnB1c2goeyBlbGVtZW50SWQ6IGNoaWxkLmlkLCBwcmV2aW91c0VsZW1lbnRJZCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb250YWluZXJJZCA9IGNvbnRhaW5lckFmdGVyLmlkO1xuICAgICAgdGhpcy51cGRhdGVUeXBlID0gdXBkYXRlVHlwZTtcbiAgICAgIHRoaXMuZWxlbWVudHNUb01vZGlmeSA9IGVsZW1lbnRzVG9Nb2RpZnk7XG4gICAgICB0aGlzLmVsZW1lbnRJZHNUb0FkZCA9IFsuLi5pZHNBZnRlcl0uZmlsdGVyKChpZCkgPT4gIWlkc0JlZm9yZS5oYXMoaWQpKTtcbiAgICB9XG4gICAgcGVyZm9ybSgpIHtcbiAgICAgIGxldCBjb250YWluZXIgPSBkb21fZGVmYXVsdC5ieUlkKHRoaXMuY29udGFpbmVySWQpO1xuICAgICAgdGhpcy5lbGVtZW50c1RvTW9kaWZ5LmZvckVhY2goKGVsZW1lbnRUb01vZGlmeSkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudFRvTW9kaWZ5LnByZXZpb3VzRWxlbWVudElkKSB7XG4gICAgICAgICAgbWF5YmUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudFRvTW9kaWZ5LnByZXZpb3VzRWxlbWVudElkKSwgKHByZXZpb3VzRWxlbSkgPT4ge1xuICAgICAgICAgICAgbWF5YmUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudFRvTW9kaWZ5LmVsZW1lbnRJZCksIChlbGVtKSA9PiB7XG4gICAgICAgICAgICAgIGxldCBpc0luUmlnaHRQbGFjZSA9IGVsZW0ucHJldmlvdXNFbGVtZW50U2libGluZyAmJiBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuaWQgPT0gcHJldmlvdXNFbGVtLmlkO1xuICAgICAgICAgICAgICBpZiAoIWlzSW5SaWdodFBsYWNlKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNFbGVtLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyZW5kXCIsIGVsZW0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkuZWxlbWVudElkKSwgKGVsZW0pID0+IHtcbiAgICAgICAgICAgIGxldCBpc0luUmlnaHRQbGFjZSA9IGVsZW0ucHJldmlvdXNFbGVtZW50U2libGluZyA9PSBudWxsO1xuICAgICAgICAgICAgaWYgKCFpc0luUmlnaHRQbGFjZSkge1xuICAgICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJiZWdpblwiLCBlbGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy51cGRhdGVUeXBlID09IFwicHJlcGVuZFwiKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudElkc1RvQWRkLnJldmVyc2UoKS5mb3JFYWNoKChlbGVtSWQpID0+IHtcbiAgICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtSWQpLCAoZWxlbSkgPT4gY29udGFpbmVyLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyYmVnaW5cIiwgZWxlbSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gbm9kZV9tb2R1bGVzL21vcnBoZG9tL2Rpc3QvbW9ycGhkb20tZXNtLmpzXG4gIHZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gMTE7XG4gIGZ1bmN0aW9uIG1vcnBoQXR0cnMoZnJvbU5vZGUsIHRvTm9kZSkge1xuICAgIHZhciB0b05vZGVBdHRycyA9IHRvTm9kZS5hdHRyaWJ1dGVzO1xuICAgIHZhciBhdHRyO1xuICAgIHZhciBhdHRyTmFtZTtcbiAgICB2YXIgYXR0ck5hbWVzcGFjZVVSSTtcbiAgICB2YXIgYXR0clZhbHVlO1xuICAgIHZhciBmcm9tVmFsdWU7XG4gICAgaWYgKHRvTm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBmcm9tTm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gdG9Ob2RlQXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGF0dHIgPSB0b05vZGVBdHRyc1tpXTtcbiAgICAgIGF0dHJOYW1lID0gYXR0ci5uYW1lO1xuICAgICAgYXR0ck5hbWVzcGFjZVVSSSA9IGF0dHIubmFtZXNwYWNlVVJJO1xuICAgICAgYXR0clZhbHVlID0gYXR0ci52YWx1ZTtcbiAgICAgIGlmIChhdHRyTmFtZXNwYWNlVVJJKSB7XG4gICAgICAgIGF0dHJOYW1lID0gYXR0ci5sb2NhbE5hbWUgfHwgYXR0ck5hbWU7XG4gICAgICAgIGZyb21WYWx1ZSA9IGZyb21Ob2RlLmdldEF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKTtcbiAgICAgICAgaWYgKGZyb21WYWx1ZSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgICAgaWYgKGF0dHIucHJlZml4ID09PSBcInhtbG5zXCIpIHtcbiAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0ci5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmcm9tTm9kZS5zZXRBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJvbVZhbHVlID0gZnJvbU5vZGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgaWYgKGZyb21WYWx1ZSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgICAgZnJvbU5vZGUuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBmcm9tTm9kZUF0dHJzID0gZnJvbU5vZGUuYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBkID0gZnJvbU5vZGVBdHRycy5sZW5ndGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgYXR0ciA9IGZyb21Ob2RlQXR0cnNbZF07XG4gICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTtcbiAgICAgIGF0dHJOYW1lc3BhY2VVUkkgPSBhdHRyLm5hbWVzcGFjZVVSSTtcbiAgICAgIGlmIChhdHRyTmFtZXNwYWNlVVJJKSB7XG4gICAgICAgIGF0dHJOYW1lID0gYXR0ci5sb2NhbE5hbWUgfHwgYXR0ck5hbWU7XG4gICAgICAgIGlmICghdG9Ob2RlLmhhc0F0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKSkge1xuICAgICAgICAgIGZyb21Ob2RlLnJlbW92ZUF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0b05vZGUuaGFzQXR0cmlidXRlKGF0dHJOYW1lKSkge1xuICAgICAgICAgIGZyb21Ob2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIHJhbmdlO1xuICB2YXIgTlNfWEhUTUwgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcbiAgdmFyIGRvYyA9IHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IHZvaWQgMCA6IGRvY3VtZW50O1xuICB2YXIgSEFTX1RFTVBMQVRFX1NVUFBPUlQgPSAhIWRvYyAmJiBcImNvbnRlbnRcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuICB2YXIgSEFTX1JBTkdFX1NVUFBPUlQgPSAhIWRvYyAmJiBkb2MuY3JlYXRlUmFuZ2UgJiYgXCJjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnRcIiBpbiBkb2MuY3JlYXRlUmFuZ2UoKTtcbiAgZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRGcm9tVGVtcGxhdGUoc3RyKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBzdHI7XG4gICAgcmV0dXJuIHRlbXBsYXRlLmNvbnRlbnQuY2hpbGROb2Rlc1swXTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVGcmFnbWVudEZyb21SYW5nZShzdHIpIHtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICByYW5nZSA9IGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZShkb2MuYm9keSk7XG4gICAgfVxuICAgIHZhciBmcmFnbWVudCA9IHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChzdHIpO1xuICAgIHJldHVybiBmcmFnbWVudC5jaGlsZE5vZGVzWzBdO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50RnJvbVdyYXAoc3RyKSB7XG4gICAgdmFyIGZyYWdtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIpO1xuICAgIGZyYWdtZW50LmlubmVySFRNTCA9IHN0cjtcbiAgICByZXR1cm4gZnJhZ21lbnQuY2hpbGROb2Rlc1swXTtcbiAgfVxuICBmdW5jdGlvbiB0b0VsZW1lbnQoc3RyKSB7XG4gICAgc3RyID0gc3RyLnRyaW0oKTtcbiAgICBpZiAoSEFTX1RFTVBMQVRFX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGcmFnbWVudEZyb21UZW1wbGF0ZShzdHIpO1xuICAgIH0gZWxzZSBpZiAoSEFTX1JBTkdFX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGcmFnbWVudEZyb21SYW5nZShzdHIpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRnJhZ21lbnRGcm9tV3JhcChzdHIpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbXBhcmVOb2RlTmFtZXMoZnJvbUVsLCB0b0VsKSB7XG4gICAgdmFyIGZyb21Ob2RlTmFtZSA9IGZyb21FbC5ub2RlTmFtZTtcbiAgICB2YXIgdG9Ob2RlTmFtZSA9IHRvRWwubm9kZU5hbWU7XG4gICAgdmFyIGZyb21Db2RlU3RhcnQsIHRvQ29kZVN0YXJ0O1xuICAgIGlmIChmcm9tTm9kZU5hbWUgPT09IHRvTm9kZU5hbWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmcm9tQ29kZVN0YXJ0ID0gZnJvbU5vZGVOYW1lLmNoYXJDb2RlQXQoMCk7XG4gICAgdG9Db2RlU3RhcnQgPSB0b05vZGVOYW1lLmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKGZyb21Db2RlU3RhcnQgPD0gOTAgJiYgdG9Db2RlU3RhcnQgPj0gOTcpIHtcbiAgICAgIHJldHVybiBmcm9tTm9kZU5hbWUgPT09IHRvTm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYgKHRvQ29kZVN0YXJ0IDw9IDkwICYmIGZyb21Db2RlU3RhcnQgPj0gOTcpIHtcbiAgICAgIHJldHVybiB0b05vZGVOYW1lID09PSBmcm9tTm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZSwgbmFtZXNwYWNlVVJJKSB7XG4gICAgcmV0dXJuICFuYW1lc3BhY2VVUkkgfHwgbmFtZXNwYWNlVVJJID09PSBOU19YSFRNTCA/IGRvYy5jcmVhdGVFbGVtZW50KG5hbWUpIDogZG9jLmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIG5hbWUpO1xuICB9XG4gIGZ1bmN0aW9uIG1vdmVDaGlsZHJlbihmcm9tRWwsIHRvRWwpIHtcbiAgICB2YXIgY3VyQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgIHZhciBuZXh0Q2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgIHRvRWwuYXBwZW5kQ2hpbGQoY3VyQ2hpbGQpO1xuICAgICAgY3VyQ2hpbGQgPSBuZXh0Q2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiB0b0VsO1xuICB9XG4gIGZ1bmN0aW9uIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCBuYW1lKSB7XG4gICAgaWYgKGZyb21FbFtuYW1lXSAhPT0gdG9FbFtuYW1lXSkge1xuICAgICAgZnJvbUVsW25hbWVdID0gdG9FbFtuYW1lXTtcbiAgICAgIGlmIChmcm9tRWxbbmFtZV0pIHtcbiAgICAgICAgZnJvbUVsLnNldEF0dHJpYnV0ZShuYW1lLCBcIlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBzcGVjaWFsRWxIYW5kbGVycyA9IHtcbiAgICBPUFRJT046IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgdmFyIHBhcmVudE5vZGUgPSBmcm9tRWwucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgIHZhciBwYXJlbnROYW1lID0gcGFyZW50Tm9kZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAocGFyZW50TmFtZSA9PT0gXCJPUFRHUk9VUFwiKSB7XG4gICAgICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICBwYXJlbnROYW1lID0gcGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudE5hbWUgPT09IFwiU0VMRUNUXCIgJiYgIXBhcmVudE5vZGUuaGFzQXR0cmlidXRlKFwibXVsdGlwbGVcIikpIHtcbiAgICAgICAgICBpZiAoZnJvbUVsLmhhc0F0dHJpYnV0ZShcInNlbGVjdGVkXCIpICYmICF0b0VsLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBmcm9tRWwuc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCBcInNlbGVjdGVkXCIpO1xuICAgIH0sXG4gICAgSU5QVVQ6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsIFwiY2hlY2tlZFwiKTtcbiAgICAgIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCBcImRpc2FibGVkXCIpO1xuICAgICAgaWYgKGZyb21FbC52YWx1ZSAhPT0gdG9FbC52YWx1ZSkge1xuICAgICAgICBmcm9tRWwudmFsdWUgPSB0b0VsLnZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKCF0b0VsLmhhc0F0dHJpYnV0ZShcInZhbHVlXCIpKSB7XG4gICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFRFWFRBUkVBOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IHRvRWwudmFsdWU7XG4gICAgICBpZiAoZnJvbUVsLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICBmcm9tRWwudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBmaXJzdENoaWxkID0gZnJvbUVsLmZpcnN0Q2hpbGQ7XG4gICAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSBmaXJzdENoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgaWYgKG9sZFZhbHVlID09IG5ld1ZhbHVlIHx8ICFuZXdWYWx1ZSAmJiBvbGRWYWx1ZSA9PSBmcm9tRWwucGxhY2Vob2xkZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFNFTEVDVDogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICBpZiAoIXRvRWwuaGFzQXR0cmlidXRlKFwibXVsdGlwbGVcIikpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgY3VyQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgdmFyIG9wdGdyb3VwO1xuICAgICAgICB2YXIgbm9kZU5hbWU7XG4gICAgICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICAgIG5vZGVOYW1lID0gY3VyQ2hpbGQubm9kZU5hbWUgJiYgY3VyQ2hpbGQubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICBpZiAobm9kZU5hbWUgPT09IFwiT1BUR1JPVVBcIikge1xuICAgICAgICAgICAgb3B0Z3JvdXAgPSBjdXJDaGlsZDtcbiAgICAgICAgICAgIGN1ckNoaWxkID0gb3B0Z3JvdXAuZmlyc3RDaGlsZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSBcIk9QVElPTlwiKSB7XG4gICAgICAgICAgICAgIGlmIChjdXJDaGlsZC5oYXNBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAoIWN1ckNoaWxkICYmIG9wdGdyb3VwKSB7XG4gICAgICAgICAgICAgIGN1ckNoaWxkID0gb3B0Z3JvdXAubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgIG9wdGdyb3VwID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnJvbUVsLnNlbGVjdGVkSW5kZXggPSBzZWxlY3RlZEluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIEVMRU1FTlRfTk9ERSA9IDE7XG4gIHZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFJDEgPSAxMTtcbiAgdmFyIFRFWFRfTk9ERSA9IDM7XG4gIHZhciBDT01NRU5UX05PREUgPSA4O1xuICBmdW5jdGlvbiBub29wKCkge1xuICB9XG4gIGZ1bmN0aW9uIGRlZmF1bHRHZXROb2RlS2V5KG5vZGUpIHtcbiAgICBpZiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKFwiaWRcIikgfHwgbm9kZS5pZDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbW9ycGhkb21GYWN0b3J5KG1vcnBoQXR0cnMyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1vcnBoZG9tMihmcm9tTm9kZSwgdG9Ob2RlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0b05vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGZyb21Ob2RlLm5vZGVOYW1lID09PSBcIiNkb2N1bWVudFwiIHx8IGZyb21Ob2RlLm5vZGVOYW1lID09PSBcIkhUTUxcIiB8fCBmcm9tTm9kZS5ub2RlTmFtZSA9PT0gXCJCT0RZXCIpIHtcbiAgICAgICAgICB2YXIgdG9Ob2RlSHRtbCA9IHRvTm9kZTtcbiAgICAgICAgICB0b05vZGUgPSBkb2MuY3JlYXRlRWxlbWVudChcImh0bWxcIik7XG4gICAgICAgICAgdG9Ob2RlLmlubmVySFRNTCA9IHRvTm9kZUh0bWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9Ob2RlID0gdG9FbGVtZW50KHRvTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBnZXROb2RlS2V5ID0gb3B0aW9ucy5nZXROb2RlS2V5IHx8IGRlZmF1bHRHZXROb2RlS2V5O1xuICAgICAgdmFyIG9uQmVmb3JlTm9kZUFkZGVkID0gb3B0aW9ucy5vbkJlZm9yZU5vZGVBZGRlZCB8fCBub29wO1xuICAgICAgdmFyIG9uTm9kZUFkZGVkID0gb3B0aW9ucy5vbk5vZGVBZGRlZCB8fCBub29wO1xuICAgICAgdmFyIG9uQmVmb3JlRWxVcGRhdGVkID0gb3B0aW9ucy5vbkJlZm9yZUVsVXBkYXRlZCB8fCBub29wO1xuICAgICAgdmFyIG9uRWxVcGRhdGVkID0gb3B0aW9ucy5vbkVsVXBkYXRlZCB8fCBub29wO1xuICAgICAgdmFyIG9uQmVmb3JlTm9kZURpc2NhcmRlZCA9IG9wdGlvbnMub25CZWZvcmVOb2RlRGlzY2FyZGVkIHx8IG5vb3A7XG4gICAgICB2YXIgb25Ob2RlRGlzY2FyZGVkID0gb3B0aW9ucy5vbk5vZGVEaXNjYXJkZWQgfHwgbm9vcDtcbiAgICAgIHZhciBvbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkID0gb3B0aW9ucy5vbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkIHx8IG5vb3A7XG4gICAgICB2YXIgY2hpbGRyZW5Pbmx5ID0gb3B0aW9ucy5jaGlsZHJlbk9ubHkgPT09IHRydWU7XG4gICAgICB2YXIgZnJvbU5vZGVzTG9va3VwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHZhciBrZXllZFJlbW92YWxMaXN0ID0gW107XG4gICAgICBmdW5jdGlvbiBhZGRLZXllZFJlbW92YWwoa2V5KSB7XG4gICAgICAgIGtleWVkUmVtb3ZhbExpc3QucHVzaChrZXkpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMobm9kZSwgc2tpcEtleWVkTm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHZhciBjdXJDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoc2tpcEtleWVkTm9kZXMgJiYgKGtleSA9IGdldE5vZGVLZXkoY3VyQ2hpbGQpKSkge1xuICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoa2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9uTm9kZURpc2NhcmRlZChjdXJDaGlsZCk7XG4gICAgICAgICAgICAgIGlmIChjdXJDaGlsZC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMoY3VyQ2hpbGQsIHNraXBLZXllZE5vZGVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSwgcGFyZW50Tm9kZSwgc2tpcEtleWVkTm9kZXMpIHtcbiAgICAgICAgaWYgKG9uQmVmb3JlTm9kZURpc2NhcmRlZChub2RlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIG9uTm9kZURpc2NhcmRlZChub2RlKTtcbiAgICAgICAgd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMobm9kZSwgc2tpcEtleWVkTm9kZXMpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaW5kZXhUcmVlKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFJDEpIHtcbiAgICAgICAgICB2YXIgY3VyQ2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgd2hpbGUgKGN1ckNoaWxkKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShjdXJDaGlsZCk7XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgIGZyb21Ob2Rlc0xvb2t1cFtrZXldID0gY3VyQ2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleFRyZWUoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluZGV4VHJlZShmcm9tTm9kZSk7XG4gICAgICBmdW5jdGlvbiBoYW5kbGVOb2RlQWRkZWQoZWwpIHtcbiAgICAgICAgb25Ob2RlQWRkZWQoZWwpO1xuICAgICAgICB2YXIgY3VyQ2hpbGQgPSBlbC5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShjdXJDaGlsZCk7XG4gICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgdmFyIHVubWF0Y2hlZEZyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtrZXldO1xuICAgICAgICAgICAgaWYgKHVubWF0Y2hlZEZyb21FbCAmJiBjb21wYXJlTm9kZU5hbWVzKGN1ckNoaWxkLCB1bm1hdGNoZWRGcm9tRWwpKSB7XG4gICAgICAgICAgICAgIGN1ckNoaWxkLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHVubWF0Y2hlZEZyb21FbCwgY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICBtb3JwaEVsKHVubWF0Y2hlZEZyb21FbCwgY3VyQ2hpbGQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaGFuZGxlTm9kZUFkZGVkKGN1ckNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlTm9kZUFkZGVkKGN1ckNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VyQ2hpbGQgPSBuZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY2xlYW51cEZyb21FbChmcm9tRWwsIGN1ckZyb21Ob2RlQ2hpbGQsIGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgIHdoaWxlIChjdXJGcm9tTm9kZUNoaWxkKSB7XG4gICAgICAgICAgdmFyIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgaWYgKGN1ckZyb21Ob2RlS2V5ID0gZ2V0Tm9kZUtleShjdXJGcm9tTm9kZUNoaWxkKSkge1xuICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtb3JwaEVsKGZyb21FbCwgdG9FbCwgY2hpbGRyZW5Pbmx5Mikge1xuICAgICAgICB2YXIgdG9FbEtleSA9IGdldE5vZGVLZXkodG9FbCk7XG4gICAgICAgIGlmICh0b0VsS2V5KSB7XG4gICAgICAgICAgZGVsZXRlIGZyb21Ob2Rlc0xvb2t1cFt0b0VsS2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoaWxkcmVuT25seTIpIHtcbiAgICAgICAgICBpZiAob25CZWZvcmVFbFVwZGF0ZWQoZnJvbUVsLCB0b0VsKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW9ycGhBdHRyczIoZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgICBvbkVsVXBkYXRlZChmcm9tRWwpO1xuICAgICAgICAgIGlmIChvbkJlZm9yZUVsQ2hpbGRyZW5VcGRhdGVkKGZyb21FbCwgdG9FbCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tRWwubm9kZU5hbWUgIT09IFwiVEVYVEFSRUFcIikge1xuICAgICAgICAgIG1vcnBoQ2hpbGRyZW4oZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGVjaWFsRWxIYW5kbGVycy5URVhUQVJFQShmcm9tRWwsIHRvRWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBtb3JwaENoaWxkcmVuKGZyb21FbCwgdG9FbCkge1xuICAgICAgICB2YXIgY3VyVG9Ob2RlQ2hpbGQgPSB0b0VsLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHZhciBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbUVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHZhciBjdXJUb05vZGVLZXk7XG4gICAgICAgIHZhciBjdXJGcm9tTm9kZUtleTtcbiAgICAgICAgdmFyIGZyb21OZXh0U2libGluZztcbiAgICAgICAgdmFyIHRvTmV4dFNpYmxpbmc7XG4gICAgICAgIHZhciBtYXRjaGluZ0Zyb21FbDtcbiAgICAgICAgb3V0ZXI6XG4gICAgICAgICAgd2hpbGUgKGN1clRvTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICB0b05leHRTaWJsaW5nID0gY3VyVG9Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBjdXJUb05vZGVLZXkgPSBnZXROb2RlS2V5KGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgIHdoaWxlIChjdXJGcm9tTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICAgIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgIGlmIChjdXJUb05vZGVDaGlsZC5pc1NhbWVOb2RlICYmIGN1clRvTm9kZUNoaWxkLmlzU2FtZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IHRvTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJGcm9tTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyRnJvbU5vZGVDaGlsZCk7XG4gICAgICAgICAgICAgIHZhciBjdXJGcm9tTm9kZVR5cGUgPSBjdXJGcm9tTm9kZUNoaWxkLm5vZGVUeXBlO1xuICAgICAgICAgICAgICB2YXIgaXNDb21wYXRpYmxlID0gdm9pZCAwO1xuICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSBjdXJUb05vZGVDaGlsZC5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5ICE9PSBjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ0Zyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtjdXJUb05vZGVLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbU5leHRTaWJsaW5nID09PSBtYXRjaGluZ0Zyb21FbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21FbC5pbnNlcnRCZWZvcmUobWF0Y2hpbmdGcm9tRWwsIGN1ckZyb21Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gbWF0Y2hpbmdGcm9tRWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGlzQ29tcGF0aWJsZSAhPT0gZmFsc2UgJiYgY29tcGFyZU5vZGVOYW1lcyhjdXJGcm9tTm9kZUNoaWxkLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vcnBoRWwoY3VyRnJvbU5vZGVDaGlsZCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSBURVhUX05PREUgfHwgY3VyRnJvbU5vZGVUeXBlID09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUNoaWxkLm5vZGVWYWx1ZSAhPT0gY3VyVG9Ob2RlQ2hpbGQubm9kZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQubm9kZVZhbHVlID0gY3VyVG9Ob2RlQ2hpbGQubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQsIGZyb21FbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJUb05vZGVLZXkgJiYgKG1hdGNoaW5nRnJvbUVsID0gZnJvbU5vZGVzTG9va3VwW2N1clRvTm9kZUtleV0pICYmIGNvbXBhcmVOb2RlTmFtZXMobWF0Y2hpbmdGcm9tRWwsIGN1clRvTm9kZUNoaWxkKSkge1xuICAgICAgICAgICAgICBmcm9tRWwuYXBwZW5kQ2hpbGQobWF0Y2hpbmdGcm9tRWwpO1xuICAgICAgICAgICAgICBtb3JwaEVsKG1hdGNoaW5nRnJvbUVsLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgb25CZWZvcmVOb2RlQWRkZWRSZXN1bHQgPSBvbkJlZm9yZU5vZGVBZGRlZChjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgIGlmIChvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAob25CZWZvcmVOb2RlQWRkZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gb25CZWZvcmVOb2RlQWRkZWRSZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVDaGlsZC5hY3R1YWxpemUpIHtcbiAgICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gY3VyVG9Ob2RlQ2hpbGQuYWN0dWFsaXplKGZyb21FbC5vd25lckRvY3VtZW50IHx8IGRvYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZyb21FbC5hcHBlbmRDaGlsZChjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlTm9kZUFkZGVkKGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICB9XG4gICAgICAgIGNsZWFudXBGcm9tRWwoZnJvbUVsLCBjdXJGcm9tTm9kZUNoaWxkLCBjdXJGcm9tTm9kZUtleSk7XG4gICAgICAgIHZhciBzcGVjaWFsRWxIYW5kbGVyID0gc3BlY2lhbEVsSGFuZGxlcnNbZnJvbUVsLm5vZGVOYW1lXTtcbiAgICAgICAgaWYgKHNwZWNpYWxFbEhhbmRsZXIpIHtcbiAgICAgICAgICBzcGVjaWFsRWxIYW5kbGVyKGZyb21FbCwgdG9FbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBtb3JwaGVkTm9kZSA9IGZyb21Ob2RlO1xuICAgICAgdmFyIG1vcnBoZWROb2RlVHlwZSA9IG1vcnBoZWROb2RlLm5vZGVUeXBlO1xuICAgICAgdmFyIHRvTm9kZVR5cGUgPSB0b05vZGUubm9kZVR5cGU7XG4gICAgICBpZiAoIWNoaWxkcmVuT25seSkge1xuICAgICAgICBpZiAobW9ycGhlZE5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBpZiAodG9Ob2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICBpZiAoIWNvbXBhcmVOb2RlTmFtZXMoZnJvbU5vZGUsIHRvTm9kZSkpIHtcbiAgICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKGZyb21Ob2RlKTtcbiAgICAgICAgICAgICAgbW9ycGhlZE5vZGUgPSBtb3ZlQ2hpbGRyZW4oZnJvbU5vZGUsIGNyZWF0ZUVsZW1lbnROUyh0b05vZGUubm9kZU5hbWUsIHRvTm9kZS5uYW1lc3BhY2VVUkkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9ycGhlZE5vZGUgPSB0b05vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1vcnBoZWROb2RlVHlwZSA9PT0gVEVYVF9OT0RFIHx8IG1vcnBoZWROb2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgICAgaWYgKHRvTm9kZVR5cGUgPT09IG1vcnBoZWROb2RlVHlwZSkge1xuICAgICAgICAgICAgaWYgKG1vcnBoZWROb2RlLm5vZGVWYWx1ZSAhPT0gdG9Ob2RlLm5vZGVWYWx1ZSkge1xuICAgICAgICAgICAgICBtb3JwaGVkTm9kZS5ub2RlVmFsdWUgPSB0b05vZGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1vcnBoZWROb2RlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb3JwaGVkTm9kZSA9IHRvTm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtb3JwaGVkTm9kZSA9PT0gdG9Ob2RlKSB7XG4gICAgICAgIG9uTm9kZURpc2NhcmRlZChmcm9tTm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodG9Ob2RlLmlzU2FtZU5vZGUgJiYgdG9Ob2RlLmlzU2FtZU5vZGUobW9ycGhlZE5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1vcnBoRWwobW9ycGhlZE5vZGUsIHRvTm9kZSwgY2hpbGRyZW5Pbmx5KTtcbiAgICAgICAgaWYgKGtleWVkUmVtb3ZhbExpc3QpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2V5ZWRSZW1vdmFsTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGVsVG9SZW1vdmUgPSBmcm9tTm9kZXNMb29rdXBba2V5ZWRSZW1vdmFsTGlzdFtpXV07XG4gICAgICAgICAgICBpZiAoZWxUb1JlbW92ZSkge1xuICAgICAgICAgICAgICByZW1vdmVOb2RlKGVsVG9SZW1vdmUsIGVsVG9SZW1vdmUucGFyZW50Tm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjaGlsZHJlbk9ubHkgJiYgbW9ycGhlZE5vZGUgIT09IGZyb21Ob2RlICYmIGZyb21Ob2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKG1vcnBoZWROb2RlLmFjdHVhbGl6ZSkge1xuICAgICAgICAgIG1vcnBoZWROb2RlID0gbW9ycGhlZE5vZGUuYWN0dWFsaXplKGZyb21Ob2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jKTtcbiAgICAgICAgfVxuICAgICAgICBmcm9tTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChtb3JwaGVkTm9kZSwgZnJvbU5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1vcnBoZWROb2RlO1xuICAgIH07XG4gIH1cbiAgdmFyIG1vcnBoZG9tID0gbW9ycGhkb21GYWN0b3J5KG1vcnBoQXR0cnMpO1xuICB2YXIgbW9ycGhkb21fZXNtX2RlZmF1bHQgPSBtb3JwaGRvbTtcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy9kb21fcGF0Y2guanNcbiAgdmFyIERPTVBhdGNoID0gY2xhc3Mge1xuICAgIHN0YXRpYyBwYXRjaEVsKGZyb21FbCwgdG9FbCwgYWN0aXZlRWxlbWVudCkge1xuICAgICAgbW9ycGhkb21fZXNtX2RlZmF1bHQoZnJvbUVsLCB0b0VsLCB7XG4gICAgICAgIGNoaWxkcmVuT25seTogZmFsc2UsXG4gICAgICAgIG9uQmVmb3JlRWxVcGRhdGVkOiAoZnJvbUVsMiwgdG9FbDIpID0+IHtcbiAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVFbGVtZW50LmlzU2FtZU5vZGUoZnJvbUVsMikgJiYgZG9tX2RlZmF1bHQuaXNGb3JtSW5wdXQoZnJvbUVsMikpIHtcbiAgICAgICAgICAgIGRvbV9kZWZhdWx0Lm1lcmdlRm9jdXNlZElucHV0KGZyb21FbDIsIHRvRWwyKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBjb250YWluZXIsIGlkLCBodG1sLCB0YXJnZXRDSUQpIHtcbiAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQgPSB2aWV3LmxpdmVTb2NrZXQ7XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgIHRoaXMucm9vdElEID0gdmlldy5yb290LmlkO1xuICAgICAgdGhpcy5odG1sID0gaHRtbDtcbiAgICAgIHRoaXMudGFyZ2V0Q0lEID0gdGFyZ2V0Q0lEO1xuICAgICAgdGhpcy5jaWRQYXRjaCA9IGlzQ2lkKHRoaXMudGFyZ2V0Q0lEKTtcbiAgICAgIHRoaXMuY2FsbGJhY2tzID0ge1xuICAgICAgICBiZWZvcmVhZGRlZDogW10sXG4gICAgICAgIGJlZm9yZXVwZGF0ZWQ6IFtdLFxuICAgICAgICBiZWZvcmVwaHhDaGlsZEFkZGVkOiBbXSxcbiAgICAgICAgYWZ0ZXJhZGRlZDogW10sXG4gICAgICAgIGFmdGVydXBkYXRlZDogW10sXG4gICAgICAgIGFmdGVyZGlzY2FyZGVkOiBbXSxcbiAgICAgICAgYWZ0ZXJwaHhDaGlsZEFkZGVkOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgYmVmb3JlKGtpbmQsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrc1tgYmVmb3JlJHtraW5kfWBdLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgICBhZnRlcihraW5kLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5jYWxsYmFja3NbYGFmdGVyJHtraW5kfWBdLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgICB0cmFja0JlZm9yZShraW5kLCAuLi5hcmdzKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrc1tgYmVmb3JlJHtraW5kfWBdLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayguLi5hcmdzKSk7XG4gICAgfVxuICAgIHRyYWNrQWZ0ZXIoa2luZCwgLi4uYXJncykge1xuICAgICAgdGhpcy5jYWxsYmFja3NbYGFmdGVyJHtraW5kfWBdLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjayguLi5hcmdzKSk7XG4gICAgfVxuICAgIG1hcmtQcnVuYWJsZUNvbnRlbnRGb3JSZW1vdmFsKCkge1xuICAgICAgZG9tX2RlZmF1bHQuYWxsKHRoaXMuY29udGFpbmVyLCBcIltwaHgtdXBkYXRlPWFwcGVuZF0gPiAqLCBbcGh4LXVwZGF0ZT1wcmVwZW5kXSA+ICpcIiwgKGVsKSA9PiB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfUkVNT1ZFLCBcIlwiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBwZXJmb3JtKCkge1xuICAgICAgbGV0IHsgdmlldywgbGl2ZVNvY2tldCwgY29udGFpbmVyLCBodG1sIH0gPSB0aGlzO1xuICAgICAgbGV0IHRhcmdldENvbnRhaW5lciA9IHRoaXMuaXNDSURQYXRjaCgpID8gdGhpcy50YXJnZXRDSURDb250YWluZXIoaHRtbCkgOiBjb250YWluZXI7XG4gICAgICBpZiAodGhpcy5pc0NJRFBhdGNoKCkgJiYgIXRhcmdldENvbnRhaW5lcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgZm9jdXNlZCA9IGxpdmVTb2NrZXQuZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgICAgbGV0IHsgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCB9ID0gZm9jdXNlZCAmJiBkb21fZGVmYXVsdC5oYXNTZWxlY3Rpb25SYW5nZShmb2N1c2VkKSA/IGZvY3VzZWQgOiB7fTtcbiAgICAgIGxldCBwaHhVcGRhdGUgPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX1VQREFURSk7XG4gICAgICBsZXQgcGh4RmVlZGJhY2tGb3IgPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX0ZFRURCQUNLX0ZPUik7XG4gICAgICBsZXQgZGlzYWJsZVdpdGggPSBsaXZlU29ja2V0LmJpbmRpbmcoUEhYX0RJU0FCTEVfV0lUSCk7XG4gICAgICBsZXQgcGh4VHJpZ2dlckV4dGVybmFsID0gbGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9UUklHR0VSX0FDVElPTik7XG4gICAgICBsZXQgYWRkZWQgPSBbXTtcbiAgICAgIGxldCB1cGRhdGVzID0gW107XG4gICAgICBsZXQgYXBwZW5kUHJlcGVuZFVwZGF0ZXMgPSBbXTtcbiAgICAgIGxldCBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBudWxsO1xuICAgICAgbGV0IGRpZmZIVE1MID0gbGl2ZVNvY2tldC50aW1lKFwicHJlbW9ycGggY29udGFpbmVyIHByZXBcIiwgKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZERpZmZIVE1MKGNvbnRhaW5lciwgaHRtbCwgcGh4VXBkYXRlLCB0YXJnZXRDb250YWluZXIpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnRyYWNrQmVmb3JlKFwiYWRkZWRcIiwgY29udGFpbmVyKTtcbiAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJ1cGRhdGVkXCIsIGNvbnRhaW5lciwgY29udGFpbmVyKTtcbiAgICAgIGxpdmVTb2NrZXQudGltZShcIm1vcnBoZG9tXCIsICgpID0+IHtcbiAgICAgICAgbW9ycGhkb21fZXNtX2RlZmF1bHQodGFyZ2V0Q29udGFpbmVyLCBkaWZmSFRNTCwge1xuICAgICAgICAgIGNoaWxkcmVuT25seTogdGFyZ2V0Q29udGFpbmVyLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSA9PT0gbnVsbCxcbiAgICAgICAgICBnZXROb2RlS2V5OiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRvbV9kZWZhdWx0LmlzUGh4RGVzdHJveWVkKG5vZGUpID8gbnVsbCA6IG5vZGUuaWQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkJlZm9yZU5vZGVBZGRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwiYWRkZWRcIiwgZWwpO1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25Ob2RlQWRkZWQ6IChlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRvbV9kZWZhdWx0LmlzTm93VHJpZ2dlckZvcm1FeHRlcm5hbChlbCwgcGh4VHJpZ2dlckV4dGVybmFsKSkge1xuICAgICAgICAgICAgICBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbV9kZWZhdWx0LmRpc2NhcmRFcnJvcih0YXJnZXRDb250YWluZXIsIGVsLCBwaHhGZWVkYmFja0Zvcik7XG4gICAgICAgICAgICBpZiAoZG9tX2RlZmF1bHQuaXNQaHhDaGlsZChlbCkgJiYgdmlldy5vd25zRWxlbWVudChlbCkpIHtcbiAgICAgICAgICAgICAgdGhpcy50cmFja0FmdGVyKFwicGh4Q2hpbGRBZGRlZFwiLCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRlZC5wdXNoKGVsKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uTm9kZURpc2NhcmRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9tX2RlZmF1bHQuaXNQaHhDaGlsZChlbCkpIHtcbiAgICAgICAgICAgICAgbGl2ZVNvY2tldC5kZXN0cm95Vmlld0J5RWwoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFja0FmdGVyKFwiZGlzY2FyZGVkXCIsIGVsKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uQmVmb3JlTm9kZURpc2NhcmRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfUkVNT1ZFKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbC5wYXJlbnROb2RlICE9PSBudWxsICYmIGRvbV9kZWZhdWx0LmlzUGh4VXBkYXRlKGVsLnBhcmVudE5vZGUsIHBoeFVwZGF0ZSwgW1wiYXBwZW5kXCIsIFwicHJlcGVuZFwiXSkgJiYgZWwuaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2tpcENJRFNpYmxpbmcoZWwpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25FbFVwZGF0ZWQ6IChlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRvbV9kZWZhdWx0LmlzTm93VHJpZ2dlckZvcm1FeHRlcm5hbChlbCwgcGh4VHJpZ2dlckV4dGVybmFsKSkge1xuICAgICAgICAgICAgICBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZXMucHVzaChlbCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkJlZm9yZUVsVXBkYXRlZDogKGZyb21FbCwgdG9FbCkgPT4ge1xuICAgICAgICAgICAgZG9tX2RlZmF1bHQuY2xlYW5DaGlsZE5vZGVzKHRvRWwsIHBoeFVwZGF0ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5za2lwQ0lEU2libGluZyh0b0VsKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZG9tX2RlZmF1bHQuaXNJZ25vcmVkKGZyb21FbCwgcGh4VXBkYXRlKSkge1xuICAgICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgICAgICBkb21fZGVmYXVsdC5tZXJnZUF0dHJzKGZyb21FbCwgdG9FbCwgeyBpc0lnbm9yZWQ6IHRydWUgfSk7XG4gICAgICAgICAgICAgIHVwZGF0ZXMucHVzaChmcm9tRWwpO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJvbUVsLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgKGZyb21FbC52YWxpZGl0eSAmJiBmcm9tRWwudmFsaWRpdHkuYmFkSW5wdXQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZG9tX2RlZmF1bHQuc3luY1BlbmRpbmdSZWYoZnJvbUVsLCB0b0VsLCBkaXNhYmxlV2l0aCkpIHtcbiAgICAgICAgICAgICAgaWYgKGRvbV9kZWZhdWx0LmlzVXBsb2FkSW5wdXQoZnJvbUVsKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tCZWZvcmUoXCJ1cGRhdGVkXCIsIGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlcy5wdXNoKGZyb21FbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRvbV9kZWZhdWx0LmlzUGh4Q2hpbGQodG9FbCkpIHtcbiAgICAgICAgICAgICAgbGV0IHByZXZTZXNzaW9uID0gZnJvbUVsLmdldEF0dHJpYnV0ZShQSFhfU0VTU0lPTik7XG4gICAgICAgICAgICAgIGRvbV9kZWZhdWx0Lm1lcmdlQXR0cnMoZnJvbUVsLCB0b0VsLCB7IGV4Y2x1ZGU6IFtQSFhfU1RBVElDXSB9KTtcbiAgICAgICAgICAgICAgaWYgKHByZXZTZXNzaW9uICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgZnJvbUVsLnNldEF0dHJpYnV0ZShQSFhfU0VTU0lPTiwgcHJldlNlc3Npb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQsIHRoaXMucm9vdElEKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tX2RlZmF1bHQuY29weVByaXZhdGVzKHRvRWwsIGZyb21FbCk7XG4gICAgICAgICAgICBkb21fZGVmYXVsdC5kaXNjYXJkRXJyb3IodGFyZ2V0Q29udGFpbmVyLCB0b0VsLCBwaHhGZWVkYmFja0Zvcik7XG4gICAgICAgICAgICBkb21fZGVmYXVsdC5zeW5jUHJvcHNUb0F0dHJzKHRvRWwpO1xuICAgICAgICAgICAgbGV0IGlzRm9jdXNlZEZvcm1FbCA9IGZvY3VzZWQgJiYgZnJvbUVsLmlzU2FtZU5vZGUoZm9jdXNlZCkgJiYgZG9tX2RlZmF1bHQuaXNGb3JtSW5wdXQoZnJvbUVsKTtcbiAgICAgICAgICAgIGlmIChpc0ZvY3VzZWRGb3JtRWwgJiYgIXRoaXMuZm9yY2VGb2N1c2VkU2VsZWN0VXBkYXRlKGZyb21FbCwgdG9FbCkpIHtcbiAgICAgICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgICAgICAgZG9tX2RlZmF1bHQubWVyZ2VGb2N1c2VkSW5wdXQoZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgICAgICAgZG9tX2RlZmF1bHQuc3luY0F0dHJzVG9Qcm9wcyhmcm9tRWwpO1xuICAgICAgICAgICAgICB1cGRhdGVzLnB1c2goZnJvbUVsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGRvbV9kZWZhdWx0LmlzUGh4VXBkYXRlKHRvRWwsIHBoeFVwZGF0ZSwgW1wiYXBwZW5kXCIsIFwicHJlcGVuZFwiXSkpIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRQcmVwZW5kVXBkYXRlcy5wdXNoKG5ldyBET01Qb3N0TW9ycGhSZXN0b3Jlcihmcm9tRWwsIHRvRWwsIHRvRWwuZ2V0QXR0cmlidXRlKHBoeFVwZGF0ZSkpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkb21fZGVmYXVsdC5zeW5jQXR0cnNUb1Byb3BzKHRvRWwpO1xuICAgICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBpZiAobGl2ZVNvY2tldC5pc0RlYnVnRW5hYmxlZCgpKSB7XG4gICAgICAgIGRldGVjdER1cGxpY2F0ZUlkcygpO1xuICAgICAgfVxuICAgICAgaWYgKGFwcGVuZFByZXBlbmRVcGRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGl2ZVNvY2tldC50aW1lKFwicG9zdC1tb3JwaCBhcHBlbmQvcHJlcGVuZCByZXN0b3JhdGlvblwiLCAoKSA9PiB7XG4gICAgICAgICAgYXBwZW5kUHJlcGVuZFVwZGF0ZXMuZm9yRWFjaCgodXBkYXRlKSA9PiB1cGRhdGUucGVyZm9ybSgpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsaXZlU29ja2V0LnNpbGVuY2VFdmVudHMoKCkgPT4gZG9tX2RlZmF1bHQucmVzdG9yZUZvY3VzKGZvY3VzZWQsIHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpKTtcbiAgICAgIGRvbV9kZWZhdWx0LmRpc3BhdGNoRXZlbnQoZG9jdW1lbnQsIFwicGh4OnVwZGF0ZVwiKTtcbiAgICAgIGFkZGVkLmZvckVhY2goKGVsKSA9PiB0aGlzLnRyYWNrQWZ0ZXIoXCJhZGRlZFwiLCBlbCkpO1xuICAgICAgdXBkYXRlcy5mb3JFYWNoKChlbCkgPT4gdGhpcy50cmFja0FmdGVyKFwidXBkYXRlZFwiLCBlbCkpO1xuICAgICAgaWYgKGV4dGVybmFsRm9ybVRyaWdnZXJlZCkge1xuICAgICAgICBsaXZlU29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkLnN1Ym1pdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvcmNlRm9jdXNlZFNlbGVjdFVwZGF0ZShmcm9tRWwsIHRvRWwpIHtcbiAgICAgIGxldCBpc1NlbGVjdCA9IFtcInNlbGVjdFwiLCBcInNlbGVjdC1vbmVcIiwgXCJzZWxlY3QtbXVsdGlwbGVcIl0uZmluZCgodCkgPT4gdCA9PT0gZnJvbUVsLnR5cGUpO1xuICAgICAgcmV0dXJuIGZyb21FbC5tdWx0aXBsZSA9PT0gdHJ1ZSB8fCBpc1NlbGVjdCAmJiBmcm9tRWwuaW5uZXJIVE1MICE9IHRvRWwuaW5uZXJIVE1MO1xuICAgIH1cbiAgICBpc0NJRFBhdGNoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2lkUGF0Y2g7XG4gICAgfVxuICAgIHNraXBDSURTaWJsaW5nKGVsKSB7XG4gICAgICByZXR1cm4gZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfU0tJUCkgIT09IG51bGw7XG4gICAgfVxuICAgIHRhcmdldENJRENvbnRhaW5lcihodG1sKSB7XG4gICAgICBpZiAoIXRoaXMuaXNDSURQYXRjaCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBbZmlyc3QsIC4uLnJlc3RdID0gZG9tX2RlZmF1bHQuZmluZENvbXBvbmVudE5vZGVMaXN0KHRoaXMuY29udGFpbmVyLCB0aGlzLnRhcmdldENJRCk7XG4gICAgICBpZiAocmVzdC5sZW5ndGggPT09IDAgJiYgZG9tX2RlZmF1bHQuY2hpbGROb2RlTGVuZ3RoKGh0bWwpID09PSAxKSB7XG4gICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmaXJzdCAmJiBmaXJzdC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBidWlsZERpZmZIVE1MKGNvbnRhaW5lciwgaHRtbCwgcGh4VXBkYXRlLCB0YXJnZXRDb250YWluZXIpIHtcbiAgICAgIGxldCBpc0NJRFBhdGNoID0gdGhpcy5pc0NJRFBhdGNoKCk7XG4gICAgICBsZXQgaXNDSURXaXRoU2luZ2xlUm9vdCA9IGlzQ0lEUGF0Y2ggJiYgdGFyZ2V0Q29udGFpbmVyLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSA9PT0gdGhpcy50YXJnZXRDSUQudG9TdHJpbmcoKTtcbiAgICAgIGlmICghaXNDSURQYXRjaCB8fCBpc0NJRFdpdGhTaW5nbGVSb290KSB7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGRpZmZDb250YWluZXIgPSBudWxsO1xuICAgICAgICBsZXQgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG4gICAgICAgIGRpZmZDb250YWluZXIgPSBkb21fZGVmYXVsdC5jbG9uZU5vZGUodGFyZ2V0Q29udGFpbmVyKTtcbiAgICAgICAgbGV0IFtmaXJzdENvbXBvbmVudCwgLi4ucmVzdF0gPSBkb21fZGVmYXVsdC5maW5kQ29tcG9uZW50Tm9kZUxpc3QoZGlmZkNvbnRhaW5lciwgdGhpcy50YXJnZXRDSUQpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgICByZXN0LmZvckVhY2goKGVsKSA9PiBlbC5yZW1vdmUoKSk7XG4gICAgICAgIEFycmF5LmZyb20oZGlmZkNvbnRhaW5lci5jaGlsZE5vZGVzKS5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgIGlmIChjaGlsZC5pZCAmJiBjaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgY2hpbGQuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpICE9PSB0aGlzLnRhcmdldENJRC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoUEhYX1NLSVAsIFwiXCIpO1xuICAgICAgICAgICAgY2hpbGQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBBcnJheS5mcm9tKHRlbXBsYXRlLmNvbnRlbnQuY2hpbGROb2RlcykuZm9yRWFjaCgoZWwpID0+IGRpZmZDb250YWluZXIuaW5zZXJ0QmVmb3JlKGVsLCBmaXJzdENvbXBvbmVudCkpO1xuICAgICAgICBmaXJzdENvbXBvbmVudC5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuIGRpZmZDb250YWluZXIub3V0ZXJIVE1MO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy9yZW5kZXJlZC5qc1xuICB2YXIgUmVuZGVyZWQgPSBjbGFzcyB7XG4gICAgc3RhdGljIGV4dHJhY3QoZGlmZikge1xuICAgICAgbGV0IHsgW1JFUExZXTogcmVwbHksIFtFVkVOVFNdOiBldmVudHMsIFtUSVRMRV06IHRpdGxlIH0gPSBkaWZmO1xuICAgICAgZGVsZXRlIGRpZmZbUkVQTFldO1xuICAgICAgZGVsZXRlIGRpZmZbRVZFTlRTXTtcbiAgICAgIGRlbGV0ZSBkaWZmW1RJVExFXTtcbiAgICAgIHJldHVybiB7IGRpZmYsIHRpdGxlLCByZXBseTogcmVwbHkgfHwgbnVsbCwgZXZlbnRzOiBldmVudHMgfHwgW10gfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iodmlld0lkLCByZW5kZXJlZCkge1xuICAgICAgdGhpcy52aWV3SWQgPSB2aWV3SWQ7XG4gICAgICB0aGlzLnJlbmRlcmVkID0ge307XG4gICAgICB0aGlzLm1lcmdlRGlmZihyZW5kZXJlZCk7XG4gICAgfVxuICAgIHBhcmVudFZpZXdJZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpZXdJZDtcbiAgICB9XG4gICAgdG9TdHJpbmcob25seUNpZHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlY3Vyc2l2ZVRvU3RyaW5nKHRoaXMucmVuZGVyZWQsIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10sIG9ubHlDaWRzKTtcbiAgICB9XG4gICAgcmVjdXJzaXZlVG9TdHJpbmcocmVuZGVyZWQsIGNvbXBvbmVudHMgPSByZW5kZXJlZFtDT01QT05FTlRTXSwgb25seUNpZHMpIHtcbiAgICAgIG9ubHlDaWRzID0gb25seUNpZHMgPyBuZXcgU2V0KG9ubHlDaWRzKSA6IG51bGw7XG4gICAgICBsZXQgb3V0cHV0ID0geyBidWZmZXI6IFwiXCIsIGNvbXBvbmVudHMsIG9ubHlDaWRzIH07XG4gICAgICB0aGlzLnRvT3V0cHV0QnVmZmVyKHJlbmRlcmVkLCBvdXRwdXQpO1xuICAgICAgcmV0dXJuIG91dHB1dC5idWZmZXI7XG4gICAgfVxuICAgIGNvbXBvbmVudENJRHMoZGlmZikge1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGRpZmZbQ09NUE9ORU5UU10gfHwge30pLm1hcCgoaSkgPT4gcGFyc2VJbnQoaSkpO1xuICAgIH1cbiAgICBpc0NvbXBvbmVudE9ubHlEaWZmKGRpZmYpIHtcbiAgICAgIGlmICghZGlmZltDT01QT05FTlRTXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoZGlmZikubGVuZ3RoID09PSAxO1xuICAgIH1cbiAgICBnZXRDb21wb25lbnQoZGlmZiwgY2lkKSB7XG4gICAgICByZXR1cm4gZGlmZltDT01QT05FTlRTXVtjaWRdO1xuICAgIH1cbiAgICBtZXJnZURpZmYoZGlmZikge1xuICAgICAgbGV0IG5ld2MgPSBkaWZmW0NPTVBPTkVOVFNdO1xuICAgICAgbGV0IGNhY2hlID0ge307XG4gICAgICBkZWxldGUgZGlmZltDT01QT05FTlRTXTtcbiAgICAgIHRoaXMucmVuZGVyZWQgPSB0aGlzLm11dGFibGVNZXJnZSh0aGlzLnJlbmRlcmVkLCBkaWZmKTtcbiAgICAgIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10gPSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdIHx8IHt9O1xuICAgICAgaWYgKG5ld2MpIHtcbiAgICAgICAgbGV0IG9sZGMgPSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdO1xuICAgICAgICBmb3IgKGxldCBjaWQgaW4gbmV3Yykge1xuICAgICAgICAgIG5ld2NbY2lkXSA9IHRoaXMuY2FjaGVkRmluZENvbXBvbmVudChjaWQsIG5ld2NbY2lkXSwgb2xkYywgbmV3YywgY2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBuZXdjKSB7XG4gICAgICAgICAgb2xkY1trZXldID0gbmV3Y1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGRpZmZbQ09NUE9ORU5UU10gPSBuZXdjO1xuICAgICAgfVxuICAgIH1cbiAgICBjYWNoZWRGaW5kQ29tcG9uZW50KGNpZCwgY2RpZmYsIG9sZGMsIG5ld2MsIGNhY2hlKSB7XG4gICAgICBpZiAoY2FjaGVbY2lkXSkge1xuICAgICAgICByZXR1cm4gY2FjaGVbY2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBuZGlmZiwgc3RhdCwgc2NpZCA9IGNkaWZmW1NUQVRJQ107XG4gICAgICAgIGlmIChpc0NpZChzY2lkKSkge1xuICAgICAgICAgIGxldCB0ZGlmZjtcbiAgICAgICAgICBpZiAoc2NpZCA+IDApIHtcbiAgICAgICAgICAgIHRkaWZmID0gdGhpcy5jYWNoZWRGaW5kQ29tcG9uZW50KHNjaWQsIG5ld2Nbc2NpZF0sIG9sZGMsIG5ld2MsIGNhY2hlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGRpZmYgPSBvbGRjWy1zY2lkXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhdCA9IHRkaWZmW1NUQVRJQ107XG4gICAgICAgICAgbmRpZmYgPSB0aGlzLmNsb25lTWVyZ2UodGRpZmYsIGNkaWZmKTtcbiAgICAgICAgICBuZGlmZltTVEFUSUNdID0gc3RhdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZGlmZiA9IGNkaWZmW1NUQVRJQ10gIT09IHZvaWQgMCA/IGNkaWZmIDogdGhpcy5jbG9uZU1lcmdlKG9sZGNbY2lkXSB8fCB7fSwgY2RpZmYpO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlW2NpZF0gPSBuZGlmZjtcbiAgICAgICAgcmV0dXJuIG5kaWZmO1xuICAgICAgfVxuICAgIH1cbiAgICBtdXRhYmxlTWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2VbU1RBVElDXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRvTXV0YWJsZU1lcmdlKHRhcmdldCwgc291cmNlKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICB9XG4gICAgZG9NdXRhYmxlTWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgIGZvciAobGV0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgbGV0IHZhbCA9IHNvdXJjZVtrZXldO1xuICAgICAgICBsZXQgdGFyZ2V0VmFsID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmIChpc09iamVjdCh2YWwpICYmIHZhbFtTVEFUSUNdID09PSB2b2lkIDAgJiYgaXNPYmplY3QodGFyZ2V0VmFsKSkge1xuICAgICAgICAgIHRoaXMuZG9NdXRhYmxlTWVyZ2UodGFyZ2V0VmFsLCB2YWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNsb25lTWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgIGxldCBtZXJnZWQgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGFyZ2V0KSwgc291cmNlKTtcbiAgICAgIGZvciAobGV0IGtleSBpbiBtZXJnZWQpIHtcbiAgICAgICAgbGV0IHZhbCA9IHNvdXJjZVtrZXldO1xuICAgICAgICBsZXQgdGFyZ2V0VmFsID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmIChpc09iamVjdCh2YWwpICYmIHZhbFtTVEFUSUNdID09PSB2b2lkIDAgJiYgaXNPYmplY3QodGFyZ2V0VmFsKSkge1xuICAgICAgICAgIG1lcmdlZFtrZXldID0gdGhpcy5jbG9uZU1lcmdlKHRhcmdldFZhbCwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG4gICAgY29tcG9uZW50VG9TdHJpbmcoY2lkKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWN1cnNpdmVDSURUb1N0cmluZyh0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdLCBjaWQpO1xuICAgIH1cbiAgICBwcnVuZUNJRHMoY2lkcykge1xuICAgICAgY2lkcy5mb3JFYWNoKChjaWQpID0+IGRlbGV0ZSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdW2NpZF0pO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlZDtcbiAgICB9XG4gICAgaXNOZXdGaW5nZXJwcmludChkaWZmID0ge30pIHtcbiAgICAgIHJldHVybiAhIWRpZmZbU1RBVElDXTtcbiAgICB9XG4gICAgdG9PdXRwdXRCdWZmZXIocmVuZGVyZWQsIG91dHB1dCkge1xuICAgICAgaWYgKHJlbmRlcmVkW0RZTkFNSUNTXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wcmVoZW5zaW9uVG9CdWZmZXIocmVuZGVyZWQsIG91dHB1dCk7XG4gICAgICB9XG4gICAgICBsZXQgeyBbU1RBVElDXTogc3RhdGljcyB9ID0gcmVuZGVyZWQ7XG4gICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbMF07XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0YXRpY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5keW5hbWljVG9CdWZmZXIocmVuZGVyZWRbaSAtIDFdLCBvdXRwdXQpO1xuICAgICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbaV07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbXByZWhlbnNpb25Ub0J1ZmZlcihyZW5kZXJlZCwgb3V0cHV0KSB7XG4gICAgICBsZXQgeyBbRFlOQU1JQ1NdOiBkeW5hbWljcywgW1NUQVRJQ106IHN0YXRpY3MgfSA9IHJlbmRlcmVkO1xuICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCBkeW5hbWljcy5sZW5ndGg7IGQrKykge1xuICAgICAgICBsZXQgZHluYW1pYyA9IGR5bmFtaWNzW2RdO1xuICAgICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RhdGljcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuZHluYW1pY1RvQnVmZmVyKGR5bmFtaWNbaSAtIDFdLCBvdXRwdXQpO1xuICAgICAgICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkeW5hbWljVG9CdWZmZXIocmVuZGVyZWQsIG91dHB1dCkge1xuICAgICAgaWYgKHR5cGVvZiByZW5kZXJlZCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBvdXRwdXQuYnVmZmVyICs9IHRoaXMucmVjdXJzaXZlQ0lEVG9TdHJpbmcob3V0cHV0LmNvbXBvbmVudHMsIHJlbmRlcmVkLCBvdXRwdXQub25seUNpZHMpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChyZW5kZXJlZCkpIHtcbiAgICAgICAgdGhpcy50b091dHB1dEJ1ZmZlcihyZW5kZXJlZCwgb3V0cHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC5idWZmZXIgKz0gcmVuZGVyZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJlY3Vyc2l2ZUNJRFRvU3RyaW5nKGNvbXBvbmVudHMsIGNpZCwgb25seUNpZHMpIHtcbiAgICAgIGxldCBjb21wb25lbnQgPSBjb21wb25lbnRzW2NpZF0gfHwgbG9nRXJyb3IoYG5vIGNvbXBvbmVudCBmb3IgQ0lEICR7Y2lkfWAsIGNvbXBvbmVudHMpO1xuICAgICAgbGV0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdGhpcy5yZWN1cnNpdmVUb1N0cmluZyhjb21wb25lbnQsIGNvbXBvbmVudHMsIG9ubHlDaWRzKTtcbiAgICAgIGxldCBjb250YWluZXIgPSB0ZW1wbGF0ZS5jb250ZW50O1xuICAgICAgbGV0IHNraXAgPSBvbmx5Q2lkcyAmJiAhb25seUNpZHMuaGFzKGNpZCk7XG4gICAgICBsZXQgW2hhc0NoaWxkTm9kZXMsIGhhc0NoaWxkQ29tcG9uZW50c10gPSBBcnJheS5mcm9tKGNvbnRhaW5lci5jaGlsZE5vZGVzKS5yZWR1Y2UoKFtoYXNOb2RlcywgaGFzQ29tcG9uZW50c10sIGNoaWxkLCBpKSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBpZiAoY2hpbGQuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2hhc05vZGVzLCB0cnVlXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQsIGNpZCk7XG4gICAgICAgICAgaWYgKCFjaGlsZC5pZCkge1xuICAgICAgICAgICAgY2hpbGQuaWQgPSBgJHt0aGlzLnBhcmVudFZpZXdJZCgpfS0ke2NpZH0tJHtpfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChza2lwKSB7XG4gICAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoUEhYX1NLSVAsIFwiXCIpO1xuICAgICAgICAgICAgY2hpbGQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFt0cnVlLCBoYXNDb21wb25lbnRzXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY2hpbGQubm9kZVZhbHVlLnRyaW0oKSAhPT0gXCJcIikge1xuICAgICAgICAgICAgbG9nRXJyb3IoYG9ubHkgSFRNTCBlbGVtZW50IHRhZ3MgYXJlIGFsbG93ZWQgYXQgdGhlIHJvb3Qgb2YgY29tcG9uZW50cy5cblxuZ290OiBcIiR7Y2hpbGQubm9kZVZhbHVlLnRyaW0oKX1cIlxuXG53aXRoaW46XG5gLCB0ZW1wbGF0ZS5pbm5lckhUTUwudHJpbSgpKTtcbiAgICAgICAgICAgIGNoaWxkLnJlcGxhY2VXaXRoKHRoaXMuY3JlYXRlU3BhbihjaGlsZC5ub2RlVmFsdWUsIGNpZCkpO1xuICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCBoYXNDb21wb25lbnRzXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hpbGQucmVtb3ZlKCk7XG4gICAgICAgICAgICByZXR1cm4gW2hhc05vZGVzLCBoYXNDb21wb25lbnRzXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIFtmYWxzZSwgZmFsc2VdKTtcbiAgICAgIGlmICghaGFzQ2hpbGROb2RlcyAmJiAhaGFzQ2hpbGRDb21wb25lbnRzKSB7XG4gICAgICAgIGxvZ0Vycm9yKFwiZXhwZWN0ZWQgYXQgbGVhc3Qgb25lIEhUTUwgZWxlbWVudCB0YWcgaW5zaWRlIGEgY29tcG9uZW50LCBidXQgdGhlIGNvbXBvbmVudCBpcyBlbXB0eTpcXG5cIiwgdGVtcGxhdGUuaW5uZXJIVE1MLnRyaW0oKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNwYW4oXCJcIiwgY2lkKS5vdXRlckhUTUw7XG4gICAgICB9IGVsc2UgaWYgKCFoYXNDaGlsZE5vZGVzICYmIGhhc0NoaWxkQ29tcG9uZW50cykge1xuICAgICAgICBsb2dFcnJvcihcImV4cGVjdGVkIGF0IGxlYXN0IG9uZSBIVE1MIGVsZW1lbnQgdGFnIGRpcmVjdGx5IGluc2lkZSBhIGNvbXBvbmVudCwgYnV0IG9ubHkgc3ViY29tcG9uZW50cyB3ZXJlIGZvdW5kLiBBIGNvbXBvbmVudCBtdXN0IHJlbmRlciBhdCBsZWFzdCBvbmUgSFRNTCB0YWcgZGlyZWN0bHkgaW5zaWRlIGl0c2VsZi5cIiwgdGVtcGxhdGUuaW5uZXJIVE1MLnRyaW0oKSk7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVTcGFuKHRleHQsIGNpZCkge1xuICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHNwYW4uaW5uZXJUZXh0ID0gdGV4dDtcbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQsIGNpZCk7XG4gICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gIH07XG5cbiAgLy8ganMvcGhvZW5peF9saXZlX3ZpZXcvdmlld19ob29rLmpzXG4gIHZhciB2aWV3SG9va0lEID0gMTtcbiAgdmFyIFZpZXdIb29rID0gY2xhc3Mge1xuICAgIHN0YXRpYyBtYWtlSUQoKSB7XG4gICAgICByZXR1cm4gdmlld0hvb2tJRCsrO1xuICAgIH1cbiAgICBzdGF0aWMgZWxlbWVudElEKGVsKSB7XG4gICAgICByZXR1cm4gZWwucGh4SG9va0lkO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2aWV3LCBlbCwgY2FsbGJhY2tzKSB7XG4gICAgICB0aGlzLl9fdmlldyA9IHZpZXc7XG4gICAgICB0aGlzLl9fbGl2ZVNvY2tldCA9IHZpZXcubGl2ZVNvY2tldDtcbiAgICAgIHRoaXMuX19jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgICB0aGlzLl9fbGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5fX2lzRGlzY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmVsID0gZWw7XG4gICAgICB0aGlzLmVsLnBoeEhvb2tJZCA9IHRoaXMuY29uc3RydWN0b3IubWFrZUlEKCk7XG4gICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5fX2NhbGxiYWNrcykge1xuICAgICAgICB0aGlzW2tleV0gPSB0aGlzLl9fY2FsbGJhY2tzW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIF9fbW91bnRlZCgpIHtcbiAgICAgIHRoaXMubW91bnRlZCAmJiB0aGlzLm1vdW50ZWQoKTtcbiAgICB9XG4gICAgX191cGRhdGVkKCkge1xuICAgICAgdGhpcy51cGRhdGVkICYmIHRoaXMudXBkYXRlZCgpO1xuICAgIH1cbiAgICBfX2JlZm9yZVVwZGF0ZSgpIHtcbiAgICAgIHRoaXMuYmVmb3JlVXBkYXRlICYmIHRoaXMuYmVmb3JlVXBkYXRlKCk7XG4gICAgfVxuICAgIF9fZGVzdHJveWVkKCkge1xuICAgICAgdGhpcy5kZXN0cm95ZWQgJiYgdGhpcy5kZXN0cm95ZWQoKTtcbiAgICB9XG4gICAgX19yZWNvbm5lY3RlZCgpIHtcbiAgICAgIGlmICh0aGlzLl9faXNEaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5fX2lzRGlzY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVjb25uZWN0ZWQgJiYgdGhpcy5yZWNvbm5lY3RlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBfX2Rpc2Nvbm5lY3RlZCgpIHtcbiAgICAgIHRoaXMuX19pc0Rpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RlZCAmJiB0aGlzLmRpc2Nvbm5lY3RlZCgpO1xuICAgIH1cbiAgICBwdXNoRXZlbnQoZXZlbnQsIHBheWxvYWQgPSB7fSwgb25SZXBseSA9IGZ1bmN0aW9uKCkge1xuICAgIH0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdmlldy5wdXNoSG9va0V2ZW50KG51bGwsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5KTtcbiAgICB9XG4gICAgcHVzaEV2ZW50VG8ocGh4VGFyZ2V0LCBldmVudCwgcGF5bG9hZCA9IHt9LCBvblJlcGx5ID0gZnVuY3Rpb24oKSB7XG4gICAgfSkge1xuICAgICAgcmV0dXJuIHRoaXMuX192aWV3LndpdGhpblRhcmdldHMocGh4VGFyZ2V0LCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICAgIHJldHVybiB2aWV3LnB1c2hIb29rRXZlbnQodGFyZ2V0Q3R4LCBldmVudCwgcGF5bG9hZCwgb25SZXBseSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICBsZXQgY2FsbGJhY2tSZWYgPSAoY3VzdG9tRXZlbnQsIGJ5cGFzcykgPT4gYnlwYXNzID8gZXZlbnQgOiBjYWxsYmFjayhjdXN0b21FdmVudC5kZXRhaWwpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoYHBoeDpob29rOiR7ZXZlbnR9YCwgY2FsbGJhY2tSZWYpO1xuICAgICAgdGhpcy5fX2xpc3RlbmVycy5hZGQoY2FsbGJhY2tSZWYpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrUmVmO1xuICAgIH1cbiAgICByZW1vdmVIYW5kbGVFdmVudChjYWxsYmFja1JlZikge1xuICAgICAgbGV0IGV2ZW50ID0gY2FsbGJhY2tSZWYobnVsbCwgdHJ1ZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihgcGh4Omhvb2s6JHtldmVudH1gLCBjYWxsYmFja1JlZik7XG4gICAgICB0aGlzLl9fbGlzdGVuZXJzLmRlbGV0ZShjYWxsYmFja1JlZik7XG4gICAgfVxuICAgIHVwbG9hZChuYW1lLCBmaWxlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX192aWV3LmRpc3BhdGNoVXBsb2FkcyhuYW1lLCBmaWxlcyk7XG4gICAgfVxuICAgIHVwbG9hZFRvKHBoeFRhcmdldCwgbmFtZSwgZmlsZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fdmlldy53aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgKHZpZXcpID0+IHZpZXcuZGlzcGF0Y2hVcGxvYWRzKG5hbWUsIGZpbGVzKSk7XG4gICAgfVxuICAgIF9fY2xlYW51cF9fKCkge1xuICAgICAgdGhpcy5fX2xpc3RlbmVycy5mb3JFYWNoKChjYWxsYmFja1JlZikgPT4gdGhpcy5yZW1vdmVIYW5kbGVFdmVudChjYWxsYmFja1JlZikpO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy92aWV3LmpzXG4gIHZhciBzZXJpYWxpemVGb3JtID0gKGZvcm0sIG1ldGEgPSB7fSkgPT4ge1xuICAgIGxldCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtKTtcbiAgICBsZXQgdG9SZW1vdmUgPSBbXTtcbiAgICBmb3JtRGF0YS5mb3JFYWNoKCh2YWwsIGtleSwgX2luZGV4KSA9PiB7XG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICB0b1JlbW92ZS5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG9SZW1vdmUuZm9yRWFjaCgoa2V5KSA9PiBmb3JtRGF0YS5kZWxldGUoa2V5KSk7XG4gICAgbGV0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIGZvcm1EYXRhLmVudHJpZXMoKSkge1xuICAgICAgcGFyYW1zLmFwcGVuZChrZXksIHZhbCk7XG4gICAgfVxuICAgIGZvciAobGV0IG1ldGFLZXkgaW4gbWV0YSkge1xuICAgICAgcGFyYW1zLmFwcGVuZChtZXRhS2V5LCBtZXRhW21ldGFLZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcy50b1N0cmluZygpO1xuICB9O1xuICB2YXIgVmlldyA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvcihlbCwgbGl2ZVNvY2tldCwgcGFyZW50VmlldywgZmxhc2gpIHtcbiAgICAgIHRoaXMubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXQ7XG4gICAgICB0aGlzLmZsYXNoID0gZmxhc2g7XG4gICAgICB0aGlzLnBhcmVudCA9IHBhcmVudFZpZXc7XG4gICAgICB0aGlzLnJvb3QgPSBwYXJlbnRWaWV3ID8gcGFyZW50Vmlldy5yb290IDogdGhpcztcbiAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLmVsLmlkO1xuICAgICAgdGhpcy5yZWYgPSAwO1xuICAgICAgdGhpcy5jaGlsZEpvaW5zID0gMDtcbiAgICAgIHRoaXMubG9hZGVyVGltZXIgPSBudWxsO1xuICAgICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXTtcbiAgICAgIHRoaXMucHJ1bmluZ0NJRHMgPSBbXTtcbiAgICAgIHRoaXMucmVkaXJlY3QgPSBmYWxzZTtcbiAgICAgIHRoaXMuaHJlZiA9IG51bGw7XG4gICAgICB0aGlzLmpvaW5Db3VudCA9IHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuam9pbkNvdW50IC0gMSA6IDA7XG4gICAgICB0aGlzLmpvaW5QZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICB0aGlzLmpvaW5DYWxsYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgfTtcbiAgICAgIHRoaXMuc3RvcENhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgdGhpcy5wZW5kaW5nSm9pbk9wcyA9IHRoaXMucGFyZW50ID8gbnVsbCA6IFtdO1xuICAgICAgdGhpcy52aWV3SG9va3MgPSB7fTtcbiAgICAgIHRoaXMudXBsb2FkZXJzID0ge307XG4gICAgICB0aGlzLmZvcm1TdWJtaXRzID0gW107XG4gICAgICB0aGlzLmNoaWxkcmVuID0gdGhpcy5wYXJlbnQgPyBudWxsIDoge307XG4gICAgICB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF0gPSB7fTtcbiAgICAgIHRoaXMuY2hhbm5lbCA9IHRoaXMubGl2ZVNvY2tldC5jaGFubmVsKGBsdjoke3RoaXMuaWR9YCwgKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlZGlyZWN0OiB0aGlzLnJlZGlyZWN0ID8gdGhpcy5ocmVmIDogdm9pZCAwLFxuICAgICAgICAgIHVybDogdGhpcy5yZWRpcmVjdCA/IHZvaWQgMCA6IHRoaXMuaHJlZiB8fCB2b2lkIDAsXG4gICAgICAgICAgcGFyYW1zOiB0aGlzLmNvbm5lY3RQYXJhbXMoKSxcbiAgICAgICAgICBzZXNzaW9uOiB0aGlzLmdldFNlc3Npb24oKSxcbiAgICAgICAgICBzdGF0aWM6IHRoaXMuZ2V0U3RhdGljKCksXG4gICAgICAgICAgZmxhc2g6IHRoaXMuZmxhc2hcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zaG93TG9hZGVyKHRoaXMubGl2ZVNvY2tldC5sb2FkZXJUaW1lb3V0KTtcbiAgICAgIHRoaXMuYmluZENoYW5uZWwoKTtcbiAgICB9XG4gICAgc2V0SHJlZihocmVmKSB7XG4gICAgICB0aGlzLmhyZWYgPSBocmVmO1xuICAgIH1cbiAgICBzZXRSZWRpcmVjdChocmVmKSB7XG4gICAgICB0aGlzLnJlZGlyZWN0ID0gdHJ1ZTtcbiAgICAgIHRoaXMuaHJlZiA9IGhyZWY7XG4gICAgfVxuICAgIGlzTWFpbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpdmVTb2NrZXQubWFpbiA9PT0gdGhpcztcbiAgICB9XG4gICAgY29ubmVjdFBhcmFtcygpIHtcbiAgICAgIGxldCBwYXJhbXMgPSB0aGlzLmxpdmVTb2NrZXQucGFyYW1zKHRoaXMuZWwpO1xuICAgICAgbGV0IG1hbmlmZXN0ID0gZG9tX2RlZmF1bHQuYWxsKGRvY3VtZW50LCBgWyR7dGhpcy5iaW5kaW5nKFBIWF9UUkFDS19TVEFUSUMpfV1gKS5tYXAoKG5vZGUpID0+IG5vZGUuc3JjIHx8IG5vZGUuaHJlZikuZmlsdGVyKCh1cmwpID0+IHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpO1xuICAgICAgaWYgKG1hbmlmZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGFyYW1zW1wiX3RyYWNrX3N0YXRpY1wiXSA9IG1hbmlmZXN0O1xuICAgICAgfVxuICAgICAgcGFyYW1zW1wiX21vdW50c1wiXSA9IHRoaXMuam9pbkNvdW50O1xuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgaXNDb25uZWN0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFubmVsLmNhblB1c2goKTtcbiAgICB9XG4gICAgZ2V0U2Vzc2lvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfU0VTU0lPTik7XG4gICAgfVxuICAgIGdldFN0YXRpYygpIHtcbiAgICAgIGxldCB2YWwgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZShQSFhfU1RBVElDKTtcbiAgICAgIHJldHVybiB2YWwgPT09IFwiXCIgPyBudWxsIDogdmFsO1xuICAgIH1cbiAgICBkZXN0cm95KGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgfSkge1xuICAgICAgdGhpcy5kZXN0cm95QWxsQ2hpbGRyZW4oKTtcbiAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIGRlbGV0ZSB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF07XG4gICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMucm9vdC5jaGlsZHJlblt0aGlzLnBhcmVudC5pZF1bdGhpcy5pZF07XG4gICAgICB9XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcik7XG4gICAgICBsZXQgb25GaW5pc2hlZCA9ICgpID0+IHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZm9yIChsZXQgaWQgaW4gdGhpcy52aWV3SG9va3MpIHtcbiAgICAgICAgICB0aGlzLmRlc3Ryb3lIb29rKHRoaXMudmlld0hvb2tzW2lkXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBkb21fZGVmYXVsdC5tYXJrUGh4Q2hpbGREZXN0cm95ZWQodGhpcy5lbCk7XG4gICAgICB0aGlzLmxvZyhcImRlc3Ryb3llZFwiLCAoKSA9PiBbXCJ0aGUgY2hpbGQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnRcIl0pO1xuICAgICAgdGhpcy5jaGFubmVsLmxlYXZlKCkucmVjZWl2ZShcIm9rXCIsIG9uRmluaXNoZWQpLnJlY2VpdmUoXCJlcnJvclwiLCBvbkZpbmlzaGVkKS5yZWNlaXZlKFwidGltZW91dFwiLCBvbkZpbmlzaGVkKTtcbiAgICB9XG4gICAgc2V0Q29udGFpbmVyQ2xhc3NlcyguLi5jbGFzc2VzKSB7XG4gICAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoUEhYX0NPTk5FQ1RFRF9DTEFTUywgUEhYX0RJU0NPTk5FQ1RFRF9DTEFTUywgUEhYX0VSUk9SX0NMQVNTKTtcbiAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzKTtcbiAgICB9XG4gICAgaXNMb2FkaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWwuY2xhc3NMaXN0LmNvbnRhaW5zKFBIWF9ESVNDT05ORUNURURfQ0xBU1MpO1xuICAgIH1cbiAgICBzaG93TG9hZGVyKHRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmxvYWRlclRpbWVyKTtcbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMubG9hZGVyVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2hvd0xvYWRlcigpLCB0aW1lb3V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGlkIGluIHRoaXMudmlld0hvb2tzKSB7XG4gICAgICAgICAgdGhpcy52aWV3SG9va3NbaWRdLl9fZGlzY29ubmVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRDb250YWluZXJDbGFzc2VzKFBIWF9ESVNDT05ORUNURURfQ0xBU1MpO1xuICAgICAgfVxuICAgIH1cbiAgICBoaWRlTG9hZGVyKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubG9hZGVyVGltZXIpO1xuICAgICAgdGhpcy5zZXRDb250YWluZXJDbGFzc2VzKFBIWF9DT05ORUNURURfQ0xBU1MpO1xuICAgIH1cbiAgICB0cmlnZ2VyUmVjb25uZWN0ZWQoKSB7XG4gICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnZpZXdIb29rcykge1xuICAgICAgICB0aGlzLnZpZXdIb29rc1tpZF0uX19yZWNvbm5lY3RlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2coa2luZCwgbXNnQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5sb2codGhpcywga2luZCwgbXNnQ2FsbGJhY2spO1xuICAgIH1cbiAgICB3aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChwaHhUYXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0Lm93bmVyKHBoeFRhcmdldCwgKHZpZXcpID0+IGNhbGxiYWNrKHZpZXcsIHBoeFRhcmdldCkpO1xuICAgICAgfVxuICAgICAgaWYgKC9eKDB8WzEtOV1cXGQqKSQvLnRlc3QocGh4VGFyZ2V0KSkge1xuICAgICAgICBsZXQgdGFyZ2V0cyA9IGRvbV9kZWZhdWx0LmZpbmRDb21wb25lbnROb2RlTGlzdCh0aGlzLmVsLCBwaHhUYXJnZXQpO1xuICAgICAgICBpZiAodGFyZ2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBsb2dFcnJvcihgbm8gY29tcG9uZW50IGZvdW5kIG1hdGNoaW5nIHBoeC10YXJnZXQgb2YgJHtwaHhUYXJnZXR9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2sodGhpcywgdGFyZ2V0c1swXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB0YXJnZXRzID0gQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHBoeFRhcmdldCkpO1xuICAgICAgICBpZiAodGFyZ2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBsb2dFcnJvcihgbm90aGluZyBmb3VuZCBtYXRjaGluZyB0aGUgcGh4LXRhcmdldCBzZWxlY3RvciBcIiR7cGh4VGFyZ2V0fVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0cy5mb3JFYWNoKCh0YXJnZXQpID0+IHRoaXMubGl2ZVNvY2tldC5vd25lcih0YXJnZXQsICh2aWV3KSA9PiBjYWxsYmFjayh2aWV3LCB0YXJnZXQpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFwcGx5RGlmZih0eXBlLCByYXdEaWZmLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5sb2codHlwZSwgKCkgPT4gW1wiXCIsIGNsb25lKHJhd0RpZmYpXSk7XG4gICAgICBsZXQgeyBkaWZmLCByZXBseSwgZXZlbnRzLCB0aXRsZSB9ID0gUmVuZGVyZWQuZXh0cmFjdChyYXdEaWZmKTtcbiAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICBkb21fZGVmYXVsdC5wdXRUaXRsZSh0aXRsZSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayh7IGRpZmYsIHJlcGx5LCBldmVudHMgfSk7XG4gICAgICByZXR1cm4gcmVwbHk7XG4gICAgfVxuICAgIG9uSm9pbihyZXNwKSB7XG4gICAgICBsZXQgeyByZW5kZXJlZCwgY29udGFpbmVyIH0gPSByZXNwO1xuICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICBsZXQgW3RhZywgYXR0cnNdID0gY29udGFpbmVyO1xuICAgICAgICB0aGlzLmVsID0gZG9tX2RlZmF1bHQucmVwbGFjZVJvb3RDb250YWluZXIodGhpcy5lbCwgdGFnLCBhdHRycyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNoaWxkSm9pbnMgPSAwO1xuICAgICAgdGhpcy5qb2luUGVuZGluZyA9IHRydWU7XG4gICAgICB0aGlzLmZsYXNoID0gbnVsbDtcbiAgICAgIGJyb3dzZXJfZGVmYXVsdC5kcm9wTG9jYWwodGhpcy5saXZlU29ja2V0LmxvY2FsU3RvcmFnZSwgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLCBDT05TRUNVVElWRV9SRUxPQURTKTtcbiAgICAgIHRoaXMuYXBwbHlEaWZmKFwibW91bnRcIiwgcmVuZGVyZWQsICh7IGRpZmYsIGV2ZW50cyB9KSA9PiB7XG4gICAgICAgIHRoaXMucmVuZGVyZWQgPSBuZXcgUmVuZGVyZWQodGhpcy5pZCwgZGlmZik7XG4gICAgICAgIGxldCBodG1sID0gdGhpcy5yZW5kZXJDb250YWluZXIobnVsbCwgXCJqb2luXCIpO1xuICAgICAgICB0aGlzLmRyb3BQZW5kaW5nUmVmcygpO1xuICAgICAgICBsZXQgZm9ybXMgPSB0aGlzLmZvcm1zRm9yUmVjb3ZlcnkoaHRtbCk7XG4gICAgICAgIHRoaXMuam9pbkNvdW50Kys7XG4gICAgICAgIGlmIChmb3Jtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZm9ybXMuZm9yRWFjaCgoW2Zvcm0sIG5ld0Zvcm0sIG5ld0NpZF0sIGkpID0+IHtcbiAgICAgICAgICAgIHRoaXMucHVzaEZvcm1SZWNvdmVyeShmb3JtLCBuZXdDaWQsIChyZXNwMikgPT4ge1xuICAgICAgICAgICAgICBpZiAoaSA9PT0gZm9ybXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Kb2luQ29tcGxldGUocmVzcDIsIGh0bWwsIGV2ZW50cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25Kb2luQ29tcGxldGUocmVzcCwgaHRtbCwgZXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGRyb3BQZW5kaW5nUmVmcygpIHtcbiAgICAgIGRvbV9kZWZhdWx0LmFsbCh0aGlzLmVsLCBgWyR7UEhYX1JFRn1dYCwgKGVsKSA9PiBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRikpO1xuICAgIH1cbiAgICBvbkpvaW5Db21wbGV0ZSh7IGxpdmVfcGF0Y2ggfSwgaHRtbCwgZXZlbnRzKSB7XG4gICAgICBpZiAodGhpcy5qb2luQ291bnQgPiAxIHx8IHRoaXMucGFyZW50ICYmICF0aGlzLnBhcmVudC5pc0pvaW5QZW5kaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgZXZlbnRzKTtcbiAgICAgIH1cbiAgICAgIGxldCBuZXdDaGlsZHJlbiA9IGRvbV9kZWZhdWx0LmZpbmRQaHhDaGlsZHJlbkluRnJhZ21lbnQoaHRtbCwgdGhpcy5pZCkuZmlsdGVyKCh0b0VsKSA9PiB7XG4gICAgICAgIGxldCBmcm9tRWwgPSB0b0VsLmlkICYmIHRoaXMuZWwucXVlcnlTZWxlY3RvcihgW2lkPVwiJHt0b0VsLmlkfVwiXWApO1xuICAgICAgICBsZXQgcGh4U3RhdGljID0gZnJvbUVsICYmIGZyb21FbC5nZXRBdHRyaWJ1dGUoUEhYX1NUQVRJQyk7XG4gICAgICAgIGlmIChwaHhTdGF0aWMpIHtcbiAgICAgICAgICB0b0VsLnNldEF0dHJpYnV0ZShQSFhfU1RBVElDLCBwaHhTdGF0aWMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmpvaW5DaGlsZCh0b0VsKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKG5ld0NoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICB0aGlzLnJvb3QucGVuZGluZ0pvaW5PcHMucHVzaChbdGhpcywgKCkgPT4gdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpXSk7XG4gICAgICAgICAgdGhpcy5wYXJlbnQuYWNrSm9pbih0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uQWxsQ2hpbGRKb2luc0NvbXBsZXRlKCk7XG4gICAgICAgICAgdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJvb3QucGVuZGluZ0pvaW5PcHMucHVzaChbdGhpcywgKCkgPT4gdGhpcy5hcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGF0dGFjaFRydWVEb2NFbCgpIHtcbiAgICAgIHRoaXMuZWwgPSBkb21fZGVmYXVsdC5ieUlkKHRoaXMuaWQpO1xuICAgICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQsIHRoaXMucm9vdC5pZCk7XG4gICAgfVxuICAgIGRpc3BhdGNoRXZlbnRzKGV2ZW50cykge1xuICAgICAgZXZlbnRzLmZvckVhY2goKFtldmVudCwgcGF5bG9hZF0pID0+IHtcbiAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGBwaHg6aG9vazoke2V2ZW50fWAsIHsgZGV0YWlsOiBwYXlsb2FkIH0pKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhcHBseUpvaW5QYXRjaChsaXZlX3BhdGNoLCBodG1sLCBldmVudHMpIHtcbiAgICAgIHRoaXMuYXR0YWNoVHJ1ZURvY0VsKCk7XG4gICAgICBsZXQgcGF0Y2ggPSBuZXcgRE9NUGF0Y2godGhpcywgdGhpcy5lbCwgdGhpcy5pZCwgaHRtbCwgbnVsbCk7XG4gICAgICBwYXRjaC5tYXJrUHJ1bmFibGVDb250ZW50Rm9yUmVtb3ZhbCgpO1xuICAgICAgdGhpcy5wZXJmb3JtUGF0Y2gocGF0Y2gsIGZhbHNlKTtcbiAgICAgIHRoaXMuam9pbk5ld0NoaWxkcmVuKCk7XG4gICAgICBkb21fZGVmYXVsdC5hbGwodGhpcy5lbCwgYFske3RoaXMuYmluZGluZyhQSFhfSE9PSyl9XSwgW2RhdGEtcGh4LSR7UEhYX0hPT0t9XWAsIChob29rRWwpID0+IHtcbiAgICAgICAgbGV0IGhvb2sgPSB0aGlzLmFkZEhvb2soaG9va0VsKTtcbiAgICAgICAgaWYgKGhvb2spIHtcbiAgICAgICAgICBob29rLl9fbW91bnRlZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuam9pblBlbmRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudHMoZXZlbnRzKTtcbiAgICAgIHRoaXMuYXBwbHlQZW5kaW5nVXBkYXRlcygpO1xuICAgICAgaWYgKGxpdmVfcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsga2luZCwgdG8gfSA9IGxpdmVfcGF0Y2g7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5oaXN0b3J5UGF0Y2godG8sIGtpbmQpO1xuICAgICAgfVxuICAgICAgdGhpcy5oaWRlTG9hZGVyKCk7XG4gICAgICBpZiAodGhpcy5qb2luQ291bnQgPiAxKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlclJlY29ubmVjdGVkKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0b3BDYWxsYmFjaygpO1xuICAgIH1cbiAgICB0cmlnZ2VyQmVmb3JlVXBkYXRlSG9vayhmcm9tRWwsIHRvRWwpIHtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC50cmlnZ2VyRE9NKFwib25CZWZvcmVFbFVwZGF0ZWRcIiwgW2Zyb21FbCwgdG9FbF0pO1xuICAgICAgbGV0IGhvb2sgPSB0aGlzLmdldEhvb2soZnJvbUVsKTtcbiAgICAgIGxldCBpc0lnbm9yZWQgPSBob29rICYmIGRvbV9kZWZhdWx0LmlzSWdub3JlZChmcm9tRWwsIHRoaXMuYmluZGluZyhQSFhfVVBEQVRFKSk7XG4gICAgICBpZiAoaG9vayAmJiAhZnJvbUVsLmlzRXF1YWxOb2RlKHRvRWwpICYmICEoaXNJZ25vcmVkICYmIGlzRXF1YWxPYmooZnJvbUVsLmRhdGFzZXQsIHRvRWwuZGF0YXNldCkpKSB7XG4gICAgICAgIGhvb2suX19iZWZvcmVVcGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIGhvb2s7XG4gICAgICB9XG4gICAgfVxuICAgIHBlcmZvcm1QYXRjaChwYXRjaCwgcHJ1bmVDaWRzKSB7XG4gICAgICBsZXQgZGVzdHJveWVkQ0lEcyA9IFtdO1xuICAgICAgbGV0IHBoeENoaWxkcmVuQWRkZWQgPSBmYWxzZTtcbiAgICAgIGxldCB1cGRhdGVkSG9va0lkcyA9IG5ldyBTZXQoKTtcbiAgICAgIHBhdGNoLmFmdGVyKFwiYWRkZWRcIiwgKGVsKSA9PiB7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC50cmlnZ2VyRE9NKFwib25Ob2RlQWRkZWRcIiwgW2VsXSk7XG4gICAgICAgIGxldCBuZXdIb29rID0gdGhpcy5hZGRIb29rKGVsKTtcbiAgICAgICAgaWYgKG5ld0hvb2spIHtcbiAgICAgICAgICBuZXdIb29rLl9fbW91bnRlZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHBhdGNoLmFmdGVyKFwicGh4Q2hpbGRBZGRlZFwiLCAoX2VsKSA9PiBwaHhDaGlsZHJlbkFkZGVkID0gdHJ1ZSk7XG4gICAgICBwYXRjaC5iZWZvcmUoXCJ1cGRhdGVkXCIsIChmcm9tRWwsIHRvRWwpID0+IHtcbiAgICAgICAgbGV0IGhvb2sgPSB0aGlzLnRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGZyb21FbCwgdG9FbCk7XG4gICAgICAgIGlmIChob29rKSB7XG4gICAgICAgICAgdXBkYXRlZEhvb2tJZHMuYWRkKGZyb21FbC5pZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcGF0Y2guYWZ0ZXIoXCJ1cGRhdGVkXCIsIChlbCkgPT4ge1xuICAgICAgICBpZiAodXBkYXRlZEhvb2tJZHMuaGFzKGVsLmlkKSkge1xuICAgICAgICAgIHRoaXMuZ2V0SG9vayhlbCkuX191cGRhdGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcGF0Y2guYWZ0ZXIoXCJkaXNjYXJkZWRcIiwgKGVsKSA9PiB7XG4gICAgICAgIGxldCBjaWQgPSB0aGlzLmNvbXBvbmVudElEKGVsKTtcbiAgICAgICAgaWYgKGlzQ2lkKGNpZCkgJiYgZGVzdHJveWVkQ0lEcy5pbmRleE9mKGNpZCkgPT09IC0xKSB7XG4gICAgICAgICAgZGVzdHJveWVkQ0lEcy5wdXNoKGNpZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhvb2sgPSB0aGlzLmdldEhvb2soZWwpO1xuICAgICAgICBob29rICYmIHRoaXMuZGVzdHJveUhvb2soaG9vayk7XG4gICAgICB9KTtcbiAgICAgIHBhdGNoLnBlcmZvcm0oKTtcbiAgICAgIGlmIChwcnVuZUNpZHMpIHtcbiAgICAgICAgdGhpcy5tYXliZVB1c2hDb21wb25lbnRzRGVzdHJveWVkKGRlc3Ryb3llZENJRHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBoeENoaWxkcmVuQWRkZWQ7XG4gICAgfVxuICAgIGpvaW5OZXdDaGlsZHJlbigpIHtcbiAgICAgIGRvbV9kZWZhdWx0LmZpbmRQaHhDaGlsZHJlbih0aGlzLmVsLCB0aGlzLmlkKS5mb3JFYWNoKChlbCkgPT4gdGhpcy5qb2luQ2hpbGQoZWwpKTtcbiAgICB9XG4gICAgZ2V0Q2hpbGRCeUlkKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdW2lkXTtcbiAgICB9XG4gICAgZ2V0RGVzY2VuZGVudEJ5RWwoZWwpIHtcbiAgICAgIGlmIChlbC5pZCA9PT0gdGhpcy5pZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2VsLmdldEF0dHJpYnV0ZShQSFhfUEFSRU5UX0lEKV1bZWwuaWRdO1xuICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95RGVzY2VuZGVudChpZCkge1xuICAgICAgZm9yIChsZXQgcGFyZW50SWQgaW4gdGhpcy5yb290LmNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAobGV0IGNoaWxkSWQgaW4gdGhpcy5yb290LmNoaWxkcmVuW3BhcmVudElkXSkge1xuICAgICAgICAgIGlmIChjaGlsZElkID09PSBpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5jaGlsZHJlbltwYXJlbnRJZF1bY2hpbGRJZF0uZGVzdHJveSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBqb2luQ2hpbGQoZWwpIHtcbiAgICAgIGxldCBjaGlsZCA9IHRoaXMuZ2V0Q2hpbGRCeUlkKGVsLmlkKTtcbiAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgbGV0IHZpZXcgPSBuZXcgVmlldyhlbCwgdGhpcy5saXZlU29ja2V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdW3ZpZXcuaWRdID0gdmlldztcbiAgICAgICAgdmlldy5qb2luKCk7XG4gICAgICAgIHRoaXMuY2hpbGRKb2lucysrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaXNKb2luUGVuZGluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLmpvaW5QZW5kaW5nO1xuICAgIH1cbiAgICBhY2tKb2luKF9jaGlsZCkge1xuICAgICAgdGhpcy5jaGlsZEpvaW5zLS07XG4gICAgICBpZiAodGhpcy5jaGlsZEpvaW5zID09PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgIHRoaXMucGFyZW50LmFja0pvaW4odGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkFsbENoaWxkSm9pbnNDb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG9uQWxsQ2hpbGRKb2luc0NvbXBsZXRlKCkge1xuICAgICAgdGhpcy5qb2luQ2FsbGJhY2soKTtcbiAgICAgIHRoaXMucGVuZGluZ0pvaW5PcHMuZm9yRWFjaCgoW3ZpZXcsIG9wXSkgPT4ge1xuICAgICAgICBpZiAoIXZpZXcuaXNEZXN0cm95ZWQoKSkge1xuICAgICAgICAgIG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5wZW5kaW5nSm9pbk9wcyA9IFtdO1xuICAgIH1cbiAgICB1cGRhdGUoZGlmZiwgZXZlbnRzKSB7XG4gICAgICBpZiAodGhpcy5pc0pvaW5QZW5kaW5nKCkgfHwgdGhpcy5saXZlU29ja2V0Lmhhc1BlbmRpbmdMaW5rKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ0RpZmZzLnB1c2goeyBkaWZmLCBldmVudHMgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlcmVkLm1lcmdlRGlmZihkaWZmKTtcbiAgICAgIGxldCBwaHhDaGlsZHJlbkFkZGVkID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5yZW5kZXJlZC5pc0NvbXBvbmVudE9ubHlEaWZmKGRpZmYpKSB7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC50aW1lKFwiY29tcG9uZW50IHBhdGNoIGNvbXBsZXRlXCIsICgpID0+IHtcbiAgICAgICAgICBsZXQgcGFyZW50Q2lkcyA9IGRvbV9kZWZhdWx0LmZpbmRQYXJlbnRDSURzKHRoaXMuZWwsIHRoaXMucmVuZGVyZWQuY29tcG9uZW50Q0lEcyhkaWZmKSk7XG4gICAgICAgICAgcGFyZW50Q2lkcy5mb3JFYWNoKChwYXJlbnRDSUQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudFBhdGNoKHRoaXMucmVuZGVyZWQuZ2V0Q29tcG9uZW50KGRpZmYsIHBhcmVudENJRCksIHBhcmVudENJRCkpIHtcbiAgICAgICAgICAgICAgcGh4Q2hpbGRyZW5BZGRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICghaXNFbXB0eShkaWZmKSkge1xuICAgICAgICB0aGlzLmxpdmVTb2NrZXQudGltZShcImZ1bGwgcGF0Y2ggY29tcGxldGVcIiwgKCkgPT4ge1xuICAgICAgICAgIGxldCBodG1sID0gdGhpcy5yZW5kZXJDb250YWluZXIoZGlmZiwgXCJ1cGRhdGVcIik7XG4gICAgICAgICAgbGV0IHBhdGNoID0gbmV3IERPTVBhdGNoKHRoaXMsIHRoaXMuZWwsIHRoaXMuaWQsIGh0bWwsIG51bGwpO1xuICAgICAgICAgIHBoeENoaWxkcmVuQWRkZWQgPSB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50cyhldmVudHMpO1xuICAgICAgaWYgKHBoeENoaWxkcmVuQWRkZWQpIHtcbiAgICAgICAgdGhpcy5qb2luTmV3Q2hpbGRyZW4oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyQ29udGFpbmVyKGRpZmYsIGtpbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLmxpdmVTb2NrZXQudGltZShgdG9TdHJpbmcgZGlmZiAoJHtraW5kfSlgLCAoKSA9PiB7XG4gICAgICAgIGxldCB0YWcgPSB0aGlzLmVsLnRhZ05hbWU7XG4gICAgICAgIGxldCBjaWRzID0gZGlmZiA/IHRoaXMucmVuZGVyZWQuY29tcG9uZW50Q0lEcyhkaWZmKS5jb25jYXQodGhpcy5wcnVuaW5nQ0lEcykgOiBudWxsO1xuICAgICAgICBsZXQgaHRtbCA9IHRoaXMucmVuZGVyZWQudG9TdHJpbmcoY2lkcyk7XG4gICAgICAgIHJldHVybiBgPCR7dGFnfT4ke2h0bWx9PC8ke3RhZ30+YDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb21wb25lbnRQYXRjaChkaWZmLCBjaWQpIHtcbiAgICAgIGlmIChpc0VtcHR5KGRpZmYpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBsZXQgaHRtbCA9IHRoaXMucmVuZGVyZWQuY29tcG9uZW50VG9TdHJpbmcoY2lkKTtcbiAgICAgIGxldCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBjaWQpO1xuICAgICAgbGV0IGNoaWxkcmVuQWRkZWQgPSB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gY2hpbGRyZW5BZGRlZDtcbiAgICB9XG4gICAgZ2V0SG9vayhlbCkge1xuICAgICAgcmV0dXJuIHRoaXMudmlld0hvb2tzW1ZpZXdIb29rLmVsZW1lbnRJRChlbCldO1xuICAgIH1cbiAgICBhZGRIb29rKGVsKSB7XG4gICAgICBpZiAoVmlld0hvb2suZWxlbWVudElEKGVsKSB8fCAhZWwuZ2V0QXR0cmlidXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBob29rTmFtZSA9IGVsLmdldEF0dHJpYnV0ZShgZGF0YS1waHgtJHtQSFhfSE9PS31gKSB8fCBlbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9IT09LKSk7XG4gICAgICBpZiAoaG9va05hbWUgJiYgIXRoaXMub3duc0VsZW1lbnQoZWwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBjYWxsYmFja3MgPSB0aGlzLmxpdmVTb2NrZXQuZ2V0SG9va0NhbGxiYWNrcyhob29rTmFtZSk7XG4gICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgIGlmICghZWwuaWQpIHtcbiAgICAgICAgICBsb2dFcnJvcihgbm8gRE9NIElEIGZvciBob29rIFwiJHtob29rTmFtZX1cIi4gSG9va3MgcmVxdWlyZSBhIHVuaXF1ZSBJRCBvbiBlYWNoIGVsZW1lbnQuYCwgZWwpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBob29rID0gbmV3IFZpZXdIb29rKHRoaXMsIGVsLCBjYWxsYmFja3MpO1xuICAgICAgICB0aGlzLnZpZXdIb29rc1tWaWV3SG9vay5lbGVtZW50SUQoaG9vay5lbCldID0gaG9vaztcbiAgICAgICAgcmV0dXJuIGhvb2s7XG4gICAgICB9IGVsc2UgaWYgKGhvb2tOYW1lICE9PSBudWxsKSB7XG4gICAgICAgIGxvZ0Vycm9yKGB1bmtub3duIGhvb2sgZm91bmQgZm9yIFwiJHtob29rTmFtZX1cImAsIGVsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveUhvb2soaG9vaykge1xuICAgICAgaG9vay5fX2Rlc3Ryb3llZCgpO1xuICAgICAgaG9vay5fX2NsZWFudXBfXygpO1xuICAgICAgZGVsZXRlIHRoaXMudmlld0hvb2tzW1ZpZXdIb29rLmVsZW1lbnRJRChob29rLmVsKV07XG4gICAgfVxuICAgIGFwcGx5UGVuZGluZ1VwZGF0ZXMoKSB7XG4gICAgICB0aGlzLnBlbmRpbmdEaWZmcy5mb3JFYWNoKCh7IGRpZmYsIGV2ZW50cyB9KSA9PiB0aGlzLnVwZGF0ZShkaWZmLCBldmVudHMpKTtcbiAgICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW107XG4gICAgfVxuICAgIG9uQ2hhbm5lbChldmVudCwgY2IpIHtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5vbkNoYW5uZWwodGhpcy5jaGFubmVsLCBldmVudCwgKHJlc3ApID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaXNKb2luUGVuZGluZygpKSB7XG4gICAgICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsICgpID0+IGNiKHJlc3ApXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IocmVzcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBiaW5kQ2hhbm5lbCgpIHtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5vbkNoYW5uZWwodGhpcy5jaGFubmVsLCBcImRpZmZcIiwgKHJhd0RpZmYpID0+IHtcbiAgICAgICAgdGhpcy5hcHBseURpZmYoXCJ1cGRhdGVcIiwgcmF3RGlmZiwgKHsgZGlmZiwgZXZlbnRzIH0pID0+IHRoaXMudXBkYXRlKGRpZmYsIGV2ZW50cykpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9uQ2hhbm5lbChcInJlZGlyZWN0XCIsICh7IHRvLCBmbGFzaCB9KSA9PiB0aGlzLm9uUmVkaXJlY3QoeyB0bywgZmxhc2ggfSkpO1xuICAgICAgdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3BhdGNoXCIsIChyZWRpcikgPT4gdGhpcy5vbkxpdmVQYXRjaChyZWRpcikpO1xuICAgICAgdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3JlZGlyZWN0XCIsIChyZWRpcikgPT4gdGhpcy5vbkxpdmVSZWRpcmVjdChyZWRpcikpO1xuICAgICAgdGhpcy5jaGFubmVsLm9uRXJyb3IoKHJlYXNvbikgPT4gdGhpcy5vbkVycm9yKHJlYXNvbikpO1xuICAgICAgdGhpcy5jaGFubmVsLm9uQ2xvc2UoKHJlYXNvbikgPT4gdGhpcy5vbkNsb3NlKHJlYXNvbikpO1xuICAgIH1cbiAgICBkZXN0cm95QWxsQ2hpbGRyZW4oKSB7XG4gICAgICBmb3IgKGxldCBpZCBpbiB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF0pIHtcbiAgICAgICAgdGhpcy5nZXRDaGlsZEJ5SWQoaWQpLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb25MaXZlUmVkaXJlY3QocmVkaXIpIHtcbiAgICAgIGxldCB7IHRvLCBraW5kLCBmbGFzaCB9ID0gcmVkaXI7XG4gICAgICBsZXQgdXJsID0gdGhpcy5leHBhbmRVUkwodG8pO1xuICAgICAgdGhpcy5saXZlU29ja2V0Lmhpc3RvcnlSZWRpcmVjdCh1cmwsIGtpbmQsIGZsYXNoKTtcbiAgICB9XG4gICAgb25MaXZlUGF0Y2gocmVkaXIpIHtcbiAgICAgIGxldCB7IHRvLCBraW5kIH0gPSByZWRpcjtcbiAgICAgIHRoaXMuaHJlZiA9IHRoaXMuZXhwYW5kVVJMKHRvKTtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5oaXN0b3J5UGF0Y2godG8sIGtpbmQpO1xuICAgIH1cbiAgICBleHBhbmRVUkwodG8pIHtcbiAgICAgIHJldHVybiB0by5zdGFydHNXaXRoKFwiL1wiKSA/IGAke3dpbmRvdy5sb2NhdGlvbi5wcm90b2NvbH0vLyR7d2luZG93LmxvY2F0aW9uLmhvc3R9JHt0b31gIDogdG87XG4gICAgfVxuICAgIG9uUmVkaXJlY3QoeyB0bywgZmxhc2ggfSkge1xuICAgICAgdGhpcy5saXZlU29ja2V0LnJlZGlyZWN0KHRvLCBmbGFzaCk7XG4gICAgfVxuICAgIGlzRGVzdHJveWVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveWVkO1xuICAgIH1cbiAgICBqb2luKGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgIHRoaXMuc3RvcENhbGxiYWNrID0gdGhpcy5saXZlU29ja2V0LndpdGhQYWdlTG9hZGluZyh7IHRvOiB0aGlzLmhyZWYsIGtpbmQ6IFwiaW5pdGlhbFwiIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5qb2luQ2FsbGJhY2sgPSAoKSA9PiBjYWxsYmFjayAmJiBjYWxsYmFjayh0aGlzLmpvaW5Db3VudCk7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQud3JhcFB1c2godGhpcywgeyB0aW1lb3V0OiBmYWxzZSB9LCAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWwuam9pbigpLnJlY2VpdmUoXCJva1wiLCAoZGF0YSkgPT4gIXRoaXMuaXNEZXN0cm95ZWQoKSAmJiB0aGlzLm9uSm9pbihkYXRhKSkucmVjZWl2ZShcImVycm9yXCIsIChyZXNwKSA9PiAhdGhpcy5pc0Rlc3Ryb3llZCgpICYmIHRoaXMub25Kb2luRXJyb3IocmVzcCkpLnJlY2VpdmUoXCJ0aW1lb3V0XCIsICgpID0+ICF0aGlzLmlzRGVzdHJveWVkKCkgJiYgdGhpcy5vbkpvaW5FcnJvcih7IHJlYXNvbjogXCJ0aW1lb3V0XCIgfSkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIG9uSm9pbkVycm9yKHJlc3ApIHtcbiAgICAgIGlmIChyZXNwLnJlYXNvbiA9PT0gXCJ1bmF1dGhvcml6ZWRcIiB8fCByZXNwLnJlYXNvbiA9PT0gXCJzdGFsZVwiKSB7XG4gICAgICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgKCkgPT4gW1widW5hdXRob3JpemVkIGxpdmVfcmVkaXJlY3QuIEZhbGxpbmcgYmFjayB0byBwYWdlIHJlcXVlc3RcIiwgcmVzcF0pO1xuICAgICAgICByZXR1cm4gdGhpcy5vblJlZGlyZWN0KHsgdG86IHRoaXMuaHJlZiB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNwLnJlZGlyZWN0IHx8IHJlc3AubGl2ZV9yZWRpcmVjdCkge1xuICAgICAgICB0aGlzLmpvaW5QZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hhbm5lbC5sZWF2ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3AucmVkaXJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25SZWRpcmVjdChyZXNwLnJlZGlyZWN0KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNwLmxpdmVfcmVkaXJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub25MaXZlUmVkaXJlY3QocmVzcC5saXZlX3JlZGlyZWN0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgKCkgPT4gW1widW5hYmxlIHRvIGpvaW5cIiwgcmVzcF0pO1xuICAgICAgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5yZWxvYWRXaXRoSml0dGVyKHRoaXMpO1xuICAgIH1cbiAgICBvbkNsb3NlKHJlYXNvbikge1xuICAgICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0pvaW5QZW5kaW5nKCkgJiYgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlICE9PSBcImhpZGRlblwiIHx8IHRoaXMubGl2ZVNvY2tldC5oYXNQZW5kaW5nTGluaygpICYmIHJlYXNvbiAhPT0gXCJsZWF2ZVwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpdmVTb2NrZXQucmVsb2FkV2l0aEppdHRlcih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVzdHJveUFsbENoaWxkcmVuKCk7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQuZHJvcEFjdGl2ZUVsZW1lbnQodGhpcyk7XG4gICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxpdmVTb2NrZXQuaXNVbmxvYWRlZCgpKSB7XG4gICAgICAgIHRoaXMuc2hvd0xvYWRlcihCRUZPUkVfVU5MT0FEX0xPQURFUl9USU1FT1VUKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb25FcnJvcihyZWFzb24pIHtcbiAgICAgIHRoaXMub25DbG9zZShyZWFzb24pO1xuICAgICAgdGhpcy5sb2coXCJlcnJvclwiLCAoKSA9PiBbXCJ2aWV3IGNyYXNoZWRcIiwgcmVhc29uXSk7XG4gICAgICBpZiAoIXRoaXMubGl2ZVNvY2tldC5pc1VubG9hZGVkKCkpIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGlzcGxheUVycm9yKCkge1xuICAgICAgaWYgKHRoaXMuaXNNYWluKCkpIHtcbiAgICAgICAgZG9tX2RlZmF1bHQuZGlzcGF0Y2hFdmVudCh3aW5kb3csIFwicGh4OnBhZ2UtbG9hZGluZy1zdGFydFwiLCB7IHRvOiB0aGlzLmhyZWYsIGtpbmQ6IFwiZXJyb3JcIiB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2hvd0xvYWRlcigpO1xuICAgICAgdGhpcy5zZXRDb250YWluZXJDbGFzc2VzKFBIWF9ESVNDT05ORUNURURfQ0xBU1MsIFBIWF9FUlJPUl9DTEFTUyk7XG4gICAgfVxuICAgIHB1c2hXaXRoUmVwbHkocmVmR2VuZXJhdG9yLCBldmVudCwgcGF5bG9hZCwgb25SZXBseSA9IGZ1bmN0aW9uKCkge1xuICAgIH0pIHtcbiAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBbcmVmLCBbZWxdXSA9IHJlZkdlbmVyYXRvciA/IHJlZkdlbmVyYXRvcigpIDogW251bGwsIFtdXTtcbiAgICAgIGxldCBvbkxvYWRpbmdEb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICB9O1xuICAgICAgaWYgKGVsICYmIGVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX1BBR0VfTE9BRElORykpICE9PSBudWxsKSB7XG4gICAgICAgIG9uTG9hZGluZ0RvbmUgPSB0aGlzLmxpdmVTb2NrZXQud2l0aFBhZ2VMb2FkaW5nKHsga2luZDogXCJlbGVtZW50XCIsIHRhcmdldDogZWwgfSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBheWxvYWQuY2lkICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGRlbGV0ZSBwYXlsb2FkLmNpZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmxpdmVTb2NrZXQud3JhcFB1c2godGhpcywgeyB0aW1lb3V0OiB0cnVlIH0sICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5wdXNoKGV2ZW50LCBwYXlsb2FkLCBQVVNIX1RJTUVPVVQpLnJlY2VpdmUoXCJva1wiLCAocmVzcCkgPT4ge1xuICAgICAgICAgIGxldCBob29rUmVwbHkgPSBudWxsO1xuICAgICAgICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudW5kb1JlZnMocmVmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3AuZGlmZikge1xuICAgICAgICAgICAgaG9va1JlcGx5ID0gdGhpcy5hcHBseURpZmYoXCJ1cGRhdGVcIiwgcmVzcC5kaWZmLCAoeyBkaWZmLCBldmVudHMgfSkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnVwZGF0ZShkaWZmLCBldmVudHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXNwLnJlZGlyZWN0KSB7XG4gICAgICAgICAgICB0aGlzLm9uUmVkaXJlY3QocmVzcC5yZWRpcmVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXNwLmxpdmVfcGF0Y2gpIHtcbiAgICAgICAgICAgIHRoaXMub25MaXZlUGF0Y2gocmVzcC5saXZlX3BhdGNoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3AubGl2ZV9yZWRpcmVjdCkge1xuICAgICAgICAgICAgdGhpcy5vbkxpdmVSZWRpcmVjdChyZXNwLmxpdmVfcmVkaXJlY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvbkxvYWRpbmdEb25lKCk7XG4gICAgICAgICAgb25SZXBseShyZXNwLCBob29rUmVwbHkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB1bmRvUmVmcyhyZWYpIHtcbiAgICAgIGRvbV9kZWZhdWx0LmFsbCh0aGlzLmVsLCBgWyR7UEhYX1JFRn09XCIke3JlZn1cIl1gLCAoZWwpID0+IHtcbiAgICAgICAgbGV0IGRpc2FibGVkVmFsID0gZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFRCk7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVGKTtcbiAgICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZShQSFhfUkVBRE9OTFkpICE9PSBudWxsKSB7XG4gICAgICAgICAgZWwucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFQURPTkxZKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzYWJsZWRWYWwgIT09IG51bGwpIHtcbiAgICAgICAgICBlbC5kaXNhYmxlZCA9IGRpc2FibGVkVmFsID09PSBcInRydWVcIiA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX0RJU0FCTEVEKTtcbiAgICAgICAgfVxuICAgICAgICBQSFhfRVZFTlRfQ0xBU1NFUy5mb3JFYWNoKChjbGFzc05hbWUpID0+IGRvbV9kZWZhdWx0LnJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpKTtcbiAgICAgICAgbGV0IGRpc2FibGVSZXN0b3JlID0gZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSk7XG4gICAgICAgIGlmIChkaXNhYmxlUmVzdG9yZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGVsLmlubmVyVGV4dCA9IGRpc2FibGVSZXN0b3JlO1xuICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b0VsID0gZG9tX2RlZmF1bHQucHJpdmF0ZShlbCwgUEhYX1JFRik7XG4gICAgICAgIGlmICh0b0VsKSB7XG4gICAgICAgICAgbGV0IGhvb2sgPSB0aGlzLnRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGVsLCB0b0VsKTtcbiAgICAgICAgICBET01QYXRjaC5wYXRjaEVsKGVsLCB0b0VsLCB0aGlzLmxpdmVTb2NrZXQuZ2V0QWN0aXZlRWxlbWVudCgpKTtcbiAgICAgICAgICBpZiAoaG9vaykge1xuICAgICAgICAgICAgaG9vay5fX3VwZGF0ZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZG9tX2RlZmF1bHQuZGVsZXRlUHJpdmF0ZShlbCwgUEhYX1JFRik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBwdXRSZWYoZWxlbWVudHMsIGV2ZW50KSB7XG4gICAgICBsZXQgbmV3UmVmID0gdGhpcy5yZWYrKztcbiAgICAgIGxldCBkaXNhYmxlV2l0aCA9IHRoaXMuYmluZGluZyhQSFhfRElTQUJMRV9XSVRIKTtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoYHBoeC0ke2V2ZW50fS1sb2FkaW5nYCk7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfUkVGLCBuZXdSZWYpO1xuICAgICAgICBsZXQgZGlzYWJsZVRleHQgPSBlbC5nZXRBdHRyaWJ1dGUoZGlzYWJsZVdpdGgpO1xuICAgICAgICBpZiAoZGlzYWJsZVRleHQgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIWVsLmdldEF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUpKSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFLCBlbC5pbm5lclRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbC5pbm5lclRleHQgPSBkaXNhYmxlVGV4dDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gW25ld1JlZiwgZWxlbWVudHNdO1xuICAgIH1cbiAgICBjb21wb25lbnRJRChlbCkge1xuICAgICAgbGV0IGNpZCA9IGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX0NPTVBPTkVOVCk7XG4gICAgICByZXR1cm4gY2lkID8gcGFyc2VJbnQoY2lkKSA6IG51bGw7XG4gICAgfVxuICAgIHRhcmdldENvbXBvbmVudElEKHRhcmdldCwgdGFyZ2V0Q3R4KSB7XG4gICAgICBpZiAodGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJ0YXJnZXRcIikpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3Nlc3RDb21wb25lbnRJRCh0YXJnZXRDdHgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGNsb3Nlc3RDb21wb25lbnRJRCh0YXJnZXRDdHgpIHtcbiAgICAgIGlmICh0YXJnZXRDdHgpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlKHRhcmdldEN0eC5jbG9zZXN0KGBbJHtQSFhfQ09NUE9ORU5UfV1gKSwgKGVsKSA9PiB0aGlzLm93bnNFbGVtZW50KGVsKSAmJiB0aGlzLmNvbXBvbmVudElEKGVsKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcHVzaEhvb2tFdmVudCh0YXJnZXRDdHgsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5KSB7XG4gICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICB0aGlzLmxvZyhcImhvb2tcIiwgKCkgPT4gW1widW5hYmxlIHRvIHB1c2ggaG9vayBldmVudC4gTGl2ZVZpZXcgbm90IGNvbm5lY3RlZFwiLCBldmVudCwgcGF5bG9hZF0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBsZXQgW3JlZiwgZWxzXSA9IHRoaXMucHV0UmVmKFtdLCBcImhvb2tcIik7XG4gICAgICB0aGlzLnB1c2hXaXRoUmVwbHkoKCkgPT4gW3JlZiwgZWxzXSwgXCJldmVudFwiLCB7XG4gICAgICAgIHR5cGU6IFwiaG9va1wiLFxuICAgICAgICBldmVudCxcbiAgICAgICAgdmFsdWU6IHBheWxvYWQsXG4gICAgICAgIGNpZDogdGhpcy5jbG9zZXN0Q29tcG9uZW50SUQodGFyZ2V0Q3R4KVxuICAgICAgfSwgKHJlc3AsIHJlcGx5KSA9PiBvblJlcGx5KHJlcGx5LCByZWYpKTtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfVxuICAgIGV4dHJhY3RNZXRhKGVsLCBtZXRhKSB7XG4gICAgICBsZXQgcHJlZml4ID0gdGhpcy5iaW5kaW5nKFwidmFsdWUtXCIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbC5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBuYW1lID0gZWwuYXR0cmlidXRlc1tpXS5uYW1lO1xuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgICBtZXRhW25hbWUucmVwbGFjZShwcmVmaXgsIFwiXCIpXSA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVsLnZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgbWV0YS52YWx1ZSA9IGVsLnZhbHVlO1xuICAgICAgICBpZiAoZWwudGFnTmFtZSA9PT0gXCJJTlBVVFwiICYmIENIRUNLQUJMRV9JTlBVVFMuaW5kZXhPZihlbC50eXBlKSA+PSAwICYmICFlbC5jaGVja2VkKSB7XG4gICAgICAgICAgZGVsZXRlIG1ldGEudmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXRhO1xuICAgIH1cbiAgICBwdXNoRXZlbnQodHlwZSwgZWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIG1ldGEpIHtcbiAgICAgIHRoaXMucHVzaFdpdGhSZXBseSgoKSA9PiB0aGlzLnB1dFJlZihbZWxdLCB0eXBlKSwgXCJldmVudFwiLCB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgICAgdmFsdWU6IHRoaXMuZXh0cmFjdE1ldGEoZWwsIG1ldGEpLFxuICAgICAgICBjaWQ6IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoZWwsIHRhcmdldEN0eClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBwdXNoS2V5KGtleUVsZW1lbnQsIHRhcmdldEN0eCwga2luZCwgcGh4RXZlbnQsIG1ldGEpIHtcbiAgICAgIHRoaXMucHVzaFdpdGhSZXBseSgoKSA9PiB0aGlzLnB1dFJlZihba2V5RWxlbWVudF0sIGtpbmQpLCBcImV2ZW50XCIsIHtcbiAgICAgICAgdHlwZToga2luZCxcbiAgICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgICB2YWx1ZTogdGhpcy5leHRyYWN0TWV0YShrZXlFbGVtZW50LCBtZXRhKSxcbiAgICAgICAgY2lkOiB0aGlzLnRhcmdldENvbXBvbmVudElEKGtleUVsZW1lbnQsIHRhcmdldEN0eClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBwdXNoRmlsZVByb2dyZXNzKGZpbGVFbCwgZW50cnlSZWYsIHByb2dyZXNzLCBvblJlcGx5ID0gZnVuY3Rpb24oKSB7XG4gICAgfSkge1xuICAgICAgdGhpcy5saXZlU29ja2V0LndpdGhpbk93bmVycyhmaWxlRWwuZm9ybSwgKHZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgICB2aWV3LnB1c2hXaXRoUmVwbHkobnVsbCwgXCJwcm9ncmVzc1wiLCB7XG4gICAgICAgICAgZXZlbnQ6IGZpbGVFbC5nZXRBdHRyaWJ1dGUodmlldy5iaW5kaW5nKFBIWF9QUk9HUkVTUykpLFxuICAgICAgICAgIHJlZjogZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRiksXG4gICAgICAgICAgZW50cnlfcmVmOiBlbnRyeVJlZixcbiAgICAgICAgICBwcm9ncmVzcyxcbiAgICAgICAgICBjaWQ6IHZpZXcudGFyZ2V0Q29tcG9uZW50SUQoZmlsZUVsLmZvcm0sIHRhcmdldEN0eClcbiAgICAgICAgfSwgb25SZXBseSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcHVzaElucHV0KGlucHV0RWwsIHRhcmdldEN0eCwgZm9yY2VDaWQsIHBoeEV2ZW50LCBldmVudFRhcmdldCwgY2FsbGJhY2spIHtcbiAgICAgIGxldCB1cGxvYWRzO1xuICAgICAgbGV0IGNpZCA9IGlzQ2lkKGZvcmNlQ2lkKSA/IGZvcmNlQ2lkIDogdGhpcy50YXJnZXRDb21wb25lbnRJRChpbnB1dEVsLmZvcm0sIHRhcmdldEN0eCk7XG4gICAgICBsZXQgcmVmR2VuZXJhdG9yID0gKCkgPT4gdGhpcy5wdXRSZWYoW2lucHV0RWwsIGlucHV0RWwuZm9ybV0sIFwiY2hhbmdlXCIpO1xuICAgICAgbGV0IGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShpbnB1dEVsLmZvcm0sIHsgX3RhcmdldDogZXZlbnRUYXJnZXQubmFtZSB9KTtcbiAgICAgIGlmIChpbnB1dEVsLmZpbGVzICYmIGlucHV0RWwuZmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBMaXZlVXBsb2FkZXIudHJhY2tGaWxlcyhpbnB1dEVsLCBBcnJheS5mcm9tKGlucHV0RWwuZmlsZXMpKTtcbiAgICAgIH1cbiAgICAgIHVwbG9hZHMgPSBMaXZlVXBsb2FkZXIuc2VyaWFsaXplVXBsb2FkcyhpbnB1dEVsKTtcbiAgICAgIGxldCBldmVudCA9IHtcbiAgICAgICAgdHlwZTogXCJmb3JtXCIsXG4gICAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgICAgdmFsdWU6IGZvcm1EYXRhLFxuICAgICAgICB1cGxvYWRzLFxuICAgICAgICBjaWRcbiAgICAgIH07XG4gICAgICB0aGlzLnB1c2hXaXRoUmVwbHkocmVmR2VuZXJhdG9yLCBcImV2ZW50XCIsIGV2ZW50LCAocmVzcCkgPT4ge1xuICAgICAgICBkb21fZGVmYXVsdC5zaG93RXJyb3IoaW5wdXRFbCwgdGhpcy5saXZlU29ja2V0LmJpbmRpbmcoUEhYX0ZFRURCQUNLX0ZPUikpO1xuICAgICAgICBpZiAoZG9tX2RlZmF1bHQuaXNVcGxvYWRJbnB1dChpbnB1dEVsKSAmJiBpbnB1dEVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWF1dG8tdXBsb2FkXCIpICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKExpdmVVcGxvYWRlci5maWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0RWwpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBbcmVmLCBfZWxzXSA9IHJlZkdlbmVyYXRvcigpO1xuICAgICAgICAgICAgdGhpcy51cGxvYWRGaWxlcyhpbnB1dEVsLmZvcm0sIHRhcmdldEN0eCwgcmVmLCBjaWQsIChfdXBsb2FkcykgPT4ge1xuICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXNwKTtcbiAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyQXdhaXRpbmdTdWJtaXQoaW5wdXRFbC5mb3JtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhyZXNwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRyaWdnZXJBd2FpdGluZ1N1Ym1pdChmb3JtRWwpIHtcbiAgICAgIGxldCBhd2FpdGluZ1N1Ym1pdCA9IHRoaXMuZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbCk7XG4gICAgICBpZiAoYXdhaXRpbmdTdWJtaXQpIHtcbiAgICAgICAgbGV0IFtfZWwsIF9yZWYsIGNhbGxiYWNrXSA9IGF3YWl0aW5nU3VibWl0O1xuICAgICAgICB0aGlzLmNhbmNlbFN1Ym1pdChmb3JtRWwpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXRTY2hlZHVsZWRTdWJtaXQoZm9ybUVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3JtU3VibWl0cy5maW5kKChbZWwsIF9jYWxsYmFja10pID0+IGVsLmlzU2FtZU5vZGUoZm9ybUVsKSk7XG4gICAgfVxuICAgIHNjaGVkdWxlU3VibWl0KGZvcm1FbCwgcmVmLCBjYWxsYmFjaykge1xuICAgICAgaWYgKHRoaXMuZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLmZvcm1TdWJtaXRzLnB1c2goW2Zvcm1FbCwgcmVmLCBjYWxsYmFja10pO1xuICAgIH1cbiAgICBjYW5jZWxTdWJtaXQoZm9ybUVsKSB7XG4gICAgICB0aGlzLmZvcm1TdWJtaXRzID0gdGhpcy5mb3JtU3VibWl0cy5maWx0ZXIoKFtlbCwgcmVmLCBfY2FsbGJhY2tdKSA9PiB7XG4gICAgICAgIGlmIChlbC5pc1NhbWVOb2RlKGZvcm1FbCkpIHtcbiAgICAgICAgICB0aGlzLnVuZG9SZWZzKHJlZik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcHVzaEZvcm1TdWJtaXQoZm9ybUVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBvblJlcGx5KSB7XG4gICAgICBsZXQgZmlsdGVySWdub3JlZCA9IChlbCkgPT4ge1xuICAgICAgICBsZXQgdXNlcklnbm9yZWQgPSBjbG9zZXN0UGh4QmluZGluZyhlbCwgYCR7dGhpcy5iaW5kaW5nKFBIWF9VUERBVEUpfT1pZ25vcmVgLCBlbC5mb3JtKTtcbiAgICAgICAgcmV0dXJuICEodXNlcklnbm9yZWQgfHwgY2xvc2VzdFBoeEJpbmRpbmcoZWwsIFwiZGF0YS1waHgtdXBkYXRlPWlnbm9yZVwiLCBlbC5mb3JtKSk7XG4gICAgICB9O1xuICAgICAgbGV0IGZpbHRlckRpc2FibGVzID0gKGVsKSA9PiB7XG4gICAgICAgIHJldHVybiBlbC5oYXNBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9ESVNBQkxFX1dJVEgpKTtcbiAgICAgIH07XG4gICAgICBsZXQgZmlsdGVyQnV0dG9uID0gKGVsKSA9PiBlbC50YWdOYW1lID09IFwiQlVUVE9OXCI7XG4gICAgICBsZXQgZmlsdGVySW5wdXQgPSAoZWwpID0+IFtcIklOUFVUXCIsIFwiVEVYVEFSRUFcIiwgXCJTRUxFQ1RcIl0uaW5jbHVkZXMoZWwudGFnTmFtZSk7XG4gICAgICBsZXQgcmVmR2VuZXJhdG9yID0gKCkgPT4ge1xuICAgICAgICBsZXQgZm9ybUVsZW1lbnRzID0gQXJyYXkuZnJvbShmb3JtRWwuZWxlbWVudHMpO1xuICAgICAgICBsZXQgZGlzYWJsZXMgPSBmb3JtRWxlbWVudHMuZmlsdGVyKGZpbHRlckRpc2FibGVzKTtcbiAgICAgICAgbGV0IGJ1dHRvbnMgPSBmb3JtRWxlbWVudHMuZmlsdGVyKGZpbHRlckJ1dHRvbikuZmlsdGVyKGZpbHRlcklnbm9yZWQpO1xuICAgICAgICBsZXQgaW5wdXRzID0gZm9ybUVsZW1lbnRzLmZpbHRlcihmaWx0ZXJJbnB1dCkuZmlsdGVyKGZpbHRlcklnbm9yZWQpO1xuICAgICAgICBidXR0b25zLmZvckVhY2goKGJ1dHRvbikgPT4ge1xuICAgICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBidXR0b24uZGlzYWJsZWQpO1xuICAgICAgICAgIGJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoUEhYX1JFQURPTkxZLCBpbnB1dC5yZWFkT25seSk7XG4gICAgICAgICAgaW5wdXQucmVhZE9ubHkgPSB0cnVlO1xuICAgICAgICAgIGlmIChpbnB1dC5maWxlcykge1xuICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFRCwgaW5wdXQuZGlzYWJsZWQpO1xuICAgICAgICAgICAgaW5wdXQuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvcm1FbC5zZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9QQUdFX0xPQURJTkcpLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHV0UmVmKFtmb3JtRWxdLmNvbmNhdChkaXNhYmxlcykuY29uY2F0KGJ1dHRvbnMpLmNvbmNhdChpbnB1dHMpLCBcInN1Ym1pdFwiKTtcbiAgICAgIH07XG4gICAgICBsZXQgY2lkID0gdGhpcy50YXJnZXRDb21wb25lbnRJRChmb3JtRWwsIHRhcmdldEN0eCk7XG4gICAgICBpZiAoTGl2ZVVwbG9hZGVyLmhhc1VwbG9hZHNJblByb2dyZXNzKGZvcm1FbCkpIHtcbiAgICAgICAgbGV0IFtyZWYsIF9lbHNdID0gcmVmR2VuZXJhdG9yKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlU3VibWl0KGZvcm1FbCwgcmVmLCAoKSA9PiB0aGlzLnB1c2hGb3JtU3VibWl0KGZvcm1FbCwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgb25SZXBseSkpO1xuICAgICAgfSBlbHNlIGlmIChMaXZlVXBsb2FkZXIuaW5wdXRzQXdhaXRpbmdQcmVmbGlnaHQoZm9ybUVsKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxldCBbcmVmLCBlbHNdID0gcmVmR2VuZXJhdG9yKCk7XG4gICAgICAgIGxldCBwcm94eVJlZkdlbiA9ICgpID0+IFtyZWYsIGVsc107XG4gICAgICAgIHRoaXMudXBsb2FkRmlsZXMoZm9ybUVsLCB0YXJnZXRDdHgsIHJlZiwgY2lkLCAoX3VwbG9hZHMpID0+IHtcbiAgICAgICAgICBsZXQgZm9ybURhdGEgPSBzZXJpYWxpemVGb3JtKGZvcm1FbCwge30pO1xuICAgICAgICAgIHRoaXMucHVzaFdpdGhSZXBseShwcm94eVJlZkdlbiwgXCJldmVudFwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImZvcm1cIixcbiAgICAgICAgICAgIGV2ZW50OiBwaHhFdmVudCxcbiAgICAgICAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgICAgICAgIGNpZFxuICAgICAgICAgIH0sIG9uUmVwbHkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBmb3JtRGF0YSA9IHNlcmlhbGl6ZUZvcm0oZm9ybUVsKTtcbiAgICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KHJlZkdlbmVyYXRvciwgXCJldmVudFwiLCB7XG4gICAgICAgICAgdHlwZTogXCJmb3JtXCIsXG4gICAgICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgICAgIHZhbHVlOiBmb3JtRGF0YSxcbiAgICAgICAgICBjaWRcbiAgICAgICAgfSwgb25SZXBseSk7XG4gICAgICB9XG4gICAgfVxuICAgIHVwbG9hZEZpbGVzKGZvcm1FbCwgdGFyZ2V0Q3R4LCByZWYsIGNpZCwgb25Db21wbGV0ZSkge1xuICAgICAgbGV0IGpvaW5Db3VudEF0VXBsb2FkID0gdGhpcy5qb2luQ291bnQ7XG4gICAgICBsZXQgaW5wdXRFbHMgPSBMaXZlVXBsb2FkZXIuYWN0aXZlRmlsZUlucHV0cyhmb3JtRWwpO1xuICAgICAgbGV0IG51bUZpbGVJbnB1dHNJblByb2dyZXNzID0gaW5wdXRFbHMubGVuZ3RoO1xuICAgICAgaW5wdXRFbHMuZm9yRWFjaCgoaW5wdXRFbCkgPT4ge1xuICAgICAgICBsZXQgdXBsb2FkZXIgPSBuZXcgTGl2ZVVwbG9hZGVyKGlucHV0RWwsIHRoaXMsICgpID0+IHtcbiAgICAgICAgICBudW1GaWxlSW5wdXRzSW5Qcm9ncmVzcy0tO1xuICAgICAgICAgIGlmIChudW1GaWxlSW5wdXRzSW5Qcm9ncmVzcyA9PT0gMCkge1xuICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBsb2FkZXJzW2lucHV0RWxdID0gdXBsb2FkZXI7XG4gICAgICAgIGxldCBlbnRyaWVzID0gdXBsb2FkZXIuZW50cmllcygpLm1hcCgoZW50cnkpID0+IGVudHJ5LnRvUHJlZmxpZ2h0UGF5bG9hZCgpKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7XG4gICAgICAgICAgcmVmOiBpbnB1dEVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRiksXG4gICAgICAgICAgZW50cmllcyxcbiAgICAgICAgICBjaWQ6IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoaW5wdXRFbC5mb3JtLCB0YXJnZXRDdHgpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9nKFwidXBsb2FkXCIsICgpID0+IFtcInNlbmRpbmcgcHJlZmxpZ2h0IHJlcXVlc3RcIiwgcGF5bG9hZF0pO1xuICAgICAgICB0aGlzLnB1c2hXaXRoUmVwbHkobnVsbCwgXCJhbGxvd191cGxvYWRcIiwgcGF5bG9hZCwgKHJlc3ApID0+IHtcbiAgICAgICAgICB0aGlzLmxvZyhcInVwbG9hZFwiLCAoKSA9PiBbXCJnb3QgcHJlZmxpZ2h0IHJlc3BvbnNlXCIsIHJlc3BdKTtcbiAgICAgICAgICBpZiAocmVzcC5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy51bmRvUmVmcyhyZWYpO1xuICAgICAgICAgICAgbGV0IFtlbnRyeV9yZWYsIHJlYXNvbl0gPSByZXNwLmVycm9yO1xuICAgICAgICAgICAgdGhpcy5sb2coXCJ1cGxvYWRcIiwgKCkgPT4gW2BlcnJvciBmb3IgZW50cnkgJHtlbnRyeV9yZWZ9YCwgcmVhc29uXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBvbkVycm9yID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5vbkVycm9yKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5qb2luQ291bnQgPT09IGpvaW5Db3VudEF0VXBsb2FkKSB7XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdXBsb2FkZXIuaW5pdEFkYXB0ZXJVcGxvYWQocmVzcCwgb25FcnJvciwgdGhpcy5saXZlU29ja2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGRpc3BhdGNoVXBsb2FkcyhuYW1lLCBmaWxlc09yQmxvYnMpIHtcbiAgICAgIGxldCBpbnB1dHMgPSBkb21fZGVmYXVsdC5maW5kVXBsb2FkSW5wdXRzKHRoaXMuZWwpLmZpbHRlcigoZWwpID0+IGVsLm5hbWUgPT09IG5hbWUpO1xuICAgICAgaWYgKGlucHV0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbG9nRXJyb3IoYG5vIGxpdmUgZmlsZSBpbnB1dHMgZm91bmQgbWF0Y2hpbmcgdGhlIG5hbWUgXCIke25hbWV9XCJgKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbG9nRXJyb3IoYGR1cGxpY2F0ZSBsaXZlIGZpbGUgaW5wdXRzIGZvdW5kIG1hdGNoaW5nIHRoZSBuYW1lIFwiJHtuYW1lfVwiYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb21fZGVmYXVsdC5kaXNwYXRjaEV2ZW50KGlucHV0c1swXSwgUEhYX1RSQUNLX1VQTE9BRFMsIHsgZmlsZXM6IGZpbGVzT3JCbG9icyB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHVzaEZvcm1SZWNvdmVyeShmb3JtLCBuZXdDaWQsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQud2l0aGluT3duZXJzKGZvcm0sICh2aWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgICAgbGV0IGlucHV0ID0gZm9ybS5lbGVtZW50c1swXTtcbiAgICAgICAgbGV0IHBoeEV2ZW50ID0gZm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9BVVRPX1JFQ09WRVIpKSB8fCBmb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIikpO1xuICAgICAgICB2aWV3LnB1c2hJbnB1dChpbnB1dCwgdGFyZ2V0Q3R4LCBuZXdDaWQsIHBoeEV2ZW50LCBpbnB1dCwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHB1c2hMaW5rUGF0Y2goaHJlZiwgdGFyZ2V0RWwsIGNhbGxiYWNrKSB7XG4gICAgICBsZXQgbGlua1JlZiA9IHRoaXMubGl2ZVNvY2tldC5zZXRQZW5kaW5nTGluayhocmVmKTtcbiAgICAgIGxldCByZWZHZW4gPSB0YXJnZXRFbCA/ICgpID0+IHRoaXMucHV0UmVmKFt0YXJnZXRFbF0sIFwiY2xpY2tcIikgOiBudWxsO1xuICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KHJlZkdlbiwgXCJsaXZlX3BhdGNoXCIsIHsgdXJsOiBocmVmIH0sIChyZXNwKSA9PiB7XG4gICAgICAgIGlmIChyZXNwLmxpbmtfcmVkaXJlY3QpIHtcbiAgICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVwbGFjZU1haW4oaHJlZiwgbnVsbCwgY2FsbGJhY2ssIGxpbmtSZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmxpdmVTb2NrZXQuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpIHtcbiAgICAgICAgICAgIHRoaXMuaHJlZiA9IGhyZWY7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYXBwbHlQZW5kaW5nVXBkYXRlcygpO1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGxpbmtSZWYpO1xuICAgICAgICB9XG4gICAgICB9KS5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiB0aGlzLmxpdmVTb2NrZXQucmVkaXJlY3Qod2luZG93LmxvY2F0aW9uLmhyZWYpKTtcbiAgICB9XG4gICAgZm9ybXNGb3JSZWNvdmVyeShodG1sKSB7XG4gICAgICBpZiAodGhpcy5qb2luQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbGV0IHBoeENoYW5nZSA9IHRoaXMuYmluZGluZyhcImNoYW5nZVwiKTtcbiAgICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICByZXR1cm4gZG9tX2RlZmF1bHQuYWxsKHRoaXMuZWwsIGBmb3JtWyR7cGh4Q2hhbmdlfV1gKS5maWx0ZXIoKGZvcm0pID0+IGZvcm0uaWQgJiYgdGhpcy5vd25zRWxlbWVudChmb3JtKSkuZmlsdGVyKChmb3JtKSA9PiBmb3JtLmVsZW1lbnRzLmxlbmd0aCA+IDApLmZpbHRlcigoZm9ybSkgPT4gZm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9BVVRPX1JFQ09WRVIpKSAhPT0gXCJpZ25vcmVcIikubWFwKChmb3JtKSA9PiB7XG4gICAgICAgIGxldCBuZXdGb3JtID0gdGVtcGxhdGUuY29udGVudC5xdWVyeVNlbGVjdG9yKGBmb3JtW2lkPVwiJHtmb3JtLmlkfVwiXVske3BoeENoYW5nZX09XCIke2Zvcm0uZ2V0QXR0cmlidXRlKHBoeENoYW5nZSl9XCJdYCk7XG4gICAgICAgIGlmIChuZXdGb3JtKSB7XG4gICAgICAgICAgcmV0dXJuIFtmb3JtLCBuZXdGb3JtLCB0aGlzLmNvbXBvbmVudElEKG5ld0Zvcm0pXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW2Zvcm0sIG51bGwsIG51bGxdO1xuICAgICAgICB9XG4gICAgICB9KS5maWx0ZXIoKFtmb3JtLCBuZXdGb3JtLCBuZXdDaWRdKSA9PiBuZXdGb3JtKTtcbiAgICB9XG4gICAgbWF5YmVQdXNoQ29tcG9uZW50c0Rlc3Ryb3llZChkZXN0cm95ZWRDSURzKSB7XG4gICAgICBsZXQgd2lsbERlc3Ryb3lDSURzID0gZGVzdHJveWVkQ0lEcy5maWx0ZXIoKGNpZCkgPT4ge1xuICAgICAgICByZXR1cm4gZG9tX2RlZmF1bHQuZmluZENvbXBvbmVudE5vZGVMaXN0KHRoaXMuZWwsIGNpZCkubGVuZ3RoID09PSAwO1xuICAgICAgfSk7XG4gICAgICBpZiAod2lsbERlc3Ryb3lDSURzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5wcnVuaW5nQ0lEcy5wdXNoKC4uLndpbGxEZXN0cm95Q0lEcyk7XG4gICAgICAgIHRoaXMucHVzaFdpdGhSZXBseShudWxsLCBcImNpZHNfd2lsbF9kZXN0cm95XCIsIHsgY2lkczogd2lsbERlc3Ryb3lDSURzIH0sICgpID0+IHtcbiAgICAgICAgICB0aGlzLnBydW5pbmdDSURzID0gdGhpcy5wcnVuaW5nQ0lEcy5maWx0ZXIoKGNpZCkgPT4gd2lsbERlc3Ryb3lDSURzLmluZGV4T2YoY2lkKSAhPT0gLTEpO1xuICAgICAgICAgIGxldCBjb21wbGV0ZWx5RGVzdHJveUNJRHMgPSB3aWxsRGVzdHJveUNJRHMuZmlsdGVyKChjaWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkb21fZGVmYXVsdC5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5lbCwgY2lkKS5sZW5ndGggPT09IDA7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGNvbXBsZXRlbHlEZXN0cm95Q0lEcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hXaXRoUmVwbHkobnVsbCwgXCJjaWRzX2Rlc3Ryb3llZFwiLCB7IGNpZHM6IGNvbXBsZXRlbHlEZXN0cm95Q0lEcyB9LCAocmVzcCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVkLnBydW5lQ0lEcyhyZXNwLmNpZHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgb3duc0VsZW1lbnQoZWwpIHtcbiAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRCkgPT09IHRoaXMuaWQgfHwgbWF5YmUoZWwuY2xvc2VzdChQSFhfVklFV19TRUxFQ1RPUiksIChub2RlKSA9PiBub2RlLmlkKSA9PT0gdGhpcy5pZDtcbiAgICB9XG4gICAgc3VibWl0Rm9ybShmb3JtLCB0YXJnZXRDdHgsIHBoeEV2ZW50KSB7XG4gICAgICBkb21fZGVmYXVsdC5wdXRQcml2YXRlKGZvcm0sIFBIWF9IQVNfU1VCTUlUVEVELCB0cnVlKTtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5ibHVyQWN0aXZlRWxlbWVudCh0aGlzKTtcbiAgICAgIHRoaXMucHVzaEZvcm1TdWJtaXQoZm9ybSwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgKCkgPT4ge1xuICAgICAgICB0aGlzLmxpdmVTb2NrZXQucmVzdG9yZVByZXZpb3VzbHlBY3RpdmVGb2N1cygpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGJpbmRpbmcoa2luZCkge1xuICAgICAgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKGtpbmQpO1xuICAgIH1cbiAgfTtcblxuICAvLyBqcy9waG9lbml4X2xpdmVfdmlldy9saXZlX3NvY2tldC5qc1xuICB2YXIgTGl2ZVNvY2tldCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHBoeFNvY2tldCwgb3B0cyA9IHt9KSB7XG4gICAgICB0aGlzLnVubG9hZGVkID0gZmFsc2U7XG4gICAgICBpZiAoIXBoeFNvY2tldCB8fCBwaHhTb2NrZXQuY29uc3RydWN0b3IubmFtZSA9PT0gXCJPYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxuICAgICAgYSBwaG9lbml4IFNvY2tldCBtdXN0IGJlIHByb3ZpZGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIExpdmVTb2NrZXQgY29uc3RydWN0b3IuIEZvciBleGFtcGxlOlxuXG4gICAgICAgICAgaW1wb3J0IHtTb2NrZXR9IGZyb20gXCJwaG9lbml4XCJcbiAgICAgICAgICBpbXBvcnQgTGl2ZVNvY2tldCBmcm9tIFwicGhvZW5peF9saXZlX3ZpZXdcIlxuICAgICAgICAgIGxldCBsaXZlU29ja2V0ID0gbmV3IExpdmVTb2NrZXQoXCIvbGl2ZVwiLCBTb2NrZXQsIHsuLi59KVxuICAgICAgYCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNvY2tldCA9IG5ldyBwaHhTb2NrZXQodXJsLCBvcHRzKTtcbiAgICAgIHRoaXMuYmluZGluZ1ByZWZpeCA9IG9wdHMuYmluZGluZ1ByZWZpeCB8fCBCSU5ESU5HX1BSRUZJWDtcbiAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUob3B0cy5wYXJhbXMgfHwge30pO1xuICAgICAgdGhpcy52aWV3TG9nZ2VyID0gb3B0cy52aWV3TG9nZ2VyO1xuICAgICAgdGhpcy5tZXRhZGF0YUNhbGxiYWNrcyA9IG9wdHMubWV0YWRhdGEgfHwge307XG4gICAgICB0aGlzLmRlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihjbG9uZShERUZBVUxUUyksIG9wdHMuZGVmYXVsdHMgfHwge30pO1xuICAgICAgdGhpcy5hY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMucHJldkFjdGl2ZSA9IG51bGw7XG4gICAgICB0aGlzLnNpbGVuY2VkID0gZmFsc2U7XG4gICAgICB0aGlzLm1haW4gPSBudWxsO1xuICAgICAgdGhpcy5saW5rUmVmID0gMTtcbiAgICAgIHRoaXMucm9vdHMgPSB7fTtcbiAgICAgIHRoaXMuaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgICAgdGhpcy5wZW5kaW5nTGluayA9IG51bGw7XG4gICAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGNsb25lKHdpbmRvdy5sb2NhdGlvbik7XG4gICAgICB0aGlzLmhvb2tzID0gb3B0cy5ob29rcyB8fCB7fTtcbiAgICAgIHRoaXMudXBsb2FkZXJzID0gb3B0cy51cGxvYWRlcnMgfHwge307XG4gICAgICB0aGlzLmxvYWRlclRpbWVvdXQgPSBvcHRzLmxvYWRlclRpbWVvdXQgfHwgTE9BREVSX1RJTUVPVVQ7XG4gICAgICB0aGlzLmxvY2FsU3RvcmFnZSA9IG9wdHMubG9jYWxTdG9yYWdlIHx8IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICB0aGlzLnNlc3Npb25TdG9yYWdlID0gb3B0cy5zZXNzaW9uU3RvcmFnZSB8fCB3aW5kb3cuc2Vzc2lvblN0b3JhZ2U7XG4gICAgICB0aGlzLmJvdW5kVG9wTGV2ZWxFdmVudHMgPSBmYWxzZTtcbiAgICAgIHRoaXMuZG9tQ2FsbGJhY2tzID0gT2JqZWN0LmFzc2lnbih7IG9uTm9kZUFkZGVkOiBjbG9zdXJlKCksIG9uQmVmb3JlRWxVcGRhdGVkOiBjbG9zdXJlKCkgfSwgb3B0cy5kb20gfHwge30pO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCAoX2UpID0+IHtcbiAgICAgICAgdGhpcy51bmxvYWRlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc29ja2V0Lm9uT3BlbigoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmlzVW5sb2FkZWQoKSkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlzUHJvZmlsZUVuYWJsZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFBIWF9MVl9QUk9GSUxFKSA9PT0gXCJ0cnVlXCI7XG4gICAgfVxuICAgIGlzRGVidWdFbmFibGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfREVCVUcpID09PSBcInRydWVcIjtcbiAgICB9XG4gICAgZW5hYmxlRGVidWcoKSB7XG4gICAgICB0aGlzLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oUEhYX0xWX0RFQlVHLCBcInRydWVcIik7XG4gICAgfVxuICAgIGVuYWJsZVByb2ZpbGluZygpIHtcbiAgICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfUFJPRklMRSwgXCJ0cnVlXCIpO1xuICAgIH1cbiAgICBkaXNhYmxlRGVidWcoKSB7XG4gICAgICB0aGlzLnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oUEhYX0xWX0RFQlVHKTtcbiAgICB9XG4gICAgZGlzYWJsZVByb2ZpbGluZygpIHtcbiAgICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShQSFhfTFZfUFJPRklMRSk7XG4gICAgfVxuICAgIGVuYWJsZUxhdGVuY3lTaW0odXBwZXJCb3VuZE1zKSB7XG4gICAgICB0aGlzLmVuYWJsZURlYnVnKCk7XG4gICAgICBjb25zb2xlLmxvZyhcImxhdGVuY3kgc2ltdWxhdG9yIGVuYWJsZWQgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGlzIGJyb3dzZXIgc2Vzc2lvbi4gQ2FsbCBkaXNhYmxlTGF0ZW5jeVNpbSgpIHRvIGRpc2FibGVcIik7XG4gICAgICB0aGlzLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oUEhYX0xWX0xBVEVOQ1lfU0lNLCB1cHBlckJvdW5kTXMpO1xuICAgIH1cbiAgICBkaXNhYmxlTGF0ZW5jeVNpbSgpIHtcbiAgICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShQSFhfTFZfTEFURU5DWV9TSU0pO1xuICAgIH1cbiAgICBnZXRMYXRlbmN5U2ltKCkge1xuICAgICAgbGV0IHN0ciA9IHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfTEFURU5DWV9TSU0pO1xuICAgICAgcmV0dXJuIHN0ciA/IHBhcnNlSW50KHN0cikgOiBudWxsO1xuICAgIH1cbiAgICBnZXRTb2NrZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb2NrZXQ7XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICBsZXQgZG9Db25uZWN0ID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5qb2luUm9vdFZpZXdzKCkpIHtcbiAgICAgICAgICB0aGlzLmJpbmRUb3BMZXZlbEV2ZW50cygpO1xuICAgICAgICAgIHRoaXMuc29ja2V0LmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChbXCJjb21wbGV0ZVwiLCBcImxvYWRlZFwiLCBcImludGVyYWN0aXZlXCJdLmluZGV4T2YoZG9jdW1lbnQucmVhZHlTdGF0ZSkgPj0gMCkge1xuICAgICAgICBkb0Nvbm5lY3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IGRvQ29ubmVjdCgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdChjYWxsYmFjaykge1xuICAgICAgdGhpcy5zb2NrZXQuZGlzY29ubmVjdChjYWxsYmFjayk7XG4gICAgfVxuICAgIHRyaWdnZXJET00oa2luZCwgYXJncykge1xuICAgICAgdGhpcy5kb21DYWxsYmFja3Nba2luZF0oLi4uYXJncyk7XG4gICAgfVxuICAgIHRpbWUobmFtZSwgZnVuYykge1xuICAgICAgaWYgKCF0aGlzLmlzUHJvZmlsZUVuYWJsZWQoKSB8fCAhY29uc29sZS50aW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jKCk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLnRpbWUobmFtZSk7XG4gICAgICBsZXQgcmVzdWx0ID0gZnVuYygpO1xuICAgICAgY29uc29sZS50aW1lRW5kKG5hbWUpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbG9nKHZpZXcsIGtpbmQsIG1zZ0NhbGxiYWNrKSB7XG4gICAgICBpZiAodGhpcy52aWV3TG9nZ2VyKSB7XG4gICAgICAgIGxldCBbbXNnLCBvYmpdID0gbXNnQ2FsbGJhY2soKTtcbiAgICAgICAgdGhpcy52aWV3TG9nZ2VyKHZpZXcsIGtpbmQsIG1zZywgb2JqKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0RlYnVnRW5hYmxlZCgpKSB7XG4gICAgICAgIGxldCBbbXNnLCBvYmpdID0gbXNnQ2FsbGJhY2soKTtcbiAgICAgICAgZGVidWcodmlldywga2luZCwgbXNnLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICBvbkNoYW5uZWwoY2hhbm5lbCwgZXZlbnQsIGNiKSB7XG4gICAgICBjaGFubmVsLm9uKGV2ZW50LCAoZGF0YSkgPT4ge1xuICAgICAgICBsZXQgbGF0ZW5jeSA9IHRoaXMuZ2V0TGF0ZW5jeVNpbSgpO1xuICAgICAgICBpZiAoIWxhdGVuY3kpIHtcbiAgICAgICAgICBjYihkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgc2ltdWxhdGluZyAke2xhdGVuY3l9bXMgb2YgbGF0ZW5jeSBmcm9tIHNlcnZlciB0byBjbGllbnRgKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGNiKGRhdGEpLCBsYXRlbmN5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHdyYXBQdXNoKHZpZXcsIG9wdHMsIHB1c2gpIHtcbiAgICAgIGxldCBsYXRlbmN5ID0gdGhpcy5nZXRMYXRlbmN5U2ltKCk7XG4gICAgICBsZXQgb2xkSm9pbkNvdW50ID0gdmlldy5qb2luQ291bnQ7XG4gICAgICBpZiAoIWxhdGVuY3kpIHtcbiAgICAgICAgaWYgKG9wdHMudGltZW91dCkge1xuICAgICAgICAgIHJldHVybiBwdXNoKCkucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuam9pbkNvdW50ID09PSBvbGRKb2luQ291bnQgJiYgIXZpZXcuaXNEZXN0cm95ZWQoKSkge1xuICAgICAgICAgICAgICB0aGlzLnJlbG9hZFdpdGhKaXR0ZXIodmlldywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKHZpZXcsIFwidGltZW91dFwiLCAoKSA9PiBbXCJyZWNlaXZlZCB0aW1lb3V0IHdoaWxlIGNvbW11bmljYXRpbmcgd2l0aCBzZXJ2ZXIuIEZhbGxpbmcgYmFjayB0byBoYXJkIHJlZnJlc2ggZm9yIHJlY292ZXJ5XCJdKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHB1c2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coYHNpbXVsYXRpbmcgJHtsYXRlbmN5fW1zIG9mIGxhdGVuY3kgZnJvbSBjbGllbnQgdG8gc2VydmVyYCk7XG4gICAgICBsZXQgZmFrZVB1c2ggPSB7XG4gICAgICAgIHJlY2VpdmVzOiBbXSxcbiAgICAgICAgcmVjZWl2ZShraW5kLCBjYikge1xuICAgICAgICAgIHRoaXMucmVjZWl2ZXMucHVzaChba2luZCwgY2JdKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodmlldy5pc0Rlc3Ryb3llZCgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZha2VQdXNoLnJlY2VpdmVzLnJlZHVjZSgoYWNjLCBba2luZCwgY2JdKSA9PiBhY2MucmVjZWl2ZShraW5kLCBjYiksIHB1c2goKSk7XG4gICAgICB9LCBsYXRlbmN5KTtcbiAgICAgIHJldHVybiBmYWtlUHVzaDtcbiAgICB9XG4gICAgcmVsb2FkV2l0aEppdHRlcih2aWV3LCBsb2cpIHtcbiAgICAgIHZpZXcuZGVzdHJveSgpO1xuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICBsZXQgW21pbk1zLCBtYXhNc10gPSBSRUxPQURfSklUVEVSO1xuICAgICAgbGV0IGFmdGVyTXMgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4TXMgLSBtaW5NcyArIDEpKSArIG1pbk1zO1xuICAgICAgbGV0IHRyaWVzID0gYnJvd3Nlcl9kZWZhdWx0LnVwZGF0ZUxvY2FsKHRoaXMubG9jYWxTdG9yYWdlLCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsIENPTlNFQ1VUSVZFX1JFTE9BRFMsIDAsIChjb3VudCkgPT4gY291bnQgKyAxKTtcbiAgICAgIGxvZyA/IGxvZygpIDogdGhpcy5sb2codmlldywgXCJqb2luXCIsICgpID0+IFtgZW5jb3VudGVyZWQgJHt0cmllc30gY29uc2VjdXRpdmUgcmVsb2Fkc2BdKTtcbiAgICAgIGlmICh0cmllcyA+IE1BWF9SRUxPQURTKSB7XG4gICAgICAgIHRoaXMubG9nKHZpZXcsIFwiam9pblwiLCAoKSA9PiBbYGV4Y2VlZGVkICR7TUFYX1JFTE9BRFN9IGNvbnNlY3V0aXZlIHJlbG9hZHMuIEVudGVyaW5nIGZhaWxzYWZlIG1vZGVgXSk7XG4gICAgICAgIGFmdGVyTXMgPSBGQUlMU0FGRV9KSVRURVI7XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaGFzUGVuZGluZ0xpbmsoKSkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IHRoaXMucGVuZGluZ0xpbms7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9LCBhZnRlck1zKTtcbiAgICB9XG4gICAgZ2V0SG9va0NhbGxiYWNrcyhuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZSAmJiBuYW1lLnN0YXJ0c1dpdGgoXCJQaG9lbml4LlwiKSA/IGhvb2tzX2RlZmF1bHRbbmFtZS5zcGxpdChcIi5cIilbMV1dIDogdGhpcy5ob29rc1tuYW1lXTtcbiAgICB9XG4gICAgaXNVbmxvYWRlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnVubG9hZGVkO1xuICAgIH1cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpO1xuICAgIH1cbiAgICBnZXRCaW5kaW5nUHJlZml4KCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ1ByZWZpeDtcbiAgICB9XG4gICAgYmluZGluZyhraW5kKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5nZXRCaW5kaW5nUHJlZml4KCl9JHtraW5kfWA7XG4gICAgfVxuICAgIGNoYW5uZWwodG9waWMsIHBhcmFtcykge1xuICAgICAgcmV0dXJuIHRoaXMuc29ja2V0LmNoYW5uZWwodG9waWMsIHBhcmFtcyk7XG4gICAgfVxuICAgIGpvaW5Sb290Vmlld3MoKSB7XG4gICAgICBsZXQgcm9vdHNGb3VuZCA9IGZhbHNlO1xuICAgICAgZG9tX2RlZmF1bHQuYWxsKGRvY3VtZW50LCBgJHtQSFhfVklFV19TRUxFQ1RPUn06bm90KFske1BIWF9QQVJFTlRfSUR9XSlgLCAocm9vdEVsKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5nZXRSb290QnlJZChyb290RWwuaWQpKSB7XG4gICAgICAgICAgbGV0IHZpZXcgPSB0aGlzLm5ld1Jvb3RWaWV3KHJvb3RFbCk7XG4gICAgICAgICAgdmlldy5zZXRIcmVmKHRoaXMuZ2V0SHJlZigpKTtcbiAgICAgICAgICB2aWV3LmpvaW4oKTtcbiAgICAgICAgICBpZiAocm9vdEVsLmdldEF0dHJpYnV0ZShQSFhfTUFJTikpIHtcbiAgICAgICAgICAgIHRoaXMubWFpbiA9IHZpZXc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJvb3RzRm91bmQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcm9vdHNGb3VuZDtcbiAgICB9XG4gICAgcmVkaXJlY3QodG8sIGZsYXNoKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyb3dzZXJfZGVmYXVsdC5yZWRpcmVjdCh0bywgZmxhc2gpO1xuICAgIH1cbiAgICByZXBsYWNlTWFpbihocmVmLCBmbGFzaCwgY2FsbGJhY2sgPSBudWxsLCBsaW5rUmVmID0gdGhpcy5zZXRQZW5kaW5nTGluayhocmVmKSkge1xuICAgICAgbGV0IG9sZE1haW5FbCA9IHRoaXMubWFpbi5lbDtcbiAgICAgIGxldCBuZXdNYWluRWwgPSBkb21fZGVmYXVsdC5jbG9uZU5vZGUob2xkTWFpbkVsLCBcIlwiKTtcbiAgICAgIHRoaXMubWFpbi5zaG93TG9hZGVyKHRoaXMubG9hZGVyVGltZW91dCk7XG4gICAgICB0aGlzLm1haW4uZGVzdHJveSgpO1xuICAgICAgdGhpcy5tYWluID0gdGhpcy5uZXdSb290VmlldyhuZXdNYWluRWwsIGZsYXNoKTtcbiAgICAgIHRoaXMubWFpbi5zZXRSZWRpcmVjdChocmVmKTtcbiAgICAgIHRoaXMubWFpbi5qb2luKChqb2luQ291bnQpID0+IHtcbiAgICAgICAgaWYgKGpvaW5Db3VudCA9PT0gMSAmJiB0aGlzLmNvbW1pdFBlbmRpbmdMaW5rKGxpbmtSZWYpKSB7XG4gICAgICAgICAgb2xkTWFpbkVsLnJlcGxhY2VXaXRoKG5ld01haW5FbCk7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlzUGh4VmlldyhlbCkge1xuICAgICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pICE9PSBudWxsO1xuICAgIH1cbiAgICBuZXdSb290VmlldyhlbCwgZmxhc2gpIHtcbiAgICAgIGxldCB2aWV3ID0gbmV3IFZpZXcoZWwsIHRoaXMsIG51bGwsIGZsYXNoKTtcbiAgICAgIHRoaXMucm9vdHNbdmlldy5pZF0gPSB2aWV3O1xuICAgICAgcmV0dXJuIHZpZXc7XG4gICAgfVxuICAgIG93bmVyKGNoaWxkRWwsIGNhbGxiYWNrKSB7XG4gICAgICBsZXQgdmlldyA9IG1heWJlKGNoaWxkRWwuY2xvc2VzdChQSFhfVklFV19TRUxFQ1RPUiksIChlbCkgPT4gdGhpcy5nZXRWaWV3QnlFbChlbCkpO1xuICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgY2FsbGJhY2sodmlldyk7XG4gICAgICB9XG4gICAgfVxuICAgIHdpdGhpbk93bmVycyhjaGlsZEVsLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5vd25lcihjaGlsZEVsLCAodmlldykgPT4ge1xuICAgICAgICBsZXQgcGh4VGFyZ2V0ID0gY2hpbGRFbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwidGFyZ2V0XCIpKTtcbiAgICAgICAgaWYgKHBoeFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgIGNhbGxiYWNrKHZpZXcsIGNoaWxkRWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZpZXcud2l0aGluVGFyZ2V0cyhwaHhUYXJnZXQsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGdldFZpZXdCeUVsKGVsKSB7XG4gICAgICBsZXQgcm9vdElkID0gZWwuZ2V0QXR0cmlidXRlKFBIWF9ST09UX0lEKTtcbiAgICAgIHJldHVybiBtYXliZSh0aGlzLmdldFJvb3RCeUlkKHJvb3RJZCksIChyb290KSA9PiByb290LmdldERlc2NlbmRlbnRCeUVsKGVsKSk7XG4gICAgfVxuICAgIGdldFJvb3RCeUlkKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb290c1tpZF07XG4gICAgfVxuICAgIGRlc3Ryb3lBbGxWaWV3cygpIHtcbiAgICAgIGZvciAobGV0IGlkIGluIHRoaXMucm9vdHMpIHtcbiAgICAgICAgdGhpcy5yb290c1tpZF0uZGVzdHJveSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5yb290c1tpZF07XG4gICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3lWaWV3QnlFbChlbCkge1xuICAgICAgbGV0IHJvb3QgPSB0aGlzLmdldFJvb3RCeUlkKGVsLmdldEF0dHJpYnV0ZShQSFhfUk9PVF9JRCkpO1xuICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgcm9vdC5kZXN0cm95RGVzY2VuZGVudChlbC5pZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNldEFjdGl2ZUVsZW1lbnQodGFyZ2V0KSB7XG4gICAgICBpZiAodGhpcy5hY3RpdmVFbGVtZW50ID09PSB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICAgICAgbGV0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdGhpcy5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy5hY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcyk7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcyk7XG4gICAgICB9O1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGNhbmNlbCk7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGNhbmNlbCk7XG4gICAgfVxuICAgIGdldEFjdGl2ZUVsZW1lbnQoKSB7XG4gICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fCBkb2N1bWVudC5ib2R5O1xuICAgICAgfVxuICAgIH1cbiAgICBkcm9wQWN0aXZlRWxlbWVudCh2aWV3KSB7XG4gICAgICBpZiAodGhpcy5wcmV2QWN0aXZlICYmIHZpZXcub3duc0VsZW1lbnQodGhpcy5wcmV2QWN0aXZlKSkge1xuICAgICAgICB0aGlzLnByZXZBY3RpdmUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN0b3JlUHJldmlvdXNseUFjdGl2ZUZvY3VzKCkge1xuICAgICAgaWYgKHRoaXMucHJldkFjdGl2ZSAmJiB0aGlzLnByZXZBY3RpdmUgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgdGhpcy5wcmV2QWN0aXZlLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGJsdXJBY3RpdmVFbGVtZW50KCkge1xuICAgICAgdGhpcy5wcmV2QWN0aXZlID0gdGhpcy5nZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgICBpZiAodGhpcy5wcmV2QWN0aXZlICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHRoaXMucHJldkFjdGl2ZS5ibHVyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGJpbmRUb3BMZXZlbEV2ZW50cygpIHtcbiAgICAgIGlmICh0aGlzLmJvdW5kVG9wTGV2ZWxFdmVudHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5ib3VuZFRvcExldmVsRXZlbnRzID0gdHJ1ZTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgfSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VzaG93XCIsIChlKSA9PiB7XG4gICAgICAgIGlmIChlLnBlcnNpc3RlZCkge1xuICAgICAgICAgIHRoaXMuZ2V0U29ja2V0KCkuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIHRoaXMud2l0aFBhZ2VMb2FkaW5nKHsgdG86IHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBraW5kOiBcInJlZGlyZWN0XCIgfSk7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9LCB0cnVlKTtcbiAgICAgIHRoaXMuYmluZE5hdigpO1xuICAgICAgdGhpcy5iaW5kQ2xpY2tzKCk7XG4gICAgICB0aGlzLmJpbmRGb3JtcygpO1xuICAgICAgdGhpcy5iaW5kKHsga2V5dXA6IFwia2V5dXBcIiwga2V5ZG93bjogXCJrZXlkb3duXCIgfSwgKGUsIHR5cGUsIHZpZXcsIHRhcmdldCwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgX3BoeFRhcmdldCkgPT4ge1xuICAgICAgICBsZXQgbWF0Y2hLZXkgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfS0VZKSk7XG4gICAgICAgIGxldCBwcmVzc2VkS2V5ID0gZS5rZXkgJiYgZS5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKG1hdGNoS2V5ICYmIG1hdGNoS2V5LnRvTG93ZXJDYXNlKCkgIT09IHByZXNzZWRLZXkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5wdXNoS2V5KHRhcmdldCwgdGFyZ2V0Q3R4LCB0eXBlLCBwaHhFdmVudCwgX19zcHJlYWRWYWx1ZXMoeyBrZXk6IGUua2V5IH0sIHRoaXMuZXZlbnRNZXRhKHR5cGUsIGUsIHRhcmdldCkpKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5iaW5kKHsgYmx1cjogXCJmb2N1c291dFwiLCBmb2N1czogXCJmb2N1c2luXCIgfSwgKGUsIHR5cGUsIHZpZXcsIHRhcmdldEVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBwaHhUYXJnZXQpID0+IHtcbiAgICAgICAgaWYgKCFwaHhUYXJnZXQpIHtcbiAgICAgICAgICB2aWV3LnB1c2hFdmVudCh0eXBlLCB0YXJnZXRFbCwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgdGhpcy5ldmVudE1ldGEodHlwZSwgZSwgdGFyZ2V0RWwpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmJpbmQoeyBibHVyOiBcImJsdXJcIiwgZm9jdXM6IFwiZm9jdXNcIiB9LCAoZSwgdHlwZSwgdmlldywgdGFyZ2V0RWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIHBoeFRhcmdldCkgPT4ge1xuICAgICAgICBpZiAocGh4VGFyZ2V0ICYmICFwaHhUYXJnZXQgIT09IFwid2luZG93XCIpIHtcbiAgICAgICAgICB2aWV3LnB1c2hFdmVudCh0eXBlLCB0YXJnZXRFbCwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgdGhpcy5ldmVudE1ldGEodHlwZSwgZSwgdGFyZ2V0RWwpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIChlKSA9PiBlLnByZXZlbnREZWZhdWx0KCkpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkcm9wXCIsIChlKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGV0IGRyb3BUYXJnZXRJZCA9IG1heWJlKGNsb3Nlc3RQaHhCaW5kaW5nKGUudGFyZ2V0LCB0aGlzLmJpbmRpbmcoUEhYX0RST1BfVEFSR0VUKSksICh0cnVlVGFyZ2V0KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRydWVUYXJnZXQuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfRFJPUF9UQVJHRVQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBkcm9wVGFyZ2V0ID0gZHJvcFRhcmdldElkICYmIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRyb3BUYXJnZXRJZCk7XG4gICAgICAgIGxldCBmaWxlcyA9IEFycmF5LmZyb20oZS5kYXRhVHJhbnNmZXIuZmlsZXMgfHwgW10pO1xuICAgICAgICBpZiAoIWRyb3BUYXJnZXQgfHwgZHJvcFRhcmdldC5kaXNhYmxlZCB8fCBmaWxlcy5sZW5ndGggPT09IDAgfHwgIShkcm9wVGFyZ2V0LmZpbGVzIGluc3RhbmNlb2YgRmlsZUxpc3QpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIExpdmVVcGxvYWRlci50cmFja0ZpbGVzKGRyb3BUYXJnZXQsIGZpbGVzKTtcbiAgICAgICAgZHJvcFRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIsIHsgYnViYmxlczogdHJ1ZSB9KSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oUEhYX1RSQUNLX1VQTE9BRFMsIChlKSA9PiB7XG4gICAgICAgIGxldCB1cGxvYWRUYXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgaWYgKCFkb21fZGVmYXVsdC5pc1VwbG9hZElucHV0KHVwbG9hZFRhcmdldCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpbGVzID0gQXJyYXkuZnJvbShlLmRldGFpbC5maWxlcyB8fCBbXSkuZmlsdGVyKChmKSA9PiBmIGluc3RhbmNlb2YgRmlsZSB8fCBmIGluc3RhbmNlb2YgQmxvYik7XG4gICAgICAgIExpdmVVcGxvYWRlci50cmFja0ZpbGVzKHVwbG9hZFRhcmdldCwgZmlsZXMpO1xuICAgICAgICB1cGxvYWRUYXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJpbnB1dFwiLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGV2ZW50TWV0YShldmVudE5hbWUsIGUsIHRhcmdldEVsKSB7XG4gICAgICBsZXQgY2FsbGJhY2sgPSB0aGlzLm1ldGFkYXRhQ2FsbGJhY2tzW2V2ZW50TmFtZV07XG4gICAgICByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjayhlLCB0YXJnZXRFbCkgOiB7fTtcbiAgICB9XG4gICAgc2V0UGVuZGluZ0xpbmsoaHJlZikge1xuICAgICAgdGhpcy5saW5rUmVmKys7XG4gICAgICB0aGlzLnBlbmRpbmdMaW5rID0gaHJlZjtcbiAgICAgIHJldHVybiB0aGlzLmxpbmtSZWY7XG4gICAgfVxuICAgIGNvbW1pdFBlbmRpbmdMaW5rKGxpbmtSZWYpIHtcbiAgICAgIGlmICh0aGlzLmxpbmtSZWYgIT09IGxpbmtSZWYpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ocmVmID0gdGhpcy5wZW5kaW5nTGluaztcbiAgICAgICAgdGhpcy5wZW5kaW5nTGluayA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBnZXRIcmVmKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaHJlZjtcbiAgICB9XG4gICAgaGFzUGVuZGluZ0xpbmsoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnBlbmRpbmdMaW5rO1xuICAgIH1cbiAgICBiaW5kKGV2ZW50cywgY2FsbGJhY2spIHtcbiAgICAgIGZvciAobGV0IGV2ZW50IGluIGV2ZW50cykge1xuICAgICAgICBsZXQgYnJvd3NlckV2ZW50TmFtZSA9IGV2ZW50c1tldmVudF07XG4gICAgICAgIHRoaXMub24oYnJvd3NlckV2ZW50TmFtZSwgKGUpID0+IHtcbiAgICAgICAgICBsZXQgYmluZGluZyA9IHRoaXMuYmluZGluZyhldmVudCk7XG4gICAgICAgICAgbGV0IHdpbmRvd0JpbmRpbmcgPSB0aGlzLmJpbmRpbmcoYHdpbmRvdy0ke2V2ZW50fWApO1xuICAgICAgICAgIGxldCB0YXJnZXRQaHhFdmVudCA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSAmJiBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoYmluZGluZyk7XG4gICAgICAgICAgaWYgKHRhcmdldFBoeEV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRlYm91bmNlKGUudGFyZ2V0LCBlLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMud2l0aGluT3duZXJzKGUudGFyZ2V0LCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSwgZXZlbnQsIHZpZXcsIGUudGFyZ2V0LCB0YXJnZXRDdHgsIHRhcmdldFBoeEV2ZW50LCBudWxsKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9tX2RlZmF1bHQuYWxsKGRvY3VtZW50LCBgWyR7d2luZG93QmluZGluZ31dYCwgKGVsKSA9PiB7XG4gICAgICAgICAgICAgIGxldCBwaHhFdmVudCA9IGVsLmdldEF0dHJpYnV0ZSh3aW5kb3dCaW5kaW5nKTtcbiAgICAgICAgICAgICAgdGhpcy5kZWJvdW5jZShlbCwgZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMud2l0aGluT3duZXJzKGVsLCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjayhlLCBldmVudCwgdmlldywgZWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIFwid2luZG93XCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGJpbmRDbGlja3MoKSB7XG4gICAgICB0aGlzLmJpbmRDbGljayhcImNsaWNrXCIsIFwiY2xpY2tcIiwgZmFsc2UpO1xuICAgICAgdGhpcy5iaW5kQ2xpY2soXCJtb3VzZWRvd25cIiwgXCJjYXB0dXJlLWNsaWNrXCIsIHRydWUpO1xuICAgIH1cbiAgICBiaW5kQ2xpY2soZXZlbnROYW1lLCBiaW5kaW5nTmFtZSwgY2FwdHVyZSkge1xuICAgICAgbGV0IGNsaWNrID0gdGhpcy5iaW5kaW5nKGJpbmRpbmdOYW1lKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgKGUpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhcmdldCA9IG51bGw7XG4gICAgICAgIGlmIChjYXB0dXJlKSB7XG4gICAgICAgICAgdGFyZ2V0ID0gZS50YXJnZXQubWF0Y2hlcyhgWyR7Y2xpY2t9XWApID8gZS50YXJnZXQgOiBlLnRhcmdldC5xdWVyeVNlbGVjdG9yKGBbJHtjbGlja31dYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0ID0gY2xvc2VzdFBoeEJpbmRpbmcoZS50YXJnZXQsIGNsaWNrKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGh4RXZlbnQgPSB0YXJnZXQgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShjbGljayk7XG4gICAgICAgIGlmICghcGh4RXZlbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIikge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYm91bmNlKHRhcmdldCwgZSwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMud2l0aGluT3duZXJzKHRhcmdldCwgKHZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgICAgICAgdmlldy5wdXNoRXZlbnQoXCJjbGlja1wiLCB0YXJnZXQsIHRhcmdldEN0eCwgcGh4RXZlbnQsIHRoaXMuZXZlbnRNZXRhKFwiY2xpY2tcIiwgZSwgdGFyZ2V0KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgY2FwdHVyZSk7XG4gICAgfVxuICAgIGJpbmROYXYoKSB7XG4gICAgICBpZiAoIWJyb3dzZXJfZGVmYXVsdC5jYW5QdXNoU3RhdGUoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICBoaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJtYW51YWxcIjtcbiAgICAgIH1cbiAgICAgIGxldCBzY3JvbGxUaW1lciA9IG51bGw7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCAoX2UpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHNjcm9sbFRpbWVyKTtcbiAgICAgICAgc2Nyb2xsVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBicm93c2VyX2RlZmF1bHQudXBkYXRlQ3VycmVudFN0YXRlKChzdGF0ZSkgPT4gT2JqZWN0LmFzc2lnbihzdGF0ZSwgeyBzY3JvbGw6IHdpbmRvdy5zY3JvbGxZIH0pKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICAgIH0pO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyB0eXBlLCBpZCwgcm9vdCwgc2Nyb2xsIH0gPSBldmVudC5zdGF0ZSB8fCB7fTtcbiAgICAgICAgbGV0IGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgICAgaWYgKHRoaXMubWFpbi5pc0Nvbm5lY3RlZCgpICYmICh0eXBlID09PSBcInBhdGNoXCIgJiYgaWQgPT09IHRoaXMubWFpbi5pZCkpIHtcbiAgICAgICAgICB0aGlzLm1haW4ucHVzaExpbmtQYXRjaChocmVmLCBudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlcGxhY2VNYWluKGhyZWYsIG51bGwsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgICAgIHRoaXMucmVwbGFjZVJvb3RIaXN0b3J5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjcm9sbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgc2Nyb2xsKTtcbiAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZhbHNlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgICAgbGV0IHRhcmdldCA9IGNsb3Nlc3RQaHhCaW5kaW5nKGUudGFyZ2V0LCBQSFhfTElWRV9MSU5LKTtcbiAgICAgICAgbGV0IHR5cGUgPSB0YXJnZXQgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShQSFhfTElWRV9MSU5LKTtcbiAgICAgICAgbGV0IHdhbnRzTmV3VGFiID0gZS5tZXRhS2V5IHx8IGUuY3RybEtleSB8fCBlLmJ1dHRvbiA9PT0gMTtcbiAgICAgICAgaWYgKCF0eXBlIHx8ICF0aGlzLmlzQ29ubmVjdGVkKCkgfHwgIXRoaXMubWFpbiB8fCB3YW50c05ld1RhYikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaHJlZiA9IHRhcmdldC5ocmVmO1xuICAgICAgICBsZXQgbGlua1N0YXRlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShQSFhfTElOS19TVEFURSk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0xpbmsgPT09IGhyZWYpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwicGF0Y2hcIikge1xuICAgICAgICAgIHRoaXMucHVzaEhpc3RvcnlQYXRjaChocmVmLCBsaW5rU3RhdGUsIHRhcmdldCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJyZWRpcmVjdFwiKSB7XG4gICAgICAgICAgdGhpcy5oaXN0b3J5UmVkaXJlY3QoaHJlZiwgbGlua1N0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7UEhYX0xJVkVfTElOS30gdG8gYmUgXCJwYXRjaFwiIG9yIFwicmVkaXJlY3RcIiwgZ290OiAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG4gICAgd2l0aFBhZ2VMb2FkaW5nKGluZm8sIGNhbGxiYWNrKSB7XG4gICAgICBkb21fZGVmYXVsdC5kaXNwYXRjaEV2ZW50KHdpbmRvdywgXCJwaHg6cGFnZS1sb2FkaW5nLXN0YXJ0XCIsIGluZm8pO1xuICAgICAgbGV0IGRvbmUgPSAoKSA9PiBkb21fZGVmYXVsdC5kaXNwYXRjaEV2ZW50KHdpbmRvdywgXCJwaHg6cGFnZS1sb2FkaW5nLXN0b3BcIiwgaW5mbyk7XG4gICAgICByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjayhkb25lKSA6IGRvbmU7XG4gICAgfVxuICAgIHB1c2hIaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCB0YXJnZXRFbCkge1xuICAgICAgdGhpcy53aXRoUGFnZUxvYWRpbmcoeyB0bzogaHJlZiwga2luZDogXCJwYXRjaFwiIH0sIChkb25lKSA9PiB7XG4gICAgICAgIHRoaXMubWFpbi5wdXNoTGlua1BhdGNoKGhyZWYsIHRhcmdldEVsLCAobGlua1JlZikgPT4ge1xuICAgICAgICAgIHRoaXMuaGlzdG9yeVBhdGNoKGhyZWYsIGxpbmtTdGF0ZSwgbGlua1JlZik7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBoaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCBsaW5rUmVmID0gdGhpcy5zZXRQZW5kaW5nTGluayhocmVmKSkge1xuICAgICAgaWYgKCF0aGlzLmNvbW1pdFBlbmRpbmdMaW5rKGxpbmtSZWYpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGJyb3dzZXJfZGVmYXVsdC5wdXNoU3RhdGUobGlua1N0YXRlLCB7IHR5cGU6IFwicGF0Y2hcIiwgaWQ6IHRoaXMubWFpbi5pZCB9LCBocmVmKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJOZXdMb2NhdGlvbih3aW5kb3cubG9jYXRpb24pO1xuICAgIH1cbiAgICBoaXN0b3J5UmVkaXJlY3QoaHJlZiwgbGlua1N0YXRlLCBmbGFzaCkge1xuICAgICAgbGV0IHNjcm9sbCA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgdGhpcy53aXRoUGFnZUxvYWRpbmcoeyB0bzogaHJlZiwga2luZDogXCJyZWRpcmVjdFwiIH0sIChkb25lKSA9PiB7XG4gICAgICAgIHRoaXMucmVwbGFjZU1haW4oaHJlZiwgZmxhc2gsICgpID0+IHtcbiAgICAgICAgICBicm93c2VyX2RlZmF1bHQucHVzaFN0YXRlKGxpbmtTdGF0ZSwgeyB0eXBlOiBcInJlZGlyZWN0XCIsIGlkOiB0aGlzLm1haW4uaWQsIHNjcm9sbCB9LCBocmVmKTtcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJlcGxhY2VSb290SGlzdG9yeSgpIHtcbiAgICAgIGJyb3dzZXJfZGVmYXVsdC5wdXNoU3RhdGUoXCJyZXBsYWNlXCIsIHsgcm9vdDogdHJ1ZSwgdHlwZTogXCJwYXRjaFwiLCBpZDogdGhpcy5tYWluLmlkIH0pO1xuICAgIH1cbiAgICByZWdpc3Rlck5ld0xvY2F0aW9uKG5ld0xvY2F0aW9uKSB7XG4gICAgICBsZXQgeyBwYXRobmFtZSwgc2VhcmNoIH0gPSB0aGlzLmN1cnJlbnRMb2NhdGlvbjtcbiAgICAgIGlmIChwYXRobmFtZSArIHNlYXJjaCA9PT0gbmV3TG9jYXRpb24ucGF0aG5hbWUgKyBuZXdMb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBjbG9uZShuZXdMb2NhdGlvbik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBiaW5kRm9ybXMoKSB7XG4gICAgICBsZXQgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB0aGlzLm9uKFwic3VibWl0XCIsIChlKSA9PiB7XG4gICAgICAgIGxldCBwaHhFdmVudCA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJzdWJtaXRcIikpO1xuICAgICAgICBpZiAoIXBoeEV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS50YXJnZXQuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLndpdGhpbk93bmVycyhlLnRhcmdldCwgKHZpZXcsIHRhcmdldEN0eCkgPT4gdmlldy5zdWJtaXRGb3JtKGUudGFyZ2V0LCB0YXJnZXRDdHgsIHBoeEV2ZW50KSk7XG4gICAgICB9LCBmYWxzZSk7XG4gICAgICBmb3IgKGxldCB0eXBlIG9mIFtcImNoYW5nZVwiLCBcImlucHV0XCJdKSB7XG4gICAgICAgIHRoaXMub24odHlwZSwgKGUpID0+IHtcbiAgICAgICAgICBsZXQgaW5wdXQgPSBlLnRhcmdldDtcbiAgICAgICAgICBsZXQgcGh4RXZlbnQgPSBpbnB1dC5mb3JtICYmIGlucHV0LmZvcm0uZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcImNoYW5nZVwiKSk7XG4gICAgICAgICAgaWYgKCFwaHhFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5wdXQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiBpbnB1dC52YWxpZGl0eSAmJiBpbnB1dC52YWxpZGl0eS5iYWRJbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgY3VycmVudEl0ZXJhdGlvbnMgPSBpdGVyYXRpb25zO1xuICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgICBsZXQgeyBhdCwgdHlwZTogbGFzdFR5cGUgfSA9IGRvbV9kZWZhdWx0LnByaXZhdGUoaW5wdXQsIFwicHJldi1pdGVyYXRpb25cIikgfHwge307XG4gICAgICAgICAgaWYgKGF0ID09PSBjdXJyZW50SXRlcmF0aW9ucyAtIDEgJiYgdHlwZSAhPT0gbGFzdFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZG9tX2RlZmF1bHQucHV0UHJpdmF0ZShpbnB1dCwgXCJwcmV2LWl0ZXJhdGlvblwiLCB7IGF0OiBjdXJyZW50SXRlcmF0aW9ucywgdHlwZSB9KTtcbiAgICAgICAgICB0aGlzLmRlYm91bmNlKGlucHV0LCBlLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndpdGhpbk93bmVycyhpbnB1dC5mb3JtLCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICAgICAgICAgIGRvbV9kZWZhdWx0LnB1dFByaXZhdGUoaW5wdXQsIFBIWF9IQVNfRk9DVVNFRCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGlmICghZG9tX2RlZmF1bHQuaXNUZXh0dWFsSW5wdXQoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmVFbGVtZW50KGlucHV0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2aWV3LnB1c2hJbnB1dChpbnB1dCwgdGFyZ2V0Q3R4LCBudWxsLCBwaHhFdmVudCwgZS50YXJnZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVib3VuY2UoZWwsIGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgbGV0IHBoeERlYm91bmNlID0gdGhpcy5iaW5kaW5nKFBIWF9ERUJPVU5DRSk7XG4gICAgICBsZXQgcGh4VGhyb3R0bGUgPSB0aGlzLmJpbmRpbmcoUEhYX1RIUk9UVExFKTtcbiAgICAgIGxldCBkZWZhdWx0RGVib3VuY2UgPSB0aGlzLmRlZmF1bHRzLmRlYm91bmNlLnRvU3RyaW5nKCk7XG4gICAgICBsZXQgZGVmYXVsdFRocm90dGxlID0gdGhpcy5kZWZhdWx0cy50aHJvdHRsZS50b1N0cmluZygpO1xuICAgICAgZG9tX2RlZmF1bHQuZGVib3VuY2UoZWwsIGV2ZW50LCBwaHhEZWJvdW5jZSwgZGVmYXVsdERlYm91bmNlLCBwaHhUaHJvdHRsZSwgZGVmYXVsdFRocm90dGxlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHNpbGVuY2VFdmVudHMoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuc2lsZW5jZWQgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIHRoaXMuc2lsZW5jZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgb24oZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgKGUpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnNpbGVuY2VkKSB7XG4gICAgICAgICAgY2FsbGJhY2soZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHBob2VuaXhfbGl2ZV92aWV3X2V4cG9ydHM7XG59KSgpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTdDQTtBQUNBO0FBK0NBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQWxFQTtBQW1FQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUE3Q0E7QUE4Q0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwVkE7QUFxVkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBOUZBO0FBQ0E7QUFnR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwR0E7QUFDQTtBQXNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBdkJBO0FBd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQXpCQTtBQXVDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE5Q0E7QUFDQTtBQWdEQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQXhFQTtBQTBFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0ZBO0FBNkZBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsT0E7QUFDQTtBQW9PQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpNQTtBQUNBO0FBMk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBdkVBO0FBQ0E7QUF5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQXg0QkE7QUFDQTtBQTA0QkE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNWxCQTtBQTZsQkE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../deps/phoenix_live_view/priv/static/phoenix_live_view.js\n");

/***/ }),

/***/ "./css/app.scss":
/*!**********************!*\
  !*** ./css/app.scss ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jc3MvYXBwLnNjc3MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jc3MvYXBwLnNjc3M/MjQyYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./css/app.scss\n");

/***/ }),

/***/ "./js/app.js":
/*!*******************!*\
  !*** ./js/app.js ***!
  \*******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _css_app_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css/app.scss */ \"./css/app.scss\");\n/* harmony import */ var _css_app_scss__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_app_scss__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! phoenix_html */ \"../deps/phoenix_html/priv/static/phoenix_html.js\");\n/* harmony import */ var phoenix_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(phoenix_html__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var phoenix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! phoenix */ \"../deps/phoenix/priv/static/phoenix.js\");\n/* harmony import */ var phoenix__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(phoenix__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var nprogress__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! nprogress */ \"./node_modules/nprogress/nprogress.js\");\n/* harmony import */ var nprogress__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(nprogress__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var phoenix_live_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! phoenix_live_view */ \"../deps/phoenix_live_view/priv/static/phoenix_live_view.js\");\n/* harmony import */ var phoenix_live_view__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(phoenix_live_view__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var alpinejs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! alpinejs */ \"./node_modules/alpinejs/dist/alpine.js\");\n/* harmony import */ var alpinejs__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(alpinejs__WEBPACK_IMPORTED_MODULE_5__);\n// We need to import the CSS so that webpack will load it.\n// The MiniCssExtractPlugin is used to separate it out into\n// its own CSS file.\n // webpack automatically bundles all modules in your\n// entry points. Those entry points can be configured\n// in \"webpack.config.js\".\n//\n// Import deps with the dep name or local files with a relative path, for example:\n//\n//     import {Socket} from \"phoenix\"\n//     import socket from \"./socket\"\n//\n\n\n\n\n\n //import Chart from 'chart.js'\n\nChart.defaults.global.defaultFontFamily = 'Cairo';\nChart.defaults.global.defaultFontStyle = 'bold';\nvar hooks = {};\nvar csrfToken = document.querySelector(\"meta[name='csrf-token']\").getAttribute(\"content\");\nvar liveSocket = new phoenix_live_view__WEBPACK_IMPORTED_MODULE_4__[\"LiveSocket\"](\"/live\", phoenix__WEBPACK_IMPORTED_MODULE_2__[\"Socket\"], {\n  params: {\n    _csrf_token: csrfToken\n  },\n  dom: {\n    onBeforeElUpdated: function onBeforeElUpdated(from, to) {\n      if (from.__x) {\n        alpinejs__WEBPACK_IMPORTED_MODULE_5___default.a.clone(from.__x, to);\n      }\n    }\n  },\n  hooks: hooks\n}); // Show progress bar on live navigation and form submits\n\nwindow.addEventListener(\"phx:page-loading-start\", function (info) {\n  return nprogress__WEBPACK_IMPORTED_MODULE_3___default.a.start();\n});\nwindow.addEventListener(\"phx:page-loading-stop\", function (info) {\n  return nprogress__WEBPACK_IMPORTED_MODULE_3___default.a.done();\n}); // connect if there are any LiveViews on the page\n\nliveSocket.connect(); // expose liveSocket on window for web console debug logs and latency simulation:\n// >> liveSocket.enableDebug()\n// >> liveSocket.enableLatencySim(1000)  // enabled for duration of browser session\n// >> liveSocket.disableLatencySim()\n\nwindow.liveSocket = liveSocket;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9hcHAuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hcHAuanM/NzQ3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXZSBuZWVkIHRvIGltcG9ydCB0aGUgQ1NTIHNvIHRoYXQgd2VicGFjayB3aWxsIGxvYWQgaXQuXG4vLyBUaGUgTWluaUNzc0V4dHJhY3RQbHVnaW4gaXMgdXNlZCB0byBzZXBhcmF0ZSBpdCBvdXQgaW50b1xuLy8gaXRzIG93biBDU1MgZmlsZS5cbmltcG9ydCBcIi4uL2Nzcy9hcHAuc2Nzc1wiXG5cbi8vIHdlYnBhY2sgYXV0b21hdGljYWxseSBidW5kbGVzIGFsbCBtb2R1bGVzIGluIHlvdXJcbi8vIGVudHJ5IHBvaW50cy4gVGhvc2UgZW50cnkgcG9pbnRzIGNhbiBiZSBjb25maWd1cmVkXG4vLyBpbiBcIndlYnBhY2suY29uZmlnLmpzXCIuXG4vL1xuLy8gSW1wb3J0IGRlcHMgd2l0aCB0aGUgZGVwIG5hbWUgb3IgbG9jYWwgZmlsZXMgd2l0aCBhIHJlbGF0aXZlIHBhdGgsIGZvciBleGFtcGxlOlxuLy9cbi8vICAgICBpbXBvcnQge1NvY2tldH0gZnJvbSBcInBob2VuaXhcIlxuLy8gICAgIGltcG9ydCBzb2NrZXQgZnJvbSBcIi4vc29ja2V0XCJcbi8vXG5pbXBvcnQgXCJwaG9lbml4X2h0bWxcIlxuaW1wb3J0IHtTb2NrZXR9IGZyb20gXCJwaG9lbml4XCJcbmltcG9ydCBOUHJvZ3Jlc3MgZnJvbSBcIm5wcm9ncmVzc1wiXG5pbXBvcnQge0xpdmVTb2NrZXR9IGZyb20gXCJwaG9lbml4X2xpdmVfdmlld1wiXG5pbXBvcnQgQWxwaW5lIGZyb20gXCJhbHBpbmVqc1wiXG5cbi8vaW1wb3J0IENoYXJ0IGZyb20gJ2NoYXJ0LmpzJ1xuXG5DaGFydC5kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRGYW1pbHkgPSAnQ2Fpcm8nXG5DaGFydC5kZWZhdWx0cy5nbG9iYWwuZGVmYXVsdEZvbnRTdHlsZSA9ICdib2xkJ1xuXG5sZXQgaG9va3MgPSB7fVxuXG5sZXQgY3NyZlRva2VuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIm1ldGFbbmFtZT0nY3NyZi10b2tlbiddXCIpLmdldEF0dHJpYnV0ZShcImNvbnRlbnRcIilcbmxldCBsaXZlU29ja2V0ID0gbmV3IExpdmVTb2NrZXQoXCIvbGl2ZVwiLCBTb2NrZXQsIHtcbiAgICBwYXJhbXM6IHtfY3NyZl90b2tlbjogY3NyZlRva2VufSxcbiAgICBkb206IHtcbiAgICAgICAgb25CZWZvcmVFbFVwZGF0ZWQoZnJvbSwgdG8pIHtcbiAgICAgICAgICBpZiAoZnJvbS5fX3gpIHsgQWxwaW5lLmNsb25lKGZyb20uX194LCB0bykgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIGhvb2tzXG59KVxuXG4vLyBTaG93IHByb2dyZXNzIGJhciBvbiBsaXZlIG5hdmlnYXRpb24gYW5kIGZvcm0gc3VibWl0c1xud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwaHg6cGFnZS1sb2FkaW5nLXN0YXJ0XCIsIGluZm8gPT4gTlByb2dyZXNzLnN0YXJ0KCkpXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBoeDpwYWdlLWxvYWRpbmctc3RvcFwiLCBpbmZvID0+IE5Qcm9ncmVzcy5kb25lKCkpXG5cbi8vIGNvbm5lY3QgaWYgdGhlcmUgYXJlIGFueSBMaXZlVmlld3Mgb24gdGhlIHBhZ2VcbmxpdmVTb2NrZXQuY29ubmVjdCgpXG5cbi8vIGV4cG9zZSBsaXZlU29ja2V0IG9uIHdpbmRvdyBmb3Igd2ViIGNvbnNvbGUgZGVidWcgbG9ncyBhbmQgbGF0ZW5jeSBzaW11bGF0aW9uOlxuLy8gPj4gbGl2ZVNvY2tldC5lbmFibGVEZWJ1ZygpXG4vLyA+PiBsaXZlU29ja2V0LmVuYWJsZUxhdGVuY3lTaW0oMTAwMCkgIC8vIGVuYWJsZWQgZm9yIGR1cmF0aW9uIG9mIGJyb3dzZXIgc2Vzc2lvblxuLy8gPj4gbGl2ZVNvY2tldC5kaXNhYmxlTGF0ZW5jeVNpbSgpXG53aW5kb3cubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXRcblxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUhBO0FBS0E7QUFQQTtBQUNBO0FBVUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./js/app.js\n");

/***/ }),

/***/ "./node_modules/alpinejs/dist/alpine.js":
/*!**********************************************!*\
  !*** ./node_modules/alpinejs/dist/alpine.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? module.exports = factory() :\n  undefined;\n}(this, (function () { 'use strict';\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  // Thanks @stimulus:\n  // https://github.com/stimulusjs/stimulus/blob/master/packages/%40stimulus/core/src/application.ts\n  function domReady() {\n    return new Promise(resolve => {\n      if (document.readyState == \"loading\") {\n        document.addEventListener(\"DOMContentLoaded\", resolve);\n      } else {\n        resolve();\n      }\n    });\n  }\n  function arrayUnique(array) {\n    return Array.from(new Set(array));\n  }\n  function isTesting() {\n    return navigator.userAgent.includes(\"Node.js\") || navigator.userAgent.includes(\"jsdom\");\n  }\n  function checkedAttrLooseCompare(valueA, valueB) {\n    return valueA == valueB;\n  }\n  function warnIfMalformedTemplate(el, directive) {\n    if (el.tagName.toLowerCase() !== 'template') {\n      console.warn(`Alpine: [${directive}] directive should only be added to <template> tags. See https://github.com/alpinejs/alpine#${directive}`);\n    } else if (el.content.childElementCount !== 1) {\n      console.warn(`Alpine: <template> tag with [${directive}] encountered with an unexpected number of root elements. Make sure <template> has a single root element. `);\n    }\n  }\n  function kebabCase(subject) {\n    return subject.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/[_\\s]/, '-').toLowerCase();\n  }\n  function camelCase(subject) {\n    return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n  }\n  function walk(el, callback) {\n    if (callback(el) === false) return;\n    let node = el.firstElementChild;\n\n    while (node) {\n      walk(node, callback);\n      node = node.nextElementSibling;\n    }\n  }\n  function debounce(func, wait) {\n    var timeout;\n    return function () {\n      var context = this,\n          args = arguments;\n\n      var later = function later() {\n        timeout = null;\n        func.apply(context, args);\n      };\n\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  }\n\n  const handleError = (el, expression, error) => {\n    console.warn(`Alpine Error: \"${error}\"\\n\\nExpression: \"${expression}\"\\nElement:`, el);\n\n    if (!isTesting()) {\n      Object.assign(error, {\n        el,\n        expression\n      });\n      throw error;\n    }\n  };\n\n  function tryCatch(cb, {\n    el,\n    expression\n  }) {\n    try {\n      const value = cb();\n      return value instanceof Promise ? value.catch(e => handleError(el, expression, e)) : value;\n    } catch (e) {\n      handleError(el, expression, e);\n    }\n  }\n\n  function saferEval(el, expression, dataContext, additionalHelperVariables = {}) {\n    return tryCatch(() => {\n      if (typeof expression === 'function') {\n        return expression.call(dataContext);\n      }\n\n      return new Function(['$data', ...Object.keys(additionalHelperVariables)], `var __alpine_result; with($data) { __alpine_result = ${expression} }; return __alpine_result`)(dataContext, ...Object.values(additionalHelperVariables));\n    }, {\n      el,\n      expression\n    });\n  }\n  function saferEvalNoReturn(el, expression, dataContext, additionalHelperVariables = {}) {\n    return tryCatch(() => {\n      if (typeof expression === 'function') {\n        return Promise.resolve(expression.call(dataContext, additionalHelperVariables['$event']));\n      }\n\n      let AsyncFunction = Function;\n      /* MODERN-ONLY:START */\n\n      AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;\n      /* MODERN-ONLY:END */\n      // For the cases when users pass only a function reference to the caller: `x-on:click=\"foo\"`\n      // Where \"foo\" is a function. Also, we'll pass the function the event instance when we call it.\n\n      if (Object.keys(dataContext).includes(expression)) {\n        let methodReference = new Function(['dataContext', ...Object.keys(additionalHelperVariables)], `with(dataContext) { return ${expression} }`)(dataContext, ...Object.values(additionalHelperVariables));\n\n        if (typeof methodReference === 'function') {\n          return Promise.resolve(methodReference.call(dataContext, additionalHelperVariables['$event']));\n        } else {\n          return Promise.resolve();\n        }\n      }\n\n      return Promise.resolve(new AsyncFunction(['dataContext', ...Object.keys(additionalHelperVariables)], `with(dataContext) { ${expression} }`)(dataContext, ...Object.values(additionalHelperVariables)));\n    }, {\n      el,\n      expression\n    });\n  }\n  const xAttrRE = /^x-(on|bind|data|text|html|model|if|for|show|cloak|transition|ref|spread)\\b/;\n  function isXAttr(attr) {\n    const name = replaceAtAndColonWithStandardSyntax(attr.name);\n    return xAttrRE.test(name);\n  }\n  function getXAttrs(el, component, type) {\n    let directives = Array.from(el.attributes).filter(isXAttr).map(parseHtmlAttribute); // Get an object of directives from x-spread.\n\n    let spreadDirective = directives.filter(directive => directive.type === 'spread')[0];\n\n    if (spreadDirective) {\n      let spreadObject = saferEval(el, spreadDirective.expression, component.$data); // Add x-spread directives to the pile of existing directives.\n\n      directives = directives.concat(Object.entries(spreadObject).map(([name, value]) => parseHtmlAttribute({\n        name,\n        value\n      })));\n    }\n\n    if (type) return directives.filter(i => i.type === type);\n    return sortDirectives(directives);\n  }\n\n  function sortDirectives(directives) {\n    let directiveOrder = ['bind', 'model', 'show', 'catch-all'];\n    return directives.sort((a, b) => {\n      let typeA = directiveOrder.indexOf(a.type) === -1 ? 'catch-all' : a.type;\n      let typeB = directiveOrder.indexOf(b.type) === -1 ? 'catch-all' : b.type;\n      return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);\n    });\n  }\n\n  function parseHtmlAttribute({\n    name,\n    value\n  }) {\n    const normalizedName = replaceAtAndColonWithStandardSyntax(name);\n    const typeMatch = normalizedName.match(xAttrRE);\n    const valueMatch = normalizedName.match(/:([a-zA-Z0-9\\-:]+)/);\n    const modifiers = normalizedName.match(/\\.[^.\\]]+(?=[^\\]]*$)/g) || [];\n    return {\n      type: typeMatch ? typeMatch[1] : null,\n      value: valueMatch ? valueMatch[1] : null,\n      modifiers: modifiers.map(i => i.replace('.', '')),\n      expression: value\n    };\n  }\n  function isBooleanAttr(attrName) {\n    // As per HTML spec table https://html.spec.whatwg.org/multipage/indices.html#attributes-3:boolean-attribute\n    // Array roughly ordered by estimated usage\n    const booleanAttributes = ['disabled', 'checked', 'required', 'readonly', 'hidden', 'open', 'selected', 'autofocus', 'itemscope', 'multiple', 'novalidate', 'allowfullscreen', 'allowpaymentrequest', 'formnovalidate', 'autoplay', 'controls', 'loop', 'muted', 'playsinline', 'default', 'ismap', 'reversed', 'async', 'defer', 'nomodule'];\n    return booleanAttributes.includes(attrName);\n  }\n  function replaceAtAndColonWithStandardSyntax(name) {\n    if (name.startsWith('@')) {\n      return name.replace('@', 'x-on:');\n    } else if (name.startsWith(':')) {\n      return name.replace(':', 'x-bind:');\n    }\n\n    return name;\n  }\n  function convertClassStringToArray(classList, filterFn = Boolean) {\n    return classList.split(' ').filter(filterFn);\n  }\n  const TRANSITION_TYPE_IN = 'in';\n  const TRANSITION_TYPE_OUT = 'out';\n  const TRANSITION_CANCELLED = 'cancelled';\n  function transitionIn(el, show, reject, component, forceSkip = false) {\n    // We don't want to transition on the initial page load.\n    if (forceSkip) return show();\n\n    if (el.__x_transition && el.__x_transition.type === TRANSITION_TYPE_IN) {\n      // there is already a similar transition going on, this was probably triggered by\n      // a change in a different property, let's just leave the previous one doing its job\n      return;\n    }\n\n    const attrs = getXAttrs(el, component, 'transition');\n    const showAttr = getXAttrs(el, component, 'show')[0]; // If this is triggered by a x-show.transition.\n\n    if (showAttr && showAttr.modifiers.includes('transition')) {\n      let modifiers = showAttr.modifiers; // If x-show.transition.out, we'll skip the \"in\" transition.\n\n      if (modifiers.includes('out') && !modifiers.includes('in')) return show();\n      const settingBothSidesOfTransition = modifiers.includes('in') && modifiers.includes('out'); // If x-show.transition.in...out... only use \"in\" related modifiers for this transition.\n\n      modifiers = settingBothSidesOfTransition ? modifiers.filter((i, index) => index < modifiers.indexOf('out')) : modifiers;\n      transitionHelperIn(el, modifiers, show, reject); // Otherwise, we can assume x-transition:enter.\n    } else if (attrs.some(attr => ['enter', 'enter-start', 'enter-end'].includes(attr.value))) {\n      transitionClassesIn(el, component, attrs, show, reject);\n    } else {\n      // If neither, just show that damn thing.\n      show();\n    }\n  }\n  function transitionOut(el, hide, reject, component, forceSkip = false) {\n    // We don't want to transition on the initial page load.\n    if (forceSkip) return hide();\n\n    if (el.__x_transition && el.__x_transition.type === TRANSITION_TYPE_OUT) {\n      // there is already a similar transition going on, this was probably triggered by\n      // a change in a different property, let's just leave the previous one doing its job\n      return;\n    }\n\n    const attrs = getXAttrs(el, component, 'transition');\n    const showAttr = getXAttrs(el, component, 'show')[0];\n\n    if (showAttr && showAttr.modifiers.includes('transition')) {\n      let modifiers = showAttr.modifiers;\n      if (modifiers.includes('in') && !modifiers.includes('out')) return hide();\n      const settingBothSidesOfTransition = modifiers.includes('in') && modifiers.includes('out');\n      modifiers = settingBothSidesOfTransition ? modifiers.filter((i, index) => index > modifiers.indexOf('out')) : modifiers;\n      transitionHelperOut(el, modifiers, settingBothSidesOfTransition, hide, reject);\n    } else if (attrs.some(attr => ['leave', 'leave-start', 'leave-end'].includes(attr.value))) {\n      transitionClassesOut(el, component, attrs, hide, reject);\n    } else {\n      hide();\n    }\n  }\n  function transitionHelperIn(el, modifiers, showCallback, reject) {\n    // Default values inspired by: https://material.io/design/motion/speed.html#duration\n    const styleValues = {\n      duration: modifierValue(modifiers, 'duration', 150),\n      origin: modifierValue(modifiers, 'origin', 'center'),\n      first: {\n        opacity: 0,\n        scale: modifierValue(modifiers, 'scale', 95)\n      },\n      second: {\n        opacity: 1,\n        scale: 100\n      }\n    };\n    transitionHelper(el, modifiers, showCallback, () => {}, reject, styleValues, TRANSITION_TYPE_IN);\n  }\n  function transitionHelperOut(el, modifiers, settingBothSidesOfTransition, hideCallback, reject) {\n    // Make the \"out\" transition .5x slower than the \"in\". (Visually better)\n    // HOWEVER, if they explicitly set a duration for the \"out\" transition,\n    // use that.\n    const duration = settingBothSidesOfTransition ? modifierValue(modifiers, 'duration', 150) : modifierValue(modifiers, 'duration', 150) / 2;\n    const styleValues = {\n      duration: duration,\n      origin: modifierValue(modifiers, 'origin', 'center'),\n      first: {\n        opacity: 1,\n        scale: 100\n      },\n      second: {\n        opacity: 0,\n        scale: modifierValue(modifiers, 'scale', 95)\n      }\n    };\n    transitionHelper(el, modifiers, () => {}, hideCallback, reject, styleValues, TRANSITION_TYPE_OUT);\n  }\n\n  function modifierValue(modifiers, key, fallback) {\n    // If the modifier isn't present, use the default.\n    if (modifiers.indexOf(key) === -1) return fallback; // If it IS present, grab the value after it: x-show.transition.duration.500ms\n\n    const rawValue = modifiers[modifiers.indexOf(key) + 1];\n    if (!rawValue) return fallback;\n\n    if (key === 'scale') {\n      // Check if the very next value is NOT a number and return the fallback.\n      // If x-show.transition.scale, we'll use the default scale value.\n      // That is how a user opts out of the opacity transition.\n      if (!isNumeric(rawValue)) return fallback;\n    }\n\n    if (key === 'duration') {\n      // Support x-show.transition.duration.500ms && duration.500\n      let match = rawValue.match(/([0-9]+)ms/);\n      if (match) return match[1];\n    }\n\n    if (key === 'origin') {\n      // Support chaining origin directions: x-show.transition.top.right\n      if (['top', 'right', 'left', 'center', 'bottom'].includes(modifiers[modifiers.indexOf(key) + 2])) {\n        return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(' ');\n      }\n    }\n\n    return rawValue;\n  }\n\n  function transitionHelper(el, modifiers, hook1, hook2, reject, styleValues, type) {\n    // clear the previous transition if exists to avoid caching the wrong styles\n    if (el.__x_transition) {\n      el.__x_transition.cancel && el.__x_transition.cancel();\n    } // If the user set these style values, we'll put them back when we're done with them.\n\n\n    const opacityCache = el.style.opacity;\n    const transformCache = el.style.transform;\n    const transformOriginCache = el.style.transformOrigin; // If no modifiers are present: x-show.transition, we'll default to both opacity and scale.\n\n    const noModifiers = !modifiers.includes('opacity') && !modifiers.includes('scale');\n    const transitionOpacity = noModifiers || modifiers.includes('opacity');\n    const transitionScale = noModifiers || modifiers.includes('scale'); // These are the explicit stages of a transition (same stages for in and for out).\n    // This way you can get a birds eye view of the hooks, and the differences\n    // between them.\n\n    const stages = {\n      start() {\n        if (transitionOpacity) el.style.opacity = styleValues.first.opacity;\n        if (transitionScale) el.style.transform = `scale(${styleValues.first.scale / 100})`;\n      },\n\n      during() {\n        if (transitionScale) el.style.transformOrigin = styleValues.origin;\n        el.style.transitionProperty = [transitionOpacity ? `opacity` : ``, transitionScale ? `transform` : ``].join(' ').trim();\n        el.style.transitionDuration = `${styleValues.duration / 1000}s`;\n        el.style.transitionTimingFunction = `cubic-bezier(0.4, 0.0, 0.2, 1)`;\n      },\n\n      show() {\n        hook1();\n      },\n\n      end() {\n        if (transitionOpacity) el.style.opacity = styleValues.second.opacity;\n        if (transitionScale) el.style.transform = `scale(${styleValues.second.scale / 100})`;\n      },\n\n      hide() {\n        hook2();\n      },\n\n      cleanup() {\n        if (transitionOpacity) el.style.opacity = opacityCache;\n        if (transitionScale) el.style.transform = transformCache;\n        if (transitionScale) el.style.transformOrigin = transformOriginCache;\n        el.style.transitionProperty = null;\n        el.style.transitionDuration = null;\n        el.style.transitionTimingFunction = null;\n      }\n\n    };\n    transition(el, stages, type, reject);\n  }\n\n  const ensureStringExpression = (expression, el, component) => {\n    return typeof expression === 'function' ? component.evaluateReturnExpression(el, expression) : expression;\n  };\n\n  function transitionClassesIn(el, component, directives, showCallback, reject) {\n    const enter = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'enter') || {\n      expression: ''\n    }).expression, el, component));\n    const enterStart = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'enter-start') || {\n      expression: ''\n    }).expression, el, component));\n    const enterEnd = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'enter-end') || {\n      expression: ''\n    }).expression, el, component));\n    transitionClasses(el, enter, enterStart, enterEnd, showCallback, () => {}, TRANSITION_TYPE_IN, reject);\n  }\n  function transitionClassesOut(el, component, directives, hideCallback, reject) {\n    const leave = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'leave') || {\n      expression: ''\n    }).expression, el, component));\n    const leaveStart = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'leave-start') || {\n      expression: ''\n    }).expression, el, component));\n    const leaveEnd = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'leave-end') || {\n      expression: ''\n    }).expression, el, component));\n    transitionClasses(el, leave, leaveStart, leaveEnd, () => {}, hideCallback, TRANSITION_TYPE_OUT, reject);\n  }\n  function transitionClasses(el, classesDuring, classesStart, classesEnd, hook1, hook2, type, reject) {\n    // clear the previous transition if exists to avoid caching the wrong classes\n    if (el.__x_transition) {\n      el.__x_transition.cancel && el.__x_transition.cancel();\n    }\n\n    const originalClasses = el.__x_original_classes || [];\n    const stages = {\n      start() {\n        el.classList.add(...classesStart);\n      },\n\n      during() {\n        el.classList.add(...classesDuring);\n      },\n\n      show() {\n        hook1();\n      },\n\n      end() {\n        // Don't remove classes that were in the original class attribute.\n        el.classList.remove(...classesStart.filter(i => !originalClasses.includes(i)));\n        el.classList.add(...classesEnd);\n      },\n\n      hide() {\n        hook2();\n      },\n\n      cleanup() {\n        el.classList.remove(...classesDuring.filter(i => !originalClasses.includes(i)));\n        el.classList.remove(...classesEnd.filter(i => !originalClasses.includes(i)));\n      }\n\n    };\n    transition(el, stages, type, reject);\n  }\n  function transition(el, stages, type, reject) {\n    const finish = once(() => {\n      stages.hide(); // Adding an \"isConnected\" check, in case the callback\n      // removed the element from the DOM.\n\n      if (el.isConnected) {\n        stages.cleanup();\n      }\n\n      delete el.__x_transition;\n    });\n    el.__x_transition = {\n      // Set transition type so we can avoid clearing transition if the direction is the same\n      type: type,\n      // create a callback for the last stages of the transition so we can call it\n      // from different point and early terminate it. Once will ensure that function\n      // is only called one time.\n      cancel: once(() => {\n        reject(TRANSITION_CANCELLED);\n        finish();\n      }),\n      finish,\n      // This store the next animation frame so we can cancel it\n      nextFrame: null\n    };\n    stages.start();\n    stages.during();\n    el.__x_transition.nextFrame = requestAnimationFrame(() => {\n      // Note: Safari's transitionDuration property will list out comma separated transition durations\n      // for every single transition property. Let's grab the first one and call it a day.\n      let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, '').replace('s', '')) * 1000;\n\n      if (duration === 0) {\n        duration = Number(getComputedStyle(el).animationDuration.replace('s', '')) * 1000;\n      }\n\n      stages.show();\n      el.__x_transition.nextFrame = requestAnimationFrame(() => {\n        stages.end();\n        setTimeout(el.__x_transition.finish, duration);\n      });\n    });\n  }\n  function isNumeric(subject) {\n    return !Array.isArray(subject) && !isNaN(subject);\n  } // Thanks @vuejs\n  // https://github.com/vuejs/vue/blob/4de4649d9637262a9b007720b59f80ac72a5620c/src/shared/util.js\n\n  function once(callback) {\n    let called = false;\n    return function () {\n      if (!called) {\n        called = true;\n        callback.apply(this, arguments);\n      }\n    };\n  }\n\n  function handleForDirective(component, templateEl, expression, initialUpdate, extraVars) {\n    warnIfMalformedTemplate(templateEl, 'x-for');\n    let iteratorNames = typeof expression === 'function' ? parseForExpression(component.evaluateReturnExpression(templateEl, expression)) : parseForExpression(expression);\n    let items = evaluateItemsAndReturnEmptyIfXIfIsPresentAndFalseOnElement(component, templateEl, iteratorNames, extraVars); // As we walk the array, we'll also walk the DOM (updating/creating as we go).\n\n    let currentEl = templateEl;\n    items.forEach((item, index) => {\n      let iterationScopeVariables = getIterationScopeVariables(iteratorNames, item, index, items, extraVars());\n      let currentKey = generateKeyForIteration(component, templateEl, index, iterationScopeVariables);\n      let nextEl = lookAheadForMatchingKeyedElementAndMoveItIfFound(currentEl.nextElementSibling, currentKey); // If we haven't found a matching key, insert the element at the current position.\n\n      if (!nextEl) {\n        nextEl = addElementInLoopAfterCurrentEl(templateEl, currentEl); // And transition it in if it's not the first page load.\n\n        transitionIn(nextEl, () => {}, () => {}, component, initialUpdate);\n        nextEl.__x_for = iterationScopeVariables;\n        component.initializeElements(nextEl, () => nextEl.__x_for); // Otherwise update the element we found.\n      } else {\n        // Temporarily remove the key indicator to allow the normal \"updateElements\" to work.\n        delete nextEl.__x_for_key;\n        nextEl.__x_for = iterationScopeVariables;\n        component.updateElements(nextEl, () => nextEl.__x_for);\n      }\n\n      currentEl = nextEl;\n      currentEl.__x_for_key = currentKey;\n    });\n    removeAnyLeftOverElementsFromPreviousUpdate(currentEl, component);\n  } // This was taken from VueJS 2.* core. Thanks Vue!\n\n  function parseForExpression(expression) {\n    let forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n    let stripParensRE = /^\\(|\\)$/g;\n    let forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n    let inMatch = String(expression).match(forAliasRE);\n    if (!inMatch) return;\n    let res = {};\n    res.items = inMatch[2].trim();\n    let item = inMatch[1].trim().replace(stripParensRE, '');\n    let iteratorMatch = item.match(forIteratorRE);\n\n    if (iteratorMatch) {\n      res.item = item.replace(forIteratorRE, '').trim();\n      res.index = iteratorMatch[1].trim();\n\n      if (iteratorMatch[2]) {\n        res.collection = iteratorMatch[2].trim();\n      }\n    } else {\n      res.item = item;\n    }\n\n    return res;\n  }\n\n  function getIterationScopeVariables(iteratorNames, item, index, items, extraVars) {\n    // We must create a new object, so each iteration has a new scope\n    let scopeVariables = extraVars ? _objectSpread2({}, extraVars) : {};\n    scopeVariables[iteratorNames.item] = item;\n    if (iteratorNames.index) scopeVariables[iteratorNames.index] = index;\n    if (iteratorNames.collection) scopeVariables[iteratorNames.collection] = items;\n    return scopeVariables;\n  }\n\n  function generateKeyForIteration(component, el, index, iterationScopeVariables) {\n    let bindKeyAttribute = getXAttrs(el, component, 'bind').filter(attr => attr.value === 'key')[0]; // If the dev hasn't specified a key, just return the index of the iteration.\n\n    if (!bindKeyAttribute) return index;\n    return component.evaluateReturnExpression(el, bindKeyAttribute.expression, () => iterationScopeVariables);\n  }\n\n  function evaluateItemsAndReturnEmptyIfXIfIsPresentAndFalseOnElement(component, el, iteratorNames, extraVars) {\n    let ifAttribute = getXAttrs(el, component, 'if')[0];\n\n    if (ifAttribute && !component.evaluateReturnExpression(el, ifAttribute.expression)) {\n      return [];\n    }\n\n    let items = component.evaluateReturnExpression(el, iteratorNames.items, extraVars); // This adds support for the `i in n` syntax.\n\n    if (isNumeric(items) && items >= 0) {\n      items = Array.from(Array(items).keys(), i => i + 1);\n    }\n\n    return items;\n  }\n\n  function addElementInLoopAfterCurrentEl(templateEl, currentEl) {\n    let clone = document.importNode(templateEl.content, true);\n    currentEl.parentElement.insertBefore(clone, currentEl.nextElementSibling);\n    return currentEl.nextElementSibling;\n  }\n\n  function lookAheadForMatchingKeyedElementAndMoveItIfFound(nextEl, currentKey) {\n    if (!nextEl) return; // If we are already past the x-for generated elements, we don't need to look ahead.\n\n    if (nextEl.__x_for_key === undefined) return; // If the the key's DO match, no need to look ahead.\n\n    if (nextEl.__x_for_key === currentKey) return nextEl; // If they don't, we'll look ahead for a match.\n    // If we find it, we'll move it to the current position in the loop.\n\n    let tmpNextEl = nextEl;\n\n    while (tmpNextEl) {\n      if (tmpNextEl.__x_for_key === currentKey) {\n        return tmpNextEl.parentElement.insertBefore(tmpNextEl, nextEl);\n      }\n\n      tmpNextEl = tmpNextEl.nextElementSibling && tmpNextEl.nextElementSibling.__x_for_key !== undefined ? tmpNextEl.nextElementSibling : false;\n    }\n  }\n\n  function removeAnyLeftOverElementsFromPreviousUpdate(currentEl, component) {\n    var nextElementFromOldLoop = currentEl.nextElementSibling && currentEl.nextElementSibling.__x_for_key !== undefined ? currentEl.nextElementSibling : false;\n\n    while (nextElementFromOldLoop) {\n      let nextElementFromOldLoopImmutable = nextElementFromOldLoop;\n      let nextSibling = nextElementFromOldLoop.nextElementSibling;\n      transitionOut(nextElementFromOldLoop, () => {\n        nextElementFromOldLoopImmutable.remove();\n      }, () => {}, component);\n      nextElementFromOldLoop = nextSibling && nextSibling.__x_for_key !== undefined ? nextSibling : false;\n    }\n  }\n\n  function handleAttributeBindingDirective(component, el, attrName, expression, extraVars, attrType, modifiers) {\n    var value = component.evaluateReturnExpression(el, expression, extraVars);\n\n    if (attrName === 'value') {\n      if (Alpine.ignoreFocusedForValueBinding && document.activeElement.isSameNode(el)) return; // If nested model key is undefined, set the default value to empty string.\n\n      if (value === undefined && String(expression).match(/\\./)) {\n        value = '';\n      }\n\n      if (el.type === 'radio') {\n        // Set radio value from x-bind:value, if no \"value\" attribute exists.\n        // If there are any initial state values, radio will have a correct\n        // \"checked\" value since x-bind:value is processed before x-model.\n        if (el.attributes.value === undefined && attrType === 'bind') {\n          el.value = value;\n        } else if (attrType !== 'bind') {\n          el.checked = checkedAttrLooseCompare(el.value, value);\n        }\n      } else if (el.type === 'checkbox') {\n        // If we are explicitly binding a string to the :value, set the string,\n        // If the value is a boolean, leave it alone, it will be set to \"on\"\n        // automatically.\n        if (typeof value !== 'boolean' && ![null, undefined].includes(value) && attrType === 'bind') {\n          el.value = String(value);\n        } else if (attrType !== 'bind') {\n          if (Array.isArray(value)) {\n            // I'm purposely not using Array.includes here because it's\n            // strict, and because of Numeric/String mis-casting, I\n            // want the \"includes\" to be \"fuzzy\".\n            el.checked = value.some(val => checkedAttrLooseCompare(val, el.value));\n          } else {\n            el.checked = !!value;\n          }\n        }\n      } else if (el.tagName === 'SELECT') {\n        updateSelect(el, value);\n      } else {\n        if (el.value === value) return;\n        el.value = value;\n      }\n    } else if (attrName === 'class') {\n      if (Array.isArray(value)) {\n        const originalClasses = el.__x_original_classes || [];\n        el.setAttribute('class', arrayUnique(originalClasses.concat(value)).join(' '));\n      } else if (typeof value === 'object') {\n        // Sorting the keys / class names by their boolean value will ensure that\n        // anything that evaluates to `false` and needs to remove classes is run first.\n        const keysSortedByBooleanValue = Object.keys(value).sort((a, b) => value[a] - value[b]);\n        keysSortedByBooleanValue.forEach(classNames => {\n          if (value[classNames]) {\n            convertClassStringToArray(classNames).forEach(className => el.classList.add(className));\n          } else {\n            convertClassStringToArray(classNames).forEach(className => el.classList.remove(className));\n          }\n        });\n      } else {\n        const originalClasses = el.__x_original_classes || [];\n        const newClasses = value ? convertClassStringToArray(value) : [];\n        el.setAttribute('class', arrayUnique(originalClasses.concat(newClasses)).join(' '));\n      }\n    } else {\n      attrName = modifiers.includes('camel') ? camelCase(attrName) : attrName; // If an attribute's bound value is null, undefined or false, remove the attribute\n\n      if ([null, undefined, false].includes(value)) {\n        el.removeAttribute(attrName);\n      } else {\n        isBooleanAttr(attrName) ? setIfChanged(el, attrName, attrName) : setIfChanged(el, attrName, value);\n      }\n    }\n  }\n\n  function setIfChanged(el, attrName, value) {\n    if (el.getAttribute(attrName) != value) {\n      el.setAttribute(attrName, value);\n    }\n  }\n\n  function updateSelect(el, value) {\n    const arrayWrappedValue = [].concat(value).map(value => {\n      return value + '';\n    });\n    Array.from(el.options).forEach(option => {\n      option.selected = arrayWrappedValue.includes(option.value || option.text);\n    });\n  }\n\n  function handleTextDirective(el, output, expression) {\n    // If nested model key is undefined, set the default value to empty string.\n    if (output === undefined && String(expression).match(/\\./)) {\n      output = '';\n    }\n\n    el.textContent = output;\n  }\n\n  function handleHtmlDirective(component, el, expression, extraVars) {\n    el.innerHTML = component.evaluateReturnExpression(el, expression, extraVars);\n  }\n\n  function handleShowDirective(component, el, value, modifiers, initialUpdate = false) {\n    const hide = () => {\n      el.style.display = 'none';\n      el.__x_is_shown = false;\n    };\n\n    const show = () => {\n      if (el.style.length === 1 && el.style.display === 'none') {\n        el.removeAttribute('style');\n      } else {\n        el.style.removeProperty('display');\n      }\n\n      el.__x_is_shown = true;\n    };\n\n    if (initialUpdate === true) {\n      if (value) {\n        show();\n      } else {\n        hide();\n      }\n\n      return;\n    }\n\n    const handle = (resolve, reject) => {\n      if (value) {\n        if (el.style.display === 'none' || el.__x_transition) {\n          transitionIn(el, () => {\n            show();\n          }, reject, component);\n        }\n\n        resolve(() => {});\n      } else {\n        if (el.style.display !== 'none') {\n          transitionOut(el, () => {\n            resolve(() => {\n              hide();\n            });\n          }, reject, component);\n        } else {\n          resolve(() => {});\n        }\n      }\n    }; // The working of x-show is a bit complex because we need to\n    // wait for any child transitions to finish before hiding\n    // some element. Also, this has to be done recursively.\n    // If x-show.immediate, foregoe the waiting.\n\n\n    if (modifiers.includes('immediate')) {\n      handle(finish => finish(), () => {});\n      return;\n    } // x-show is encountered during a DOM tree walk. If an element\n    // we encounter is NOT a child of another x-show element we\n    // can execute the previous x-show stack (if one exists).\n\n\n    if (component.showDirectiveLastElement && !component.showDirectiveLastElement.contains(el)) {\n      component.executeAndClearRemainingShowDirectiveStack();\n    }\n\n    component.showDirectiveStack.push(handle);\n    component.showDirectiveLastElement = el;\n  }\n\n  function handleIfDirective(component, el, expressionResult, initialUpdate, extraVars) {\n    warnIfMalformedTemplate(el, 'x-if');\n    const elementHasAlreadyBeenAdded = el.nextElementSibling && el.nextElementSibling.__x_inserted_me === true;\n\n    if (expressionResult && (!elementHasAlreadyBeenAdded || el.__x_transition)) {\n      const clone = document.importNode(el.content, true);\n      el.parentElement.insertBefore(clone, el.nextElementSibling);\n      transitionIn(el.nextElementSibling, () => {}, () => {}, component, initialUpdate);\n      component.initializeElements(el.nextElementSibling, extraVars);\n      el.nextElementSibling.__x_inserted_me = true;\n    } else if (!expressionResult && elementHasAlreadyBeenAdded) {\n      transitionOut(el.nextElementSibling, () => {\n        el.nextElementSibling.remove();\n      }, () => {}, component, initialUpdate);\n    }\n  }\n\n  function registerListener(component, el, event, modifiers, expression, extraVars = {}) {\n    const options = {\n      passive: modifiers.includes('passive')\n    };\n\n    if (modifiers.includes('camel')) {\n      event = camelCase(event);\n    }\n\n    let handler, listenerTarget;\n\n    if (modifiers.includes('away')) {\n      listenerTarget = document;\n\n      handler = e => {\n        // Don't do anything if the click came from the element or within it.\n        if (el.contains(e.target)) return; // Don't do anything if this element isn't currently visible.\n\n        if (el.offsetWidth < 1 && el.offsetHeight < 1) return; // Now that we are sure the element is visible, AND the click\n        // is from outside it, let's run the expression.\n\n        runListenerHandler(component, expression, e, extraVars);\n\n        if (modifiers.includes('once')) {\n          document.removeEventListener(event, handler, options);\n        }\n      };\n    } else {\n      listenerTarget = modifiers.includes('window') ? window : modifiers.includes('document') ? document : el;\n\n      handler = e => {\n        // Remove this global event handler if the element that declared it\n        // has been removed. It's now stale.\n        if (listenerTarget === window || listenerTarget === document) {\n          if (!document.body.contains(el)) {\n            listenerTarget.removeEventListener(event, handler, options);\n            return;\n          }\n        }\n\n        if (isKeyEvent(event)) {\n          if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {\n            return;\n          }\n        }\n\n        if (modifiers.includes('prevent')) e.preventDefault();\n        if (modifiers.includes('stop')) e.stopPropagation(); // If the .self modifier isn't present, or if it is present and\n        // the target element matches the element we are registering the\n        // event on, run the handler\n\n        if (!modifiers.includes('self') || e.target === el) {\n          const returnValue = runListenerHandler(component, expression, e, extraVars);\n          returnValue.then(value => {\n            if (value === false) {\n              e.preventDefault();\n            } else {\n              if (modifiers.includes('once')) {\n                listenerTarget.removeEventListener(event, handler, options);\n              }\n            }\n          });\n        }\n      };\n    }\n\n    if (modifiers.includes('debounce')) {\n      let nextModifier = modifiers[modifiers.indexOf('debounce') + 1] || 'invalid-wait';\n      let wait = isNumeric(nextModifier.split('ms')[0]) ? Number(nextModifier.split('ms')[0]) : 250;\n      handler = debounce(handler, wait);\n    }\n\n    listenerTarget.addEventListener(event, handler, options);\n  }\n\n  function runListenerHandler(component, expression, e, extraVars) {\n    return component.evaluateCommandExpression(e.target, expression, () => {\n      return _objectSpread2(_objectSpread2({}, extraVars()), {}, {\n        '$event': e\n      });\n    });\n  }\n\n  function isKeyEvent(event) {\n    return ['keydown', 'keyup'].includes(event);\n  }\n\n  function isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {\n    let keyModifiers = modifiers.filter(i => {\n      return !['window', 'document', 'prevent', 'stop'].includes(i);\n    });\n\n    if (keyModifiers.includes('debounce')) {\n      let debounceIndex = keyModifiers.indexOf('debounce');\n      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || 'invalid-wait').split('ms')[0]) ? 2 : 1);\n    } // If no modifier is specified, we'll call it a press.\n\n\n    if (keyModifiers.length === 0) return false; // If one is passed, AND it matches the key pressed, we'll call it a press.\n\n    if (keyModifiers.length === 1 && keyModifiers[0] === keyToModifier(e.key)) return false; // The user is listening for key combinations.\n\n    const systemKeyModifiers = ['ctrl', 'shift', 'alt', 'meta', 'cmd', 'super'];\n    const selectedSystemKeyModifiers = systemKeyModifiers.filter(modifier => keyModifiers.includes(modifier));\n    keyModifiers = keyModifiers.filter(i => !selectedSystemKeyModifiers.includes(i));\n\n    if (selectedSystemKeyModifiers.length > 0) {\n      const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter(modifier => {\n        // Alias \"cmd\" and \"super\" to \"meta\"\n        if (modifier === 'cmd' || modifier === 'super') modifier = 'meta';\n        return e[`${modifier}Key`];\n      }); // If all the modifiers selected are pressed, ...\n\n      if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {\n        // AND the remaining key is pressed as well. It's a press.\n        if (keyModifiers[0] === keyToModifier(e.key)) return false;\n      }\n    } // We'll call it NOT a valid keypress.\n\n\n    return true;\n  }\n\n  function keyToModifier(key) {\n    switch (key) {\n      case '/':\n        return 'slash';\n\n      case ' ':\n      case 'Spacebar':\n        return 'space';\n\n      default:\n        return key && kebabCase(key);\n    }\n  }\n\n  function registerModelListener(component, el, modifiers, expression, extraVars) {\n    // If the element we are binding to is a select, a radio, or checkbox\n    // we'll listen for the change event instead of the \"input\" event.\n    var event = el.tagName.toLowerCase() === 'select' || ['checkbox', 'radio'].includes(el.type) || modifiers.includes('lazy') ? 'change' : 'input';\n    const listenerExpression = `${expression} = rightSideOfExpression($event, ${expression})`;\n    registerListener(component, el, event, modifiers, listenerExpression, () => {\n      return _objectSpread2(_objectSpread2({}, extraVars()), {}, {\n        rightSideOfExpression: generateModelAssignmentFunction(el, modifiers, expression)\n      });\n    });\n  }\n\n  function generateModelAssignmentFunction(el, modifiers, expression) {\n    if (el.type === 'radio') {\n      // Radio buttons only work properly when they share a name attribute.\n      // People might assume we take care of that for them, because\n      // they already set a shared \"x-model\" attribute.\n      if (!el.hasAttribute('name')) el.setAttribute('name', expression);\n    }\n\n    return (event, currentValue) => {\n      // Check for event.detail due to an issue where IE11 handles other events as a CustomEvent.\n      if (event instanceof CustomEvent && event.detail) {\n        return event.detail;\n      } else if (el.type === 'checkbox') {\n        // If the data we are binding to is an array, toggle its value inside the array.\n        if (Array.isArray(currentValue)) {\n          const newValue = modifiers.includes('number') ? safeParseNumber(event.target.value) : event.target.value;\n          return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter(el => !checkedAttrLooseCompare(el, newValue));\n        } else {\n          return event.target.checked;\n        }\n      } else if (el.tagName.toLowerCase() === 'select' && el.multiple) {\n        return modifiers.includes('number') ? Array.from(event.target.selectedOptions).map(option => {\n          const rawValue = option.value || option.text;\n          return safeParseNumber(rawValue);\n        }) : Array.from(event.target.selectedOptions).map(option => {\n          return option.value || option.text;\n        });\n      } else {\n        const rawValue = event.target.value;\n        return modifiers.includes('number') ? safeParseNumber(rawValue) : modifiers.includes('trim') ? rawValue.trim() : rawValue;\n      }\n    };\n  }\n\n  function safeParseNumber(rawValue) {\n    const number = rawValue ? parseFloat(rawValue) : null;\n    return isNumeric(number) ? number : rawValue;\n  }\n\n  /**\n   * Copyright (C) 2017 salesforce.com, inc.\n   */\n  const { isArray } = Array;\n  const { getPrototypeOf, create: ObjectCreate, defineProperty: ObjectDefineProperty, defineProperties: ObjectDefineProperties, isExtensible, getOwnPropertyDescriptor, getOwnPropertyNames, getOwnPropertySymbols, preventExtensions, hasOwnProperty, } = Object;\n  const { push: ArrayPush, concat: ArrayConcat, map: ArrayMap, } = Array.prototype;\n  function isUndefined(obj) {\n      return obj === undefined;\n  }\n  function isFunction(obj) {\n      return typeof obj === 'function';\n  }\n  function isObject(obj) {\n      return typeof obj === 'object';\n  }\n  const proxyToValueMap = new WeakMap();\n  function registerProxy(proxy, value) {\n      proxyToValueMap.set(proxy, value);\n  }\n  const unwrap = (replicaOrAny) => proxyToValueMap.get(replicaOrAny) || replicaOrAny;\n\n  function wrapValue(membrane, value) {\n      return membrane.valueIsObservable(value) ? membrane.getProxy(value) : value;\n  }\n  /**\n   * Unwrap property descriptors will set value on original descriptor\n   * We only need to unwrap if value is specified\n   * @param descriptor external descrpitor provided to define new property on original value\n   */\n  function unwrapDescriptor(descriptor) {\n      if (hasOwnProperty.call(descriptor, 'value')) {\n          descriptor.value = unwrap(descriptor.value);\n      }\n      return descriptor;\n  }\n  function lockShadowTarget(membrane, shadowTarget, originalTarget) {\n      const targetKeys = ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));\n      targetKeys.forEach((key) => {\n          let descriptor = getOwnPropertyDescriptor(originalTarget, key);\n          // We do not need to wrap the descriptor if configurable\n          // Because we can deal with wrapping it when user goes through\n          // Get own property descriptor. There is also a chance that this descriptor\n          // could change sometime in the future, so we can defer wrapping\n          // until we need to\n          if (!descriptor.configurable) {\n              descriptor = wrapDescriptor(membrane, descriptor, wrapValue);\n          }\n          ObjectDefineProperty(shadowTarget, key, descriptor);\n      });\n      preventExtensions(shadowTarget);\n  }\n  class ReactiveProxyHandler {\n      constructor(membrane, value) {\n          this.originalTarget = value;\n          this.membrane = membrane;\n      }\n      get(shadowTarget, key) {\n          const { originalTarget, membrane } = this;\n          const value = originalTarget[key];\n          const { valueObserved } = membrane;\n          valueObserved(originalTarget, key);\n          return membrane.getProxy(value);\n      }\n      set(shadowTarget, key, value) {\n          const { originalTarget, membrane: { valueMutated } } = this;\n          const oldValue = originalTarget[key];\n          if (oldValue !== value) {\n              originalTarget[key] = value;\n              valueMutated(originalTarget, key);\n          }\n          else if (key === 'length' && isArray(originalTarget)) {\n              // fix for issue #236: push will add the new index, and by the time length\n              // is updated, the internal length is already equal to the new length value\n              // therefore, the oldValue is equal to the value. This is the forking logic\n              // to support this use case.\n              valueMutated(originalTarget, key);\n          }\n          return true;\n      }\n      deleteProperty(shadowTarget, key) {\n          const { originalTarget, membrane: { valueMutated } } = this;\n          delete originalTarget[key];\n          valueMutated(originalTarget, key);\n          return true;\n      }\n      apply(shadowTarget, thisArg, argArray) {\n          /* No op */\n      }\n      construct(target, argArray, newTarget) {\n          /* No op */\n      }\n      has(shadowTarget, key) {\n          const { originalTarget, membrane: { valueObserved } } = this;\n          valueObserved(originalTarget, key);\n          return key in originalTarget;\n      }\n      ownKeys(shadowTarget) {\n          const { originalTarget } = this;\n          return ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));\n      }\n      isExtensible(shadowTarget) {\n          const shadowIsExtensible = isExtensible(shadowTarget);\n          if (!shadowIsExtensible) {\n              return shadowIsExtensible;\n          }\n          const { originalTarget, membrane } = this;\n          const targetIsExtensible = isExtensible(originalTarget);\n          if (!targetIsExtensible) {\n              lockShadowTarget(membrane, shadowTarget, originalTarget);\n          }\n          return targetIsExtensible;\n      }\n      setPrototypeOf(shadowTarget, prototype) {\n      }\n      getPrototypeOf(shadowTarget) {\n          const { originalTarget } = this;\n          return getPrototypeOf(originalTarget);\n      }\n      getOwnPropertyDescriptor(shadowTarget, key) {\n          const { originalTarget, membrane } = this;\n          const { valueObserved } = this.membrane;\n          // keys looked up via hasOwnProperty need to be reactive\n          valueObserved(originalTarget, key);\n          let desc = getOwnPropertyDescriptor(originalTarget, key);\n          if (isUndefined(desc)) {\n              return desc;\n          }\n          const shadowDescriptor = getOwnPropertyDescriptor(shadowTarget, key);\n          if (!isUndefined(shadowDescriptor)) {\n              return shadowDescriptor;\n          }\n          // Note: by accessing the descriptor, the key is marked as observed\n          // but access to the value, setter or getter (if available) cannot observe\n          // mutations, just like regular methods, in which case we just do nothing.\n          desc = wrapDescriptor(membrane, desc, wrapValue);\n          if (!desc.configurable) {\n              // If descriptor from original target is not configurable,\n              // We must copy the wrapped descriptor over to the shadow target.\n              // Otherwise, proxy will throw an invariant error.\n              // This is our last chance to lock the value.\n              // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants\n              ObjectDefineProperty(shadowTarget, key, desc);\n          }\n          return desc;\n      }\n      preventExtensions(shadowTarget) {\n          const { originalTarget, membrane } = this;\n          lockShadowTarget(membrane, shadowTarget, originalTarget);\n          preventExtensions(originalTarget);\n          return true;\n      }\n      defineProperty(shadowTarget, key, descriptor) {\n          const { originalTarget, membrane } = this;\n          const { valueMutated } = membrane;\n          const { configurable } = descriptor;\n          // We have to check for value in descriptor\n          // because Object.freeze(proxy) calls this method\n          // with only { configurable: false, writeable: false }\n          // Additionally, method will only be called with writeable:false\n          // if the descriptor has a value, as opposed to getter/setter\n          // So we can just check if writable is present and then see if\n          // value is present. This eliminates getter and setter descriptors\n          if (hasOwnProperty.call(descriptor, 'writable') && !hasOwnProperty.call(descriptor, 'value')) {\n              const originalDescriptor = getOwnPropertyDescriptor(originalTarget, key);\n              descriptor.value = originalDescriptor.value;\n          }\n          ObjectDefineProperty(originalTarget, key, unwrapDescriptor(descriptor));\n          if (configurable === false) {\n              ObjectDefineProperty(shadowTarget, key, wrapDescriptor(membrane, descriptor, wrapValue));\n          }\n          valueMutated(originalTarget, key);\n          return true;\n      }\n  }\n\n  function wrapReadOnlyValue(membrane, value) {\n      return membrane.valueIsObservable(value) ? membrane.getReadOnlyProxy(value) : value;\n  }\n  class ReadOnlyHandler {\n      constructor(membrane, value) {\n          this.originalTarget = value;\n          this.membrane = membrane;\n      }\n      get(shadowTarget, key) {\n          const { membrane, originalTarget } = this;\n          const value = originalTarget[key];\n          const { valueObserved } = membrane;\n          valueObserved(originalTarget, key);\n          return membrane.getReadOnlyProxy(value);\n      }\n      set(shadowTarget, key, value) {\n          return false;\n      }\n      deleteProperty(shadowTarget, key) {\n          return false;\n      }\n      apply(shadowTarget, thisArg, argArray) {\n          /* No op */\n      }\n      construct(target, argArray, newTarget) {\n          /* No op */\n      }\n      has(shadowTarget, key) {\n          const { originalTarget, membrane: { valueObserved } } = this;\n          valueObserved(originalTarget, key);\n          return key in originalTarget;\n      }\n      ownKeys(shadowTarget) {\n          const { originalTarget } = this;\n          return ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));\n      }\n      setPrototypeOf(shadowTarget, prototype) {\n      }\n      getOwnPropertyDescriptor(shadowTarget, key) {\n          const { originalTarget, membrane } = this;\n          const { valueObserved } = membrane;\n          // keys looked up via hasOwnProperty need to be reactive\n          valueObserved(originalTarget, key);\n          let desc = getOwnPropertyDescriptor(originalTarget, key);\n          if (isUndefined(desc)) {\n              return desc;\n          }\n          const shadowDescriptor = getOwnPropertyDescriptor(shadowTarget, key);\n          if (!isUndefined(shadowDescriptor)) {\n              return shadowDescriptor;\n          }\n          // Note: by accessing the descriptor, the key is marked as observed\n          // but access to the value or getter (if available) cannot be observed,\n          // just like regular methods, in which case we just do nothing.\n          desc = wrapDescriptor(membrane, desc, wrapReadOnlyValue);\n          if (hasOwnProperty.call(desc, 'set')) {\n              desc.set = undefined; // readOnly membrane does not allow setters\n          }\n          if (!desc.configurable) {\n              // If descriptor from original target is not configurable,\n              // We must copy the wrapped descriptor over to the shadow target.\n              // Otherwise, proxy will throw an invariant error.\n              // This is our last chance to lock the value.\n              // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants\n              ObjectDefineProperty(shadowTarget, key, desc);\n          }\n          return desc;\n      }\n      preventExtensions(shadowTarget) {\n          return false;\n      }\n      defineProperty(shadowTarget, key, descriptor) {\n          return false;\n      }\n  }\n  function createShadowTarget(value) {\n      let shadowTarget = undefined;\n      if (isArray(value)) {\n          shadowTarget = [];\n      }\n      else if (isObject(value)) {\n          shadowTarget = {};\n      }\n      return shadowTarget;\n  }\n  const ObjectDotPrototype = Object.prototype;\n  function defaultValueIsObservable(value) {\n      // intentionally checking for null\n      if (value === null) {\n          return false;\n      }\n      // treat all non-object types, including undefined, as non-observable values\n      if (typeof value !== 'object') {\n          return false;\n      }\n      if (isArray(value)) {\n          return true;\n      }\n      const proto = getPrototypeOf(value);\n      return (proto === ObjectDotPrototype || proto === null || getPrototypeOf(proto) === null);\n  }\n  const defaultValueObserved = (obj, key) => {\n      /* do nothing */\n  };\n  const defaultValueMutated = (obj, key) => {\n      /* do nothing */\n  };\n  const defaultValueDistortion = (value) => value;\n  function wrapDescriptor(membrane, descriptor, getValue) {\n      const { set, get } = descriptor;\n      if (hasOwnProperty.call(descriptor, 'value')) {\n          descriptor.value = getValue(membrane, descriptor.value);\n      }\n      else {\n          if (!isUndefined(get)) {\n              descriptor.get = function () {\n                  // invoking the original getter with the original target\n                  return getValue(membrane, get.call(unwrap(this)));\n              };\n          }\n          if (!isUndefined(set)) {\n              descriptor.set = function (value) {\n                  // At this point we don't have a clear indication of whether\n                  // or not a valid mutation will occur, we don't have the key,\n                  // and we are not sure why and how they are invoking this setter.\n                  // Nevertheless we preserve the original semantics by invoking the\n                  // original setter with the original target and the unwrapped value\n                  set.call(unwrap(this), membrane.unwrapProxy(value));\n              };\n          }\n      }\n      return descriptor;\n  }\n  class ReactiveMembrane {\n      constructor(options) {\n          this.valueDistortion = defaultValueDistortion;\n          this.valueMutated = defaultValueMutated;\n          this.valueObserved = defaultValueObserved;\n          this.valueIsObservable = defaultValueIsObservable;\n          this.objectGraph = new WeakMap();\n          if (!isUndefined(options)) {\n              const { valueDistortion, valueMutated, valueObserved, valueIsObservable } = options;\n              this.valueDistortion = isFunction(valueDistortion) ? valueDistortion : defaultValueDistortion;\n              this.valueMutated = isFunction(valueMutated) ? valueMutated : defaultValueMutated;\n              this.valueObserved = isFunction(valueObserved) ? valueObserved : defaultValueObserved;\n              this.valueIsObservable = isFunction(valueIsObservable) ? valueIsObservable : defaultValueIsObservable;\n          }\n      }\n      getProxy(value) {\n          const unwrappedValue = unwrap(value);\n          const distorted = this.valueDistortion(unwrappedValue);\n          if (this.valueIsObservable(distorted)) {\n              const o = this.getReactiveState(unwrappedValue, distorted);\n              // when trying to extract the writable version of a readonly\n              // we return the readonly.\n              return o.readOnly === value ? value : o.reactive;\n          }\n          return distorted;\n      }\n      getReadOnlyProxy(value) {\n          value = unwrap(value);\n          const distorted = this.valueDistortion(value);\n          if (this.valueIsObservable(distorted)) {\n              return this.getReactiveState(value, distorted).readOnly;\n          }\n          return distorted;\n      }\n      unwrapProxy(p) {\n          return unwrap(p);\n      }\n      getReactiveState(value, distortedValue) {\n          const { objectGraph, } = this;\n          let reactiveState = objectGraph.get(distortedValue);\n          if (reactiveState) {\n              return reactiveState;\n          }\n          const membrane = this;\n          reactiveState = {\n              get reactive() {\n                  const reactiveHandler = new ReactiveProxyHandler(membrane, distortedValue);\n                  // caching the reactive proxy after the first time it is accessed\n                  const proxy = new Proxy(createShadowTarget(distortedValue), reactiveHandler);\n                  registerProxy(proxy, value);\n                  ObjectDefineProperty(this, 'reactive', { value: proxy });\n                  return proxy;\n              },\n              get readOnly() {\n                  const readOnlyHandler = new ReadOnlyHandler(membrane, distortedValue);\n                  // caching the readOnly proxy after the first time it is accessed\n                  const proxy = new Proxy(createShadowTarget(distortedValue), readOnlyHandler);\n                  registerProxy(proxy, value);\n                  ObjectDefineProperty(this, 'readOnly', { value: proxy });\n                  return proxy;\n              }\n          };\n          objectGraph.set(distortedValue, reactiveState);\n          return reactiveState;\n      }\n  }\n  /** version: 0.26.0 */\n\n  function wrap(data, mutationCallback) {\n\n    let membrane = new ReactiveMembrane({\n      valueMutated(target, key) {\n        mutationCallback(target, key);\n      }\n\n    });\n    return {\n      data: membrane.getProxy(data),\n      membrane: membrane\n    };\n  }\n  function unwrap$1(membrane, observable) {\n    let unwrappedData = membrane.unwrapProxy(observable);\n    let copy = {};\n    Object.keys(unwrappedData).forEach(key => {\n      if (['$el', '$refs', '$nextTick', '$watch'].includes(key)) return;\n      copy[key] = unwrappedData[key];\n    });\n    return copy;\n  }\n\n  class Component {\n    constructor(el, componentForClone = null) {\n      this.$el = el;\n      const dataAttr = this.$el.getAttribute('x-data');\n      const dataExpression = dataAttr === '' ? '{}' : dataAttr;\n      const initExpression = this.$el.getAttribute('x-init');\n      let dataExtras = {\n        $el: this.$el\n      };\n      let canonicalComponentElementReference = componentForClone ? componentForClone.$el : this.$el;\n      Object.entries(Alpine.magicProperties).forEach(([name, callback]) => {\n        Object.defineProperty(dataExtras, `$${name}`, {\n          get: function get() {\n            return callback(canonicalComponentElementReference);\n          }\n        });\n      });\n      this.unobservedData = componentForClone ? componentForClone.getUnobservedData() : saferEval(el, dataExpression, dataExtras);\n      // Construct a Proxy-based observable. This will be used to handle reactivity.\n\n      let {\n        membrane,\n        data\n      } = this.wrapDataInObservable(this.unobservedData);\n      this.$data = data;\n      this.membrane = membrane; // After making user-supplied data methods reactive, we can now add\n      // our magic properties to the original data for access.\n\n      this.unobservedData.$el = this.$el;\n      this.unobservedData.$refs = this.getRefsProxy();\n      this.nextTickStack = [];\n\n      this.unobservedData.$nextTick = callback => {\n        this.nextTickStack.push(callback);\n      };\n\n      this.watchers = {};\n\n      this.unobservedData.$watch = (property, callback) => {\n        if (!this.watchers[property]) this.watchers[property] = [];\n        this.watchers[property].push(callback);\n      };\n      /* MODERN-ONLY:START */\n      // We remove this piece of code from the legacy build.\n      // In IE11, we have already defined our helpers at this point.\n      // Register custom magic properties.\n\n\n      Object.entries(Alpine.magicProperties).forEach(([name, callback]) => {\n        Object.defineProperty(this.unobservedData, `$${name}`, {\n          get: function get() {\n            return callback(canonicalComponentElementReference, this.$el);\n          }\n        });\n      });\n      /* MODERN-ONLY:END */\n\n      this.showDirectiveStack = [];\n      this.showDirectiveLastElement;\n      componentForClone || Alpine.onBeforeComponentInitializeds.forEach(callback => callback(this));\n      var initReturnedCallback; // If x-init is present AND we aren't cloning (skip x-init on clone)\n\n      if (initExpression && !componentForClone) {\n        // We want to allow data manipulation, but not trigger DOM updates just yet.\n        // We haven't even initialized the elements with their Alpine bindings. I mean c'mon.\n        this.pauseReactivity = true;\n        initReturnedCallback = this.evaluateReturnExpression(this.$el, initExpression);\n        this.pauseReactivity = false;\n      } // Register all our listeners and set all our attribute bindings.\n      // If we're cloning a component, the third parameter ensures no duplicate\n      // event listeners are registered (the mutation observer will take care of them)\n\n\n      this.initializeElements(this.$el, () => {}, componentForClone); // Use mutation observer to detect new elements being added within this component at run-time.\n      // Alpine's just so darn flexible amirite?\n\n      this.listenForNewElementsToInitialize();\n\n      if (typeof initReturnedCallback === 'function') {\n        // Run the callback returned from the \"x-init\" hook to allow the user to do stuff after\n        // Alpine's got it's grubby little paws all over everything.\n        initReturnedCallback.call(this.$data);\n      }\n\n      componentForClone || setTimeout(() => {\n        Alpine.onComponentInitializeds.forEach(callback => callback(this));\n      }, 0);\n    }\n\n    getUnobservedData() {\n      return unwrap$1(this.membrane, this.$data);\n    }\n\n    wrapDataInObservable(data) {\n      var self = this;\n      let updateDom = debounce(function () {\n        self.updateElements(self.$el);\n      }, 0);\n      return wrap(data, (target, key) => {\n        if (self.watchers[key]) {\n          // If there's a watcher for this specific key, run it.\n          self.watchers[key].forEach(callback => callback(target[key]));\n        } else if (Array.isArray(target)) {\n          // Arrays are special cases, if any of the items change, we consider the array as mutated.\n          Object.keys(self.watchers).forEach(fullDotNotationKey => {\n            let dotNotationParts = fullDotNotationKey.split('.'); // Ignore length mutations since they would result in duplicate calls.\n            // For example, when calling push, we would get a mutation for the item's key\n            // and a second mutation for the length property.\n\n            if (key === 'length') return;\n            dotNotationParts.reduce((comparisonData, part) => {\n              if (Object.is(target, comparisonData[part])) {\n                self.watchers[fullDotNotationKey].forEach(callback => callback(target));\n              }\n\n              return comparisonData[part];\n            }, self.unobservedData);\n          });\n        } else {\n          // Let's walk through the watchers with \"dot-notation\" (foo.bar) and see\n          // if this mutation fits any of them.\n          Object.keys(self.watchers).filter(i => i.includes('.')).forEach(fullDotNotationKey => {\n            let dotNotationParts = fullDotNotationKey.split('.'); // If this dot-notation watcher's last \"part\" doesn't match the current\n            // key, then skip it early for performance reasons.\n\n            if (key !== dotNotationParts[dotNotationParts.length - 1]) return; // Now, walk through the dot-notation \"parts\" recursively to find\n            // a match, and call the watcher if one's found.\n\n            dotNotationParts.reduce((comparisonData, part) => {\n              if (Object.is(target, comparisonData)) {\n                // Run the watchers.\n                self.watchers[fullDotNotationKey].forEach(callback => callback(target[key]));\n              }\n\n              return comparisonData[part];\n            }, self.unobservedData);\n          });\n        } // Don't react to data changes for cases like the `x-created` hook.\n\n\n        if (self.pauseReactivity) return;\n        updateDom();\n      });\n    }\n\n    walkAndSkipNestedComponents(el, callback, initializeComponentCallback = () => {}) {\n      walk(el, el => {\n        // We've hit a component.\n        if (el.hasAttribute('x-data')) {\n          // If it's not the current one.\n          if (!el.isSameNode(this.$el)) {\n            // Initialize it if it's not.\n            if (!el.__x) initializeComponentCallback(el); // Now we'll let that sub-component deal with itself.\n\n            return false;\n          }\n        }\n\n        return callback(el);\n      });\n    }\n\n    initializeElements(rootEl, extraVars = () => {}, componentForClone = false) {\n      this.walkAndSkipNestedComponents(rootEl, el => {\n        // Don't touch spawns from for loop\n        if (el.__x_for_key !== undefined) return false; // Don't touch spawns from if directives\n\n        if (el.__x_inserted_me !== undefined) return false;\n        this.initializeElement(el, extraVars, componentForClone ? false : true);\n      }, el => {\n        if (!componentForClone) el.__x = new Component(el);\n      });\n      this.executeAndClearRemainingShowDirectiveStack();\n      this.executeAndClearNextTickStack(rootEl);\n    }\n\n    initializeElement(el, extraVars, shouldRegisterListeners = true) {\n      // To support class attribute merging, we have to know what the element's\n      // original class attribute looked like for reference.\n      if (el.hasAttribute('class') && getXAttrs(el, this).length > 0) {\n        el.__x_original_classes = convertClassStringToArray(el.getAttribute('class'));\n      }\n\n      shouldRegisterListeners && this.registerListeners(el, extraVars);\n      this.resolveBoundAttributes(el, true, extraVars);\n    }\n\n    updateElements(rootEl, extraVars = () => {}) {\n      this.walkAndSkipNestedComponents(rootEl, el => {\n        // Don't touch spawns from for loop (and check if the root is actually a for loop in a parent, don't skip it.)\n        if (el.__x_for_key !== undefined && !el.isSameNode(this.$el)) return false;\n        this.updateElement(el, extraVars);\n      }, el => {\n        el.__x = new Component(el);\n      });\n      this.executeAndClearRemainingShowDirectiveStack();\n      this.executeAndClearNextTickStack(rootEl);\n    }\n\n    executeAndClearNextTickStack(el) {\n      // Skip spawns from alpine directives\n      if (el === this.$el && this.nextTickStack.length > 0) {\n        // We run the tick stack after the next frame to allow any\n        // running transitions to pass the initial show stage.\n        requestAnimationFrame(() => {\n          while (this.nextTickStack.length > 0) {\n            this.nextTickStack.shift()();\n          }\n        });\n      }\n    }\n\n    executeAndClearRemainingShowDirectiveStack() {\n      // The goal here is to start all the x-show transitions\n      // and build a nested promise chain so that elements\n      // only hide when the children are finished hiding.\n      this.showDirectiveStack.reverse().map(handler => {\n        return new Promise((resolve, reject) => {\n          handler(resolve, reject);\n        });\n      }).reduce((promiseChain, promise) => {\n        return promiseChain.then(() => {\n          return promise.then(finishElement => {\n            finishElement();\n          });\n        });\n      }, Promise.resolve(() => {})).catch(e => {\n        if (e !== TRANSITION_CANCELLED) throw e;\n      }); // We've processed the handler stack. let's clear it.\n\n      this.showDirectiveStack = [];\n      this.showDirectiveLastElement = undefined;\n    }\n\n    updateElement(el, extraVars) {\n      this.resolveBoundAttributes(el, false, extraVars);\n    }\n\n    registerListeners(el, extraVars) {\n      getXAttrs(el, this).forEach(({\n        type,\n        value,\n        modifiers,\n        expression\n      }) => {\n        switch (type) {\n          case 'on':\n            registerListener(this, el, value, modifiers, expression, extraVars);\n            break;\n\n          case 'model':\n            registerModelListener(this, el, modifiers, expression, extraVars);\n            break;\n        }\n      });\n    }\n\n    resolveBoundAttributes(el, initialUpdate = false, extraVars) {\n      let attrs = getXAttrs(el, this);\n      attrs.forEach(({\n        type,\n        value,\n        modifiers,\n        expression\n      }) => {\n        switch (type) {\n          case 'model':\n            handleAttributeBindingDirective(this, el, 'value', expression, extraVars, type, modifiers);\n            break;\n\n          case 'bind':\n            // The :key binding on an x-for is special, ignore it.\n            if (el.tagName.toLowerCase() === 'template' && value === 'key') return;\n            handleAttributeBindingDirective(this, el, value, expression, extraVars, type, modifiers);\n            break;\n\n          case 'text':\n            var output = this.evaluateReturnExpression(el, expression, extraVars);\n            handleTextDirective(el, output, expression);\n            break;\n\n          case 'html':\n            handleHtmlDirective(this, el, expression, extraVars);\n            break;\n\n          case 'show':\n            var output = this.evaluateReturnExpression(el, expression, extraVars);\n            handleShowDirective(this, el, output, modifiers, initialUpdate);\n            break;\n\n          case 'if':\n            // If this element also has x-for on it, don't process x-if.\n            // We will let the \"x-for\" directive handle the \"if\"ing.\n            if (attrs.some(i => i.type === 'for')) return;\n            var output = this.evaluateReturnExpression(el, expression, extraVars);\n            handleIfDirective(this, el, output, initialUpdate, extraVars);\n            break;\n\n          case 'for':\n            handleForDirective(this, el, expression, initialUpdate, extraVars);\n            break;\n\n          case 'cloak':\n            el.removeAttribute('x-cloak');\n            break;\n        }\n      });\n    }\n\n    evaluateReturnExpression(el, expression, extraVars = () => {}) {\n      return saferEval(el, expression, this.$data, _objectSpread2(_objectSpread2({}, extraVars()), {}, {\n        $dispatch: this.getDispatchFunction(el)\n      }));\n    }\n\n    evaluateCommandExpression(el, expression, extraVars = () => {}) {\n      return saferEvalNoReturn(el, expression, this.$data, _objectSpread2(_objectSpread2({}, extraVars()), {}, {\n        $dispatch: this.getDispatchFunction(el)\n      }));\n    }\n\n    getDispatchFunction(el) {\n      return (event, detail = {}) => {\n        el.dispatchEvent(new CustomEvent(event, {\n          detail,\n          bubbles: true\n        }));\n      };\n    }\n\n    listenForNewElementsToInitialize() {\n      const targetNode = this.$el;\n      const observerOptions = {\n        childList: true,\n        attributes: true,\n        subtree: true\n      };\n      const observer = new MutationObserver(mutations => {\n        for (let i = 0; i < mutations.length; i++) {\n          // Filter out mutations triggered from child components.\n          const closestParentComponent = mutations[i].target.closest('[x-data]');\n          if (!(closestParentComponent && closestParentComponent.isSameNode(this.$el))) continue;\n\n          if (mutations[i].type === 'attributes' && mutations[i].attributeName === 'x-data') {\n            const xAttr = mutations[i].target.getAttribute('x-data') || '{}';\n            const rawData = saferEval(this.$el, xAttr, {\n              $el: this.$el\n            });\n            Object.keys(rawData).forEach(key => {\n              if (this.$data[key] !== rawData[key]) {\n                this.$data[key] = rawData[key];\n              }\n            });\n          }\n\n          if (mutations[i].addedNodes.length > 0) {\n            mutations[i].addedNodes.forEach(node => {\n              if (node.nodeType !== 1 || node.__x_inserted_me) return;\n\n              if (node.matches('[x-data]') && !node.__x) {\n                node.__x = new Component(node);\n                return;\n              }\n\n              this.initializeElements(node);\n            });\n          }\n        }\n      });\n      observer.observe(targetNode, observerOptions);\n    }\n\n    getRefsProxy() {\n      var self = this;\n      var refObj = {};\n      // One of the goals of this is to not hold elements in memory, but rather re-evaluate\n      // the DOM when the system needs something from it. This way, the framework is flexible and\n      // friendly to outside DOM changes from libraries like Vue/Livewire.\n      // For this reason, I'm using an \"on-demand\" proxy to fake a \"$refs\" object.\n\n      return new Proxy(refObj, {\n        get(object, property) {\n          if (property === '$isAlpineProxy') return true;\n          var ref; // We can't just query the DOM because it's hard to filter out refs in\n          // nested components.\n\n          self.walkAndSkipNestedComponents(self.$el, el => {\n            if (el.hasAttribute('x-ref') && el.getAttribute('x-ref') === property) {\n              ref = el;\n            }\n          });\n          return ref;\n        }\n\n      });\n    }\n\n  }\n\n  const Alpine = {\n    version: \"2.8.2\",\n    pauseMutationObserver: false,\n    magicProperties: {},\n    onComponentInitializeds: [],\n    onBeforeComponentInitializeds: [],\n    ignoreFocusedForValueBinding: false,\n    start: async function start() {\n      if (!isTesting()) {\n        await domReady();\n      }\n\n      this.discoverComponents(el => {\n        this.initializeComponent(el);\n      }); // It's easier and more performant to just support Turbolinks than listen\n      // to MutationObserver mutations at the document level.\n\n      document.addEventListener(\"turbolinks:load\", () => {\n        this.discoverUninitializedComponents(el => {\n          this.initializeComponent(el);\n        });\n      });\n      this.listenForNewUninitializedComponentsAtRunTime();\n    },\n    discoverComponents: function discoverComponents(callback) {\n      const rootEls = document.querySelectorAll('[x-data]');\n      rootEls.forEach(rootEl => {\n        callback(rootEl);\n      });\n    },\n    discoverUninitializedComponents: function discoverUninitializedComponents(callback, el = null) {\n      const rootEls = (el || document).querySelectorAll('[x-data]');\n      Array.from(rootEls).filter(el => el.__x === undefined).forEach(rootEl => {\n        callback(rootEl);\n      });\n    },\n    listenForNewUninitializedComponentsAtRunTime: function listenForNewUninitializedComponentsAtRunTime() {\n      const targetNode = document.querySelector('body');\n      const observerOptions = {\n        childList: true,\n        attributes: true,\n        subtree: true\n      };\n      const observer = new MutationObserver(mutations => {\n        if (this.pauseMutationObserver) return;\n\n        for (let i = 0; i < mutations.length; i++) {\n          if (mutations[i].addedNodes.length > 0) {\n            mutations[i].addedNodes.forEach(node => {\n              // Discard non-element nodes (like line-breaks)\n              if (node.nodeType !== 1) return; // Discard any changes happening within an existing component.\n              // They will take care of themselves.\n\n              if (node.parentElement && node.parentElement.closest('[x-data]')) return;\n              this.discoverUninitializedComponents(el => {\n                this.initializeComponent(el);\n              }, node.parentElement);\n            });\n          }\n        }\n      });\n      observer.observe(targetNode, observerOptions);\n    },\n    initializeComponent: function initializeComponent(el) {\n      if (!el.__x) {\n        // Wrap in a try/catch so that we don't prevent other components\n        // from initializing when one component contains an error.\n        try {\n          el.__x = new Component(el);\n        } catch (error) {\n          setTimeout(() => {\n            throw error;\n          }, 0);\n        }\n      }\n    },\n    clone: function clone(component, newEl) {\n      if (!newEl.__x) {\n        newEl.__x = new Component(newEl, component);\n      }\n    },\n    addMagicProperty: function addMagicProperty(name, callback) {\n      this.magicProperties[name] = callback;\n    },\n    onComponentInitialized: function onComponentInitialized(callback) {\n      this.onComponentInitializeds.push(callback);\n    },\n    onBeforeComponentInitialized: function onBeforeComponentInitialized(callback) {\n      this.onBeforeComponentInitializeds.push(callback);\n    }\n  };\n\n  if (!isTesting()) {\n    window.Alpine = Alpine;\n\n    if (window.deferLoadingAlpine) {\n      window.deferLoadingAlpine(function () {\n        window.Alpine.start();\n      });\n    } else {\n      window.Alpine.start();\n    }\n  }\n\n  return Alpine;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWxwaW5lanMvZGlzdC9hbHBpbmUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxwaW5lanMvZGlzdC9hbHBpbmUuanM/ZGYyNCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLkFscGluZSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBmdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgfSk7XG4gICAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXM7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICAgIGlmIChpICUgMikge1xuICAgICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIC8vIFRoYW5rcyBAc3RpbXVsdXM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdGltdWx1c2pzL3N0aW11bHVzL2Jsb2IvbWFzdGVyL3BhY2thZ2VzLyU0MHN0aW11bHVzL2NvcmUvc3JjL2FwcGxpY2F0aW9uLnRzXG4gIGZ1bmN0aW9uIGRvbVJlYWR5KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIHJlc29sdmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGFycmF5VW5pcXVlKGFycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChhcnJheSkpO1xuICB9XG4gIGZ1bmN0aW9uIGlzVGVzdGluZygpIHtcbiAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcIk5vZGUuanNcIikgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcyhcImpzZG9tXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrZWRBdHRyTG9vc2VDb21wYXJlKHZhbHVlQSwgdmFsdWVCKSB7XG4gICAgcmV0dXJuIHZhbHVlQSA9PSB2YWx1ZUI7XG4gIH1cbiAgZnVuY3Rpb24gd2FybklmTWFsZm9ybWVkVGVtcGxhdGUoZWwsIGRpcmVjdGl2ZSkge1xuICAgIGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIGNvbnNvbGUud2FybihgQWxwaW5lOiBbJHtkaXJlY3RpdmV9XSBkaXJlY3RpdmUgc2hvdWxkIG9ubHkgYmUgYWRkZWQgdG8gPHRlbXBsYXRlPiB0YWdzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FscGluZWpzL2FscGluZSMke2RpcmVjdGl2ZX1gKTtcbiAgICB9IGVsc2UgaWYgKGVsLmNvbnRlbnQuY2hpbGRFbGVtZW50Q291bnQgIT09IDEpIHtcbiAgICAgIGNvbnNvbGUud2FybihgQWxwaW5lOiA8dGVtcGxhdGU+IHRhZyB3aXRoIFske2RpcmVjdGl2ZX1dIGVuY291bnRlcmVkIHdpdGggYW4gdW5leHBlY3RlZCBudW1iZXIgb2Ygcm9vdCBlbGVtZW50cy4gTWFrZSBzdXJlIDx0ZW1wbGF0ZT4gaGFzIGEgc2luZ2xlIHJvb3QgZWxlbWVudC4gYCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGtlYmFiQ2FzZShzdWJqZWN0KSB7XG4gICAgcmV0dXJuIHN1YmplY3QucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgJyQxLSQyJykucmVwbGFjZSgvW19cXHNdLywgJy0nKS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIGZ1bmN0aW9uIGNhbWVsQ2FzZShzdWJqZWN0KSB7XG4gICAgcmV0dXJuIHN1YmplY3QudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tKFxcdykvZywgKG1hdGNoLCBjaGFyKSA9PiBjaGFyLnRvVXBwZXJDYXNlKCkpO1xuICB9XG4gIGZ1bmN0aW9uIHdhbGsoZWwsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGNhbGxiYWNrKGVsKSA9PT0gZmFsc2UpIHJldHVybjtcbiAgICBsZXQgbm9kZSA9IGVsLmZpcnN0RWxlbWVudENoaWxkO1xuXG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIHdhbGsobm9kZSwgY2FsbGJhY2spO1xuICAgICAgbm9kZSA9IG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0KSB7XG4gICAgdmFyIHRpbWVvdXQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcyxcbiAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiBsYXRlcigpIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICB9O1xuXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGhhbmRsZUVycm9yID0gKGVsLCBleHByZXNzaW9uLCBlcnJvcikgPT4ge1xuICAgIGNvbnNvbGUud2FybihgQWxwaW5lIEVycm9yOiBcIiR7ZXJyb3J9XCJcXG5cXG5FeHByZXNzaW9uOiBcIiR7ZXhwcmVzc2lvbn1cIlxcbkVsZW1lbnQ6YCwgZWwpO1xuXG4gICAgaWYgKCFpc1Rlc3RpbmcoKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihlcnJvciwge1xuICAgICAgICBlbCxcbiAgICAgICAgZXhwcmVzc2lvblxuICAgICAgfSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goY2IsIHtcbiAgICBlbCxcbiAgICBleHByZXNzaW9uXG4gIH0pIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdmFsdWUgPSBjYigpO1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSA/IHZhbHVlLmNhdGNoKGUgPT4gaGFuZGxlRXJyb3IoZWwsIGV4cHJlc3Npb24sIGUpKSA6IHZhbHVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGVsLCBleHByZXNzaW9uLCBlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzYWZlckV2YWwoZWwsIGV4cHJlc3Npb24sIGRhdGFDb250ZXh0LCBhZGRpdGlvbmFsSGVscGVyVmFyaWFibGVzID0ge30pIHtcbiAgICByZXR1cm4gdHJ5Q2F0Y2goKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBleHByZXNzaW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uLmNhbGwoZGF0YUNvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFsnJGRhdGEnLCAuLi5PYmplY3Qua2V5cyhhZGRpdGlvbmFsSGVscGVyVmFyaWFibGVzKV0sIGB2YXIgX19hbHBpbmVfcmVzdWx0OyB3aXRoKCRkYXRhKSB7IF9fYWxwaW5lX3Jlc3VsdCA9ICR7ZXhwcmVzc2lvbn0gfTsgcmV0dXJuIF9fYWxwaW5lX3Jlc3VsdGApKGRhdGFDb250ZXh0LCAuLi5PYmplY3QudmFsdWVzKGFkZGl0aW9uYWxIZWxwZXJWYXJpYWJsZXMpKTtcbiAgICB9LCB7XG4gICAgICBlbCxcbiAgICAgIGV4cHJlc3Npb25cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBzYWZlckV2YWxOb1JldHVybihlbCwgZXhwcmVzc2lvbiwgZGF0YUNvbnRleHQsIGFkZGl0aW9uYWxIZWxwZXJWYXJpYWJsZXMgPSB7fSkge1xuICAgIHJldHVybiB0cnlDYXRjaCgoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShleHByZXNzaW9uLmNhbGwoZGF0YUNvbnRleHQsIGFkZGl0aW9uYWxIZWxwZXJWYXJpYWJsZXNbJyRldmVudCddKSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBBc3luY0Z1bmN0aW9uID0gRnVuY3Rpb247XG4gICAgICAvKiBNT0RFUk4tT05MWTpTVEFSVCAqL1xuXG4gICAgICBBc3luY0Z1bmN0aW9uID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGFzeW5jIGZ1bmN0aW9uICgpIHt9KS5jb25zdHJ1Y3RvcjtcbiAgICAgIC8qIE1PREVSTi1PTkxZOkVORCAqL1xuICAgICAgLy8gRm9yIHRoZSBjYXNlcyB3aGVuIHVzZXJzIHBhc3Mgb25seSBhIGZ1bmN0aW9uIHJlZmVyZW5jZSB0byB0aGUgY2FsbGVyOiBgeC1vbjpjbGljaz1cImZvb1wiYFxuICAgICAgLy8gV2hlcmUgXCJmb29cIiBpcyBhIGZ1bmN0aW9uLiBBbHNvLCB3ZSdsbCBwYXNzIHRoZSBmdW5jdGlvbiB0aGUgZXZlbnQgaW5zdGFuY2Ugd2hlbiB3ZSBjYWxsIGl0LlxuXG4gICAgICBpZiAoT2JqZWN0LmtleXMoZGF0YUNvbnRleHQpLmluY2x1ZGVzKGV4cHJlc3Npb24pKSB7XG4gICAgICAgIGxldCBtZXRob2RSZWZlcmVuY2UgPSBuZXcgRnVuY3Rpb24oWydkYXRhQ29udGV4dCcsIC4uLk9iamVjdC5rZXlzKGFkZGl0aW9uYWxIZWxwZXJWYXJpYWJsZXMpXSwgYHdpdGgoZGF0YUNvbnRleHQpIHsgcmV0dXJuICR7ZXhwcmVzc2lvbn0gfWApKGRhdGFDb250ZXh0LCAuLi5PYmplY3QudmFsdWVzKGFkZGl0aW9uYWxIZWxwZXJWYXJpYWJsZXMpKTtcblxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZFJlZmVyZW5jZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWV0aG9kUmVmZXJlbmNlLmNhbGwoZGF0YUNvbnRleHQsIGFkZGl0aW9uYWxIZWxwZXJWYXJpYWJsZXNbJyRldmVudCddKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEFzeW5jRnVuY3Rpb24oWydkYXRhQ29udGV4dCcsIC4uLk9iamVjdC5rZXlzKGFkZGl0aW9uYWxIZWxwZXJWYXJpYWJsZXMpXSwgYHdpdGgoZGF0YUNvbnRleHQpIHsgJHtleHByZXNzaW9ufSB9YCkoZGF0YUNvbnRleHQsIC4uLk9iamVjdC52YWx1ZXMoYWRkaXRpb25hbEhlbHBlclZhcmlhYmxlcykpKTtcbiAgICB9LCB7XG4gICAgICBlbCxcbiAgICAgIGV4cHJlc3Npb25cbiAgICB9KTtcbiAgfVxuICBjb25zdCB4QXR0clJFID0gL154LShvbnxiaW5kfGRhdGF8dGV4dHxodG1sfG1vZGVsfGlmfGZvcnxzaG93fGNsb2FrfHRyYW5zaXRpb258cmVmfHNwcmVhZClcXGIvO1xuICBmdW5jdGlvbiBpc1hBdHRyKGF0dHIpIHtcbiAgICBjb25zdCBuYW1lID0gcmVwbGFjZUF0QW5kQ29sb25XaXRoU3RhbmRhcmRTeW50YXgoYXR0ci5uYW1lKTtcbiAgICByZXR1cm4geEF0dHJSRS50ZXN0KG5hbWUpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFhBdHRycyhlbCwgY29tcG9uZW50LCB0eXBlKSB7XG4gICAgbGV0IGRpcmVjdGl2ZXMgPSBBcnJheS5mcm9tKGVsLmF0dHJpYnV0ZXMpLmZpbHRlcihpc1hBdHRyKS5tYXAocGFyc2VIdG1sQXR0cmlidXRlKTsgLy8gR2V0IGFuIG9iamVjdCBvZiBkaXJlY3RpdmVzIGZyb20geC1zcHJlYWQuXG5cbiAgICBsZXQgc3ByZWFkRGlyZWN0aXZlID0gZGlyZWN0aXZlcy5maWx0ZXIoZGlyZWN0aXZlID0+IGRpcmVjdGl2ZS50eXBlID09PSAnc3ByZWFkJylbMF07XG5cbiAgICBpZiAoc3ByZWFkRGlyZWN0aXZlKSB7XG4gICAgICBsZXQgc3ByZWFkT2JqZWN0ID0gc2FmZXJFdmFsKGVsLCBzcHJlYWREaXJlY3RpdmUuZXhwcmVzc2lvbiwgY29tcG9uZW50LiRkYXRhKTsgLy8gQWRkIHgtc3ByZWFkIGRpcmVjdGl2ZXMgdG8gdGhlIHBpbGUgb2YgZXhpc3RpbmcgZGlyZWN0aXZlcy5cblxuICAgICAgZGlyZWN0aXZlcyA9IGRpcmVjdGl2ZXMuY29uY2F0KE9iamVjdC5lbnRyaWVzKHNwcmVhZE9iamVjdCkubWFwKChbbmFtZSwgdmFsdWVdKSA9PiBwYXJzZUh0bWxBdHRyaWJ1dGUoe1xuICAgICAgICBuYW1lLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSkpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSkgcmV0dXJuIGRpcmVjdGl2ZXMuZmlsdGVyKGkgPT4gaS50eXBlID09PSB0eXBlKTtcbiAgICByZXR1cm4gc29ydERpcmVjdGl2ZXMoZGlyZWN0aXZlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBzb3J0RGlyZWN0aXZlcyhkaXJlY3RpdmVzKSB7XG4gICAgbGV0IGRpcmVjdGl2ZU9yZGVyID0gWydiaW5kJywgJ21vZGVsJywgJ3Nob3cnLCAnY2F0Y2gtYWxsJ107XG4gICAgcmV0dXJuIGRpcmVjdGl2ZXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgbGV0IHR5cGVBID0gZGlyZWN0aXZlT3JkZXIuaW5kZXhPZihhLnR5cGUpID09PSAtMSA/ICdjYXRjaC1hbGwnIDogYS50eXBlO1xuICAgICAgbGV0IHR5cGVCID0gZGlyZWN0aXZlT3JkZXIuaW5kZXhPZihiLnR5cGUpID09PSAtMSA/ICdjYXRjaC1hbGwnIDogYi50eXBlO1xuICAgICAgcmV0dXJuIGRpcmVjdGl2ZU9yZGVyLmluZGV4T2YodHlwZUEpIC0gZGlyZWN0aXZlT3JkZXIuaW5kZXhPZih0eXBlQik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUh0bWxBdHRyaWJ1dGUoe1xuICAgIG5hbWUsXG4gICAgdmFsdWVcbiAgfSkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWROYW1lID0gcmVwbGFjZUF0QW5kQ29sb25XaXRoU3RhbmRhcmRTeW50YXgobmFtZSk7XG4gICAgY29uc3QgdHlwZU1hdGNoID0gbm9ybWFsaXplZE5hbWUubWF0Y2goeEF0dHJSRSk7XG4gICAgY29uc3QgdmFsdWVNYXRjaCA9IG5vcm1hbGl6ZWROYW1lLm1hdGNoKC86KFthLXpBLVowLTlcXC06XSspLyk7XG4gICAgY29uc3QgbW9kaWZpZXJzID0gbm9ybWFsaXplZE5hbWUubWF0Y2goL1xcLlteLlxcXV0rKD89W15cXF1dKiQpL2cpIHx8IFtdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0eXBlTWF0Y2ggPyB0eXBlTWF0Y2hbMV0gOiBudWxsLFxuICAgICAgdmFsdWU6IHZhbHVlTWF0Y2ggPyB2YWx1ZU1hdGNoWzFdIDogbnVsbCxcbiAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzLm1hcChpID0+IGkucmVwbGFjZSgnLicsICcnKSksXG4gICAgICBleHByZXNzaW9uOiB2YWx1ZVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gaXNCb29sZWFuQXR0cihhdHRyTmFtZSkge1xuICAgIC8vIEFzIHBlciBIVE1MIHNwZWMgdGFibGUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2F0dHJpYnV0ZXMtMzpib29sZWFuLWF0dHJpYnV0ZVxuICAgIC8vIEFycmF5IHJvdWdobHkgb3JkZXJlZCBieSBlc3RpbWF0ZWQgdXNhZ2VcbiAgICBjb25zdCBib29sZWFuQXR0cmlidXRlcyA9IFsnZGlzYWJsZWQnLCAnY2hlY2tlZCcsICdyZXF1aXJlZCcsICdyZWFkb25seScsICdoaWRkZW4nLCAnb3BlbicsICdzZWxlY3RlZCcsICdhdXRvZm9jdXMnLCAnaXRlbXNjb3BlJywgJ211bHRpcGxlJywgJ25vdmFsaWRhdGUnLCAnYWxsb3dmdWxsc2NyZWVuJywgJ2FsbG93cGF5bWVudHJlcXVlc3QnLCAnZm9ybW5vdmFsaWRhdGUnLCAnYXV0b3BsYXknLCAnY29udHJvbHMnLCAnbG9vcCcsICdtdXRlZCcsICdwbGF5c2lubGluZScsICdkZWZhdWx0JywgJ2lzbWFwJywgJ3JldmVyc2VkJywgJ2FzeW5jJywgJ2RlZmVyJywgJ25vbW9kdWxlJ107XG4gICAgcmV0dXJuIGJvb2xlYW5BdHRyaWJ1dGVzLmluY2x1ZGVzKGF0dHJOYW1lKTtcbiAgfVxuICBmdW5jdGlvbiByZXBsYWNlQXRBbmRDb2xvbldpdGhTdGFuZGFyZFN5bnRheChuYW1lKSB7XG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnQCcpKSB7XG4gICAgICByZXR1cm4gbmFtZS5yZXBsYWNlKCdAJywgJ3gtb246Jyk7XG4gICAgfSBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoJzonKSkge1xuICAgICAgcmV0dXJuIG5hbWUucmVwbGFjZSgnOicsICd4LWJpbmQ6Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgZnVuY3Rpb24gY29udmVydENsYXNzU3RyaW5nVG9BcnJheShjbGFzc0xpc3QsIGZpbHRlckZuID0gQm9vbGVhbikge1xuICAgIHJldHVybiBjbGFzc0xpc3Quc3BsaXQoJyAnKS5maWx0ZXIoZmlsdGVyRm4pO1xuICB9XG4gIGNvbnN0IFRSQU5TSVRJT05fVFlQRV9JTiA9ICdpbic7XG4gIGNvbnN0IFRSQU5TSVRJT05fVFlQRV9PVVQgPSAnb3V0JztcbiAgY29uc3QgVFJBTlNJVElPTl9DQU5DRUxMRUQgPSAnY2FuY2VsbGVkJztcbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkluKGVsLCBzaG93LCByZWplY3QsIGNvbXBvbmVudCwgZm9yY2VTa2lwID0gZmFsc2UpIHtcbiAgICAvLyBXZSBkb24ndCB3YW50IHRvIHRyYW5zaXRpb24gb24gdGhlIGluaXRpYWwgcGFnZSBsb2FkLlxuICAgIGlmIChmb3JjZVNraXApIHJldHVybiBzaG93KCk7XG5cbiAgICBpZiAoZWwuX194X3RyYW5zaXRpb24gJiYgZWwuX194X3RyYW5zaXRpb24udHlwZSA9PT0gVFJBTlNJVElPTl9UWVBFX0lOKSB7XG4gICAgICAvLyB0aGVyZSBpcyBhbHJlYWR5IGEgc2ltaWxhciB0cmFuc2l0aW9uIGdvaW5nIG9uLCB0aGlzIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgYnlcbiAgICAgIC8vIGEgY2hhbmdlIGluIGEgZGlmZmVyZW50IHByb3BlcnR5LCBsZXQncyBqdXN0IGxlYXZlIHRoZSBwcmV2aW91cyBvbmUgZG9pbmcgaXRzIGpvYlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGF0dHJzID0gZ2V0WEF0dHJzKGVsLCBjb21wb25lbnQsICd0cmFuc2l0aW9uJyk7XG4gICAgY29uc3Qgc2hvd0F0dHIgPSBnZXRYQXR0cnMoZWwsIGNvbXBvbmVudCwgJ3Nob3cnKVswXTsgLy8gSWYgdGhpcyBpcyB0cmlnZ2VyZWQgYnkgYSB4LXNob3cudHJhbnNpdGlvbi5cblxuICAgIGlmIChzaG93QXR0ciAmJiBzaG93QXR0ci5tb2RpZmllcnMuaW5jbHVkZXMoJ3RyYW5zaXRpb24nKSkge1xuICAgICAgbGV0IG1vZGlmaWVycyA9IHNob3dBdHRyLm1vZGlmaWVyczsgLy8gSWYgeC1zaG93LnRyYW5zaXRpb24ub3V0LCB3ZSdsbCBza2lwIHRoZSBcImluXCIgdHJhbnNpdGlvbi5cblxuICAgICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygnb3V0JykgJiYgIW1vZGlmaWVycy5pbmNsdWRlcygnaW4nKSkgcmV0dXJuIHNob3coKTtcbiAgICAgIGNvbnN0IHNldHRpbmdCb3RoU2lkZXNPZlRyYW5zaXRpb24gPSBtb2RpZmllcnMuaW5jbHVkZXMoJ2luJykgJiYgbW9kaWZpZXJzLmluY2x1ZGVzKCdvdXQnKTsgLy8gSWYgeC1zaG93LnRyYW5zaXRpb24uaW4uLi5vdXQuLi4gb25seSB1c2UgXCJpblwiIHJlbGF0ZWQgbW9kaWZpZXJzIGZvciB0aGlzIHRyYW5zaXRpb24uXG5cbiAgICAgIG1vZGlmaWVycyA9IHNldHRpbmdCb3RoU2lkZXNPZlRyYW5zaXRpb24gPyBtb2RpZmllcnMuZmlsdGVyKChpLCBpbmRleCkgPT4gaW5kZXggPCBtb2RpZmllcnMuaW5kZXhPZignb3V0JykpIDogbW9kaWZpZXJzO1xuICAgICAgdHJhbnNpdGlvbkhlbHBlckluKGVsLCBtb2RpZmllcnMsIHNob3csIHJlamVjdCk7IC8vIE90aGVyd2lzZSwgd2UgY2FuIGFzc3VtZSB4LXRyYW5zaXRpb246ZW50ZXIuXG4gICAgfSBlbHNlIGlmIChhdHRycy5zb21lKGF0dHIgPT4gWydlbnRlcicsICdlbnRlci1zdGFydCcsICdlbnRlci1lbmQnXS5pbmNsdWRlcyhhdHRyLnZhbHVlKSkpIHtcbiAgICAgIHRyYW5zaXRpb25DbGFzc2VzSW4oZWwsIGNvbXBvbmVudCwgYXR0cnMsIHNob3csIHJlamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5laXRoZXIsIGp1c3Qgc2hvdyB0aGF0IGRhbW4gdGhpbmcuXG4gICAgICBzaG93KCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyYW5zaXRpb25PdXQoZWwsIGhpZGUsIHJlamVjdCwgY29tcG9uZW50LCBmb3JjZVNraXAgPSBmYWxzZSkge1xuICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gdHJhbnNpdGlvbiBvbiB0aGUgaW5pdGlhbCBwYWdlIGxvYWQuXG4gICAgaWYgKGZvcmNlU2tpcCkgcmV0dXJuIGhpZGUoKTtcblxuICAgIGlmIChlbC5fX3hfdHJhbnNpdGlvbiAmJiBlbC5fX3hfdHJhbnNpdGlvbi50eXBlID09PSBUUkFOU0lUSU9OX1RZUEVfT1VUKSB7XG4gICAgICAvLyB0aGVyZSBpcyBhbHJlYWR5IGEgc2ltaWxhciB0cmFuc2l0aW9uIGdvaW5nIG9uLCB0aGlzIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgYnlcbiAgICAgIC8vIGEgY2hhbmdlIGluIGEgZGlmZmVyZW50IHByb3BlcnR5LCBsZXQncyBqdXN0IGxlYXZlIHRoZSBwcmV2aW91cyBvbmUgZG9pbmcgaXRzIGpvYlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGF0dHJzID0gZ2V0WEF0dHJzKGVsLCBjb21wb25lbnQsICd0cmFuc2l0aW9uJyk7XG4gICAgY29uc3Qgc2hvd0F0dHIgPSBnZXRYQXR0cnMoZWwsIGNvbXBvbmVudCwgJ3Nob3cnKVswXTtcblxuICAgIGlmIChzaG93QXR0ciAmJiBzaG93QXR0ci5tb2RpZmllcnMuaW5jbHVkZXMoJ3RyYW5zaXRpb24nKSkge1xuICAgICAgbGV0IG1vZGlmaWVycyA9IHNob3dBdHRyLm1vZGlmaWVycztcbiAgICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ2luJykgJiYgIW1vZGlmaWVycy5pbmNsdWRlcygnb3V0JykpIHJldHVybiBoaWRlKCk7XG4gICAgICBjb25zdCBzZXR0aW5nQm90aFNpZGVzT2ZUcmFuc2l0aW9uID0gbW9kaWZpZXJzLmluY2x1ZGVzKCdpbicpICYmIG1vZGlmaWVycy5pbmNsdWRlcygnb3V0Jyk7XG4gICAgICBtb2RpZmllcnMgPSBzZXR0aW5nQm90aFNpZGVzT2ZUcmFuc2l0aW9uID8gbW9kaWZpZXJzLmZpbHRlcigoaSwgaW5kZXgpID0+IGluZGV4ID4gbW9kaWZpZXJzLmluZGV4T2YoJ291dCcpKSA6IG1vZGlmaWVycztcbiAgICAgIHRyYW5zaXRpb25IZWxwZXJPdXQoZWwsIG1vZGlmaWVycywgc2V0dGluZ0JvdGhTaWRlc09mVHJhbnNpdGlvbiwgaGlkZSwgcmVqZWN0KTtcbiAgICB9IGVsc2UgaWYgKGF0dHJzLnNvbWUoYXR0ciA9PiBbJ2xlYXZlJywgJ2xlYXZlLXN0YXJ0JywgJ2xlYXZlLWVuZCddLmluY2x1ZGVzKGF0dHIudmFsdWUpKSkge1xuICAgICAgdHJhbnNpdGlvbkNsYXNzZXNPdXQoZWwsIGNvbXBvbmVudCwgYXR0cnMsIGhpZGUsIHJlamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZGUoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkhlbHBlckluKGVsLCBtb2RpZmllcnMsIHNob3dDYWxsYmFjaywgcmVqZWN0KSB7XG4gICAgLy8gRGVmYXVsdCB2YWx1ZXMgaW5zcGlyZWQgYnk6IGh0dHBzOi8vbWF0ZXJpYWwuaW8vZGVzaWduL21vdGlvbi9zcGVlZC5odG1sI2R1cmF0aW9uXG4gICAgY29uc3Qgc3R5bGVWYWx1ZXMgPSB7XG4gICAgICBkdXJhdGlvbjogbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsICdkdXJhdGlvbicsIDE1MCksXG4gICAgICBvcmlnaW46IG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCAnb3JpZ2luJywgJ2NlbnRlcicpLFxuICAgICAgZmlyc3Q6IHtcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgc2NhbGU6IG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCAnc2NhbGUnLCA5NSlcbiAgICAgIH0sXG4gICAgICBzZWNvbmQ6IHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgc2NhbGU6IDEwMFxuICAgICAgfVxuICAgIH07XG4gICAgdHJhbnNpdGlvbkhlbHBlcihlbCwgbW9kaWZpZXJzLCBzaG93Q2FsbGJhY2ssICgpID0+IHt9LCByZWplY3QsIHN0eWxlVmFsdWVzLCBUUkFOU0lUSU9OX1RZUEVfSU4pO1xuICB9XG4gIGZ1bmN0aW9uIHRyYW5zaXRpb25IZWxwZXJPdXQoZWwsIG1vZGlmaWVycywgc2V0dGluZ0JvdGhTaWRlc09mVHJhbnNpdGlvbiwgaGlkZUNhbGxiYWNrLCByZWplY3QpIHtcbiAgICAvLyBNYWtlIHRoZSBcIm91dFwiIHRyYW5zaXRpb24gLjV4IHNsb3dlciB0aGFuIHRoZSBcImluXCIuIChWaXN1YWxseSBiZXR0ZXIpXG4gICAgLy8gSE9XRVZFUiwgaWYgdGhleSBleHBsaWNpdGx5IHNldCBhIGR1cmF0aW9uIGZvciB0aGUgXCJvdXRcIiB0cmFuc2l0aW9uLFxuICAgIC8vIHVzZSB0aGF0LlxuICAgIGNvbnN0IGR1cmF0aW9uID0gc2V0dGluZ0JvdGhTaWRlc09mVHJhbnNpdGlvbiA/IG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCAnZHVyYXRpb24nLCAxNTApIDogbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsICdkdXJhdGlvbicsIDE1MCkgLyAyO1xuICAgIGNvbnN0IHN0eWxlVmFsdWVzID0ge1xuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgb3JpZ2luOiBtb2RpZmllclZhbHVlKG1vZGlmaWVycywgJ29yaWdpbicsICdjZW50ZXInKSxcbiAgICAgIGZpcnN0OiB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHNjYWxlOiAxMDBcbiAgICAgIH0sXG4gICAgICBzZWNvbmQ6IHtcbiAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgc2NhbGU6IG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCAnc2NhbGUnLCA5NSlcbiAgICAgIH1cbiAgICB9O1xuICAgIHRyYW5zaXRpb25IZWxwZXIoZWwsIG1vZGlmaWVycywgKCkgPT4ge30sIGhpZGVDYWxsYmFjaywgcmVqZWN0LCBzdHlsZVZhbHVlcywgVFJBTlNJVElPTl9UWVBFX09VVCk7XG4gIH1cblxuICBmdW5jdGlvbiBtb2RpZmllclZhbHVlKG1vZGlmaWVycywga2V5LCBmYWxsYmFjaykge1xuICAgIC8vIElmIHRoZSBtb2RpZmllciBpc24ndCBwcmVzZW50LCB1c2UgdGhlIGRlZmF1bHQuXG4gICAgaWYgKG1vZGlmaWVycy5pbmRleE9mKGtleSkgPT09IC0xKSByZXR1cm4gZmFsbGJhY2s7IC8vIElmIGl0IElTIHByZXNlbnQsIGdyYWIgdGhlIHZhbHVlIGFmdGVyIGl0OiB4LXNob3cudHJhbnNpdGlvbi5kdXJhdGlvbi41MDBtc1xuXG4gICAgY29uc3QgcmF3VmFsdWUgPSBtb2RpZmllcnNbbW9kaWZpZXJzLmluZGV4T2Yoa2V5KSArIDFdO1xuICAgIGlmICghcmF3VmFsdWUpIHJldHVybiBmYWxsYmFjaztcblxuICAgIGlmIChrZXkgPT09ICdzY2FsZScpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSB2ZXJ5IG5leHQgdmFsdWUgaXMgTk9UIGEgbnVtYmVyIGFuZCByZXR1cm4gdGhlIGZhbGxiYWNrLlxuICAgICAgLy8gSWYgeC1zaG93LnRyYW5zaXRpb24uc2NhbGUsIHdlJ2xsIHVzZSB0aGUgZGVmYXVsdCBzY2FsZSB2YWx1ZS5cbiAgICAgIC8vIFRoYXQgaXMgaG93IGEgdXNlciBvcHRzIG91dCBvZiB0aGUgb3BhY2l0eSB0cmFuc2l0aW9uLlxuICAgICAgaWYgKCFpc051bWVyaWMocmF3VmFsdWUpKSByZXR1cm4gZmFsbGJhY2s7XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ2R1cmF0aW9uJykge1xuICAgICAgLy8gU3VwcG9ydCB4LXNob3cudHJhbnNpdGlvbi5kdXJhdGlvbi41MDBtcyAmJiBkdXJhdGlvbi41MDBcbiAgICAgIGxldCBtYXRjaCA9IHJhd1ZhbHVlLm1hdGNoKC8oWzAtOV0rKW1zLyk7XG4gICAgICBpZiAobWF0Y2gpIHJldHVybiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnb3JpZ2luJykge1xuICAgICAgLy8gU3VwcG9ydCBjaGFpbmluZyBvcmlnaW4gZGlyZWN0aW9uczogeC1zaG93LnRyYW5zaXRpb24udG9wLnJpZ2h0XG4gICAgICBpZiAoWyd0b3AnLCAncmlnaHQnLCAnbGVmdCcsICdjZW50ZXInLCAnYm90dG9tJ10uaW5jbHVkZXMobW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKGtleSkgKyAyXSkpIHtcbiAgICAgICAgcmV0dXJuIFtyYXdWYWx1ZSwgbW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKGtleSkgKyAyXV0uam9pbignICcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdWYWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zaXRpb25IZWxwZXIoZWwsIG1vZGlmaWVycywgaG9vazEsIGhvb2syLCByZWplY3QsIHN0eWxlVmFsdWVzLCB0eXBlKSB7XG4gICAgLy8gY2xlYXIgdGhlIHByZXZpb3VzIHRyYW5zaXRpb24gaWYgZXhpc3RzIHRvIGF2b2lkIGNhY2hpbmcgdGhlIHdyb25nIHN0eWxlc1xuICAgIGlmIChlbC5fX3hfdHJhbnNpdGlvbikge1xuICAgICAgZWwuX194X3RyYW5zaXRpb24uY2FuY2VsICYmIGVsLl9feF90cmFuc2l0aW9uLmNhbmNlbCgpO1xuICAgIH0gLy8gSWYgdGhlIHVzZXIgc2V0IHRoZXNlIHN0eWxlIHZhbHVlcywgd2UnbGwgcHV0IHRoZW0gYmFjayB3aGVuIHdlJ3JlIGRvbmUgd2l0aCB0aGVtLlxuXG5cbiAgICBjb25zdCBvcGFjaXR5Q2FjaGUgPSBlbC5zdHlsZS5vcGFjaXR5O1xuICAgIGNvbnN0IHRyYW5zZm9ybUNhY2hlID0gZWwuc3R5bGUudHJhbnNmb3JtO1xuICAgIGNvbnN0IHRyYW5zZm9ybU9yaWdpbkNhY2hlID0gZWwuc3R5bGUudHJhbnNmb3JtT3JpZ2luOyAvLyBJZiBubyBtb2RpZmllcnMgYXJlIHByZXNlbnQ6IHgtc2hvdy50cmFuc2l0aW9uLCB3ZSdsbCBkZWZhdWx0IHRvIGJvdGggb3BhY2l0eSBhbmQgc2NhbGUuXG5cbiAgICBjb25zdCBub01vZGlmaWVycyA9ICFtb2RpZmllcnMuaW5jbHVkZXMoJ29wYWNpdHknKSAmJiAhbW9kaWZpZXJzLmluY2x1ZGVzKCdzY2FsZScpO1xuICAgIGNvbnN0IHRyYW5zaXRpb25PcGFjaXR5ID0gbm9Nb2RpZmllcnMgfHwgbW9kaWZpZXJzLmluY2x1ZGVzKCdvcGFjaXR5Jyk7XG4gICAgY29uc3QgdHJhbnNpdGlvblNjYWxlID0gbm9Nb2RpZmllcnMgfHwgbW9kaWZpZXJzLmluY2x1ZGVzKCdzY2FsZScpOyAvLyBUaGVzZSBhcmUgdGhlIGV4cGxpY2l0IHN0YWdlcyBvZiBhIHRyYW5zaXRpb24gKHNhbWUgc3RhZ2VzIGZvciBpbiBhbmQgZm9yIG91dCkuXG4gICAgLy8gVGhpcyB3YXkgeW91IGNhbiBnZXQgYSBiaXJkcyBleWUgdmlldyBvZiB0aGUgaG9va3MsIGFuZCB0aGUgZGlmZmVyZW5jZXNcbiAgICAvLyBiZXR3ZWVuIHRoZW0uXG5cbiAgICBjb25zdCBzdGFnZXMgPSB7XG4gICAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRyYW5zaXRpb25PcGFjaXR5KSBlbC5zdHlsZS5vcGFjaXR5ID0gc3R5bGVWYWx1ZXMuZmlyc3Qub3BhY2l0eTtcbiAgICAgICAgaWYgKHRyYW5zaXRpb25TY2FsZSkgZWwuc3R5bGUudHJhbnNmb3JtID0gYHNjYWxlKCR7c3R5bGVWYWx1ZXMuZmlyc3Quc2NhbGUgLyAxMDB9KWA7XG4gICAgICB9LFxuXG4gICAgICBkdXJpbmcoKSB7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uU2NhbGUpIGVsLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IHN0eWxlVmFsdWVzLm9yaWdpbjtcbiAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gW3RyYW5zaXRpb25PcGFjaXR5ID8gYG9wYWNpdHlgIDogYGAsIHRyYW5zaXRpb25TY2FsZSA/IGB0cmFuc2Zvcm1gIDogYGBdLmpvaW4oJyAnKS50cmltKCk7XG4gICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGAke3N0eWxlVmFsdWVzLmR1cmF0aW9uIC8gMTAwMH1zYDtcbiAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uID0gYGN1YmljLWJlemllcigwLjQsIDAuMCwgMC4yLCAxKWA7XG4gICAgICB9LFxuXG4gICAgICBzaG93KCkge1xuICAgICAgICBob29rMSgpO1xuICAgICAgfSxcblxuICAgICAgZW5kKCkge1xuICAgICAgICBpZiAodHJhbnNpdGlvbk9wYWNpdHkpIGVsLnN0eWxlLm9wYWNpdHkgPSBzdHlsZVZhbHVlcy5zZWNvbmQub3BhY2l0eTtcbiAgICAgICAgaWYgKHRyYW5zaXRpb25TY2FsZSkgZWwuc3R5bGUudHJhbnNmb3JtID0gYHNjYWxlKCR7c3R5bGVWYWx1ZXMuc2Vjb25kLnNjYWxlIC8gMTAwfSlgO1xuICAgICAgfSxcblxuICAgICAgaGlkZSgpIHtcbiAgICAgICAgaG9vazIoKTtcbiAgICAgIH0sXG5cbiAgICAgIGNsZWFudXAoKSB7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uT3BhY2l0eSkgZWwuc3R5bGUub3BhY2l0eSA9IG9wYWNpdHlDYWNoZTtcbiAgICAgICAgaWYgKHRyYW5zaXRpb25TY2FsZSkgZWwuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtQ2FjaGU7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uU2NhbGUpIGVsLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IHRyYW5zZm9ybU9yaWdpbkNhY2hlO1xuICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSBudWxsO1xuICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBudWxsO1xuICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24gPSBudWxsO1xuICAgICAgfVxuXG4gICAgfTtcbiAgICB0cmFuc2l0aW9uKGVsLCBzdGFnZXMsIHR5cGUsIHJlamVjdCk7XG4gIH1cblxuICBjb25zdCBlbnN1cmVTdHJpbmdFeHByZXNzaW9uID0gKGV4cHJlc3Npb24sIGVsLCBjb21wb25lbnQpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIGV4cHJlc3Npb24gPT09ICdmdW5jdGlvbicgPyBjb21wb25lbnQuZXZhbHVhdGVSZXR1cm5FeHByZXNzaW9uKGVsLCBleHByZXNzaW9uKSA6IGV4cHJlc3Npb247XG4gIH07XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkNsYXNzZXNJbihlbCwgY29tcG9uZW50LCBkaXJlY3RpdmVzLCBzaG93Q2FsbGJhY2ssIHJlamVjdCkge1xuICAgIGNvbnN0IGVudGVyID0gY29udmVydENsYXNzU3RyaW5nVG9BcnJheShlbnN1cmVTdHJpbmdFeHByZXNzaW9uKChkaXJlY3RpdmVzLmZpbmQoaSA9PiBpLnZhbHVlID09PSAnZW50ZXInKSB8fCB7XG4gICAgICBleHByZXNzaW9uOiAnJ1xuICAgIH0pLmV4cHJlc3Npb24sIGVsLCBjb21wb25lbnQpKTtcbiAgICBjb25zdCBlbnRlclN0YXJ0ID0gY29udmVydENsYXNzU3RyaW5nVG9BcnJheShlbnN1cmVTdHJpbmdFeHByZXNzaW9uKChkaXJlY3RpdmVzLmZpbmQoaSA9PiBpLnZhbHVlID09PSAnZW50ZXItc3RhcnQnKSB8fCB7XG4gICAgICBleHByZXNzaW9uOiAnJ1xuICAgIH0pLmV4cHJlc3Npb24sIGVsLCBjb21wb25lbnQpKTtcbiAgICBjb25zdCBlbnRlckVuZCA9IGNvbnZlcnRDbGFzc1N0cmluZ1RvQXJyYXkoZW5zdXJlU3RyaW5nRXhwcmVzc2lvbigoZGlyZWN0aXZlcy5maW5kKGkgPT4gaS52YWx1ZSA9PT0gJ2VudGVyLWVuZCcpIHx8IHtcbiAgICAgIGV4cHJlc3Npb246ICcnXG4gICAgfSkuZXhwcmVzc2lvbiwgZWwsIGNvbXBvbmVudCkpO1xuICAgIHRyYW5zaXRpb25DbGFzc2VzKGVsLCBlbnRlciwgZW50ZXJTdGFydCwgZW50ZXJFbmQsIHNob3dDYWxsYmFjaywgKCkgPT4ge30sIFRSQU5TSVRJT05fVFlQRV9JTiwgcmVqZWN0KTtcbiAgfVxuICBmdW5jdGlvbiB0cmFuc2l0aW9uQ2xhc3Nlc091dChlbCwgY29tcG9uZW50LCBkaXJlY3RpdmVzLCBoaWRlQ2FsbGJhY2ssIHJlamVjdCkge1xuICAgIGNvbnN0IGxlYXZlID0gY29udmVydENsYXNzU3RyaW5nVG9BcnJheShlbnN1cmVTdHJpbmdFeHByZXNzaW9uKChkaXJlY3RpdmVzLmZpbmQoaSA9PiBpLnZhbHVlID09PSAnbGVhdmUnKSB8fCB7XG4gICAgICBleHByZXNzaW9uOiAnJ1xuICAgIH0pLmV4cHJlc3Npb24sIGVsLCBjb21wb25lbnQpKTtcbiAgICBjb25zdCBsZWF2ZVN0YXJ0ID0gY29udmVydENsYXNzU3RyaW5nVG9BcnJheShlbnN1cmVTdHJpbmdFeHByZXNzaW9uKChkaXJlY3RpdmVzLmZpbmQoaSA9PiBpLnZhbHVlID09PSAnbGVhdmUtc3RhcnQnKSB8fCB7XG4gICAgICBleHByZXNzaW9uOiAnJ1xuICAgIH0pLmV4cHJlc3Npb24sIGVsLCBjb21wb25lbnQpKTtcbiAgICBjb25zdCBsZWF2ZUVuZCA9IGNvbnZlcnRDbGFzc1N0cmluZ1RvQXJyYXkoZW5zdXJlU3RyaW5nRXhwcmVzc2lvbigoZGlyZWN0aXZlcy5maW5kKGkgPT4gaS52YWx1ZSA9PT0gJ2xlYXZlLWVuZCcpIHx8IHtcbiAgICAgIGV4cHJlc3Npb246ICcnXG4gICAgfSkuZXhwcmVzc2lvbiwgZWwsIGNvbXBvbmVudCkpO1xuICAgIHRyYW5zaXRpb25DbGFzc2VzKGVsLCBsZWF2ZSwgbGVhdmVTdGFydCwgbGVhdmVFbmQsICgpID0+IHt9LCBoaWRlQ2FsbGJhY2ssIFRSQU5TSVRJT05fVFlQRV9PVVQsIHJlamVjdCk7XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkNsYXNzZXMoZWwsIGNsYXNzZXNEdXJpbmcsIGNsYXNzZXNTdGFydCwgY2xhc3Nlc0VuZCwgaG9vazEsIGhvb2syLCB0eXBlLCByZWplY3QpIHtcbiAgICAvLyBjbGVhciB0aGUgcHJldmlvdXMgdHJhbnNpdGlvbiBpZiBleGlzdHMgdG8gYXZvaWQgY2FjaGluZyB0aGUgd3JvbmcgY2xhc3Nlc1xuICAgIGlmIChlbC5fX3hfdHJhbnNpdGlvbikge1xuICAgICAgZWwuX194X3RyYW5zaXRpb24uY2FuY2VsICYmIGVsLl9feF90cmFuc2l0aW9uLmNhbmNlbCgpO1xuICAgIH1cblxuICAgIGNvbnN0IG9yaWdpbmFsQ2xhc3NlcyA9IGVsLl9feF9vcmlnaW5hbF9jbGFzc2VzIHx8IFtdO1xuICAgIGNvbnN0IHN0YWdlcyA9IHtcbiAgICAgIHN0YXJ0KCkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXNTdGFydCk7XG4gICAgICB9LFxuXG4gICAgICBkdXJpbmcoKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3Nlc0R1cmluZyk7XG4gICAgICB9LFxuXG4gICAgICBzaG93KCkge1xuICAgICAgICBob29rMSgpO1xuICAgICAgfSxcblxuICAgICAgZW5kKCkge1xuICAgICAgICAvLyBEb24ndCByZW1vdmUgY2xhc3NlcyB0aGF0IHdlcmUgaW4gdGhlIG9yaWdpbmFsIGNsYXNzIGF0dHJpYnV0ZS5cbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzU3RhcnQuZmlsdGVyKGkgPT4gIW9yaWdpbmFsQ2xhc3Nlcy5pbmNsdWRlcyhpKSkpO1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXNFbmQpO1xuICAgICAgfSxcblxuICAgICAgaGlkZSgpIHtcbiAgICAgICAgaG9vazIoKTtcbiAgICAgIH0sXG5cbiAgICAgIGNsZWFudXAoKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3Nlc0R1cmluZy5maWx0ZXIoaSA9PiAhb3JpZ2luYWxDbGFzc2VzLmluY2x1ZGVzKGkpKSk7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3Nlc0VuZC5maWx0ZXIoaSA9PiAhb3JpZ2luYWxDbGFzc2VzLmluY2x1ZGVzKGkpKSk7XG4gICAgICB9XG5cbiAgICB9O1xuICAgIHRyYW5zaXRpb24oZWwsIHN0YWdlcywgdHlwZSwgcmVqZWN0KTtcbiAgfVxuICBmdW5jdGlvbiB0cmFuc2l0aW9uKGVsLCBzdGFnZXMsIHR5cGUsIHJlamVjdCkge1xuICAgIGNvbnN0IGZpbmlzaCA9IG9uY2UoKCkgPT4ge1xuICAgICAgc3RhZ2VzLmhpZGUoKTsgLy8gQWRkaW5nIGFuIFwiaXNDb25uZWN0ZWRcIiBjaGVjaywgaW4gY2FzZSB0aGUgY2FsbGJhY2tcbiAgICAgIC8vIHJlbW92ZWQgdGhlIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxuXG4gICAgICBpZiAoZWwuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgc3RhZ2VzLmNsZWFudXAoKTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGVsLl9feF90cmFuc2l0aW9uO1xuICAgIH0pO1xuICAgIGVsLl9feF90cmFuc2l0aW9uID0ge1xuICAgICAgLy8gU2V0IHRyYW5zaXRpb24gdHlwZSBzbyB3ZSBjYW4gYXZvaWQgY2xlYXJpbmcgdHJhbnNpdGlvbiBpZiB0aGUgZGlyZWN0aW9uIGlzIHRoZSBzYW1lXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgLy8gY3JlYXRlIGEgY2FsbGJhY2sgZm9yIHRoZSBsYXN0IHN0YWdlcyBvZiB0aGUgdHJhbnNpdGlvbiBzbyB3ZSBjYW4gY2FsbCBpdFxuICAgICAgLy8gZnJvbSBkaWZmZXJlbnQgcG9pbnQgYW5kIGVhcmx5IHRlcm1pbmF0ZSBpdC4gT25jZSB3aWxsIGVuc3VyZSB0aGF0IGZ1bmN0aW9uXG4gICAgICAvLyBpcyBvbmx5IGNhbGxlZCBvbmUgdGltZS5cbiAgICAgIGNhbmNlbDogb25jZSgoKSA9PiB7XG4gICAgICAgIHJlamVjdChUUkFOU0lUSU9OX0NBTkNFTExFRCk7XG4gICAgICAgIGZpbmlzaCgpO1xuICAgICAgfSksXG4gICAgICBmaW5pc2gsXG4gICAgICAvLyBUaGlzIHN0b3JlIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZSBzbyB3ZSBjYW4gY2FuY2VsIGl0XG4gICAgICBuZXh0RnJhbWU6IG51bGxcbiAgICB9O1xuICAgIHN0YWdlcy5zdGFydCgpO1xuICAgIHN0YWdlcy5kdXJpbmcoKTtcbiAgICBlbC5fX3hfdHJhbnNpdGlvbi5uZXh0RnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgLy8gTm90ZTogU2FmYXJpJ3MgdHJhbnNpdGlvbkR1cmF0aW9uIHByb3BlcnR5IHdpbGwgbGlzdCBvdXQgY29tbWEgc2VwYXJhdGVkIHRyYW5zaXRpb24gZHVyYXRpb25zXG4gICAgICAvLyBmb3IgZXZlcnkgc2luZ2xlIHRyYW5zaXRpb24gcHJvcGVydHkuIExldCdzIGdyYWIgdGhlIGZpcnN0IG9uZSBhbmQgY2FsbCBpdCBhIGRheS5cbiAgICAgIGxldCBkdXJhdGlvbiA9IE51bWJlcihnZXRDb21wdXRlZFN0eWxlKGVsKS50cmFuc2l0aW9uRHVyYXRpb24ucmVwbGFjZSgvLC4qLywgJycpLnJlcGxhY2UoJ3MnLCAnJykpICogMTAwMDtcblxuICAgICAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICAgIGR1cmF0aW9uID0gTnVtYmVyKGdldENvbXB1dGVkU3R5bGUoZWwpLmFuaW1hdGlvbkR1cmF0aW9uLnJlcGxhY2UoJ3MnLCAnJykpICogMTAwMDtcbiAgICAgIH1cblxuICAgICAgc3RhZ2VzLnNob3coKTtcbiAgICAgIGVsLl9feF90cmFuc2l0aW9uLm5leHRGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHN0YWdlcy5lbmQoKTtcbiAgICAgICAgc2V0VGltZW91dChlbC5fX3hfdHJhbnNpdGlvbi5maW5pc2gsIGR1cmF0aW9uKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGlzTnVtZXJpYyhzdWJqZWN0KSB7XG4gICAgcmV0dXJuICFBcnJheS5pc0FycmF5KHN1YmplY3QpICYmICFpc05hTihzdWJqZWN0KTtcbiAgfSAvLyBUaGFua3MgQHZ1ZWpzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvYmxvYi80ZGU0NjQ5ZDk2MzcyNjJhOWIwMDc3MjBiNTlmODBhYzcyYTU2MjBjL3NyYy9zaGFyZWQvdXRpbC5qc1xuXG4gIGZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHtcbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUZvckRpcmVjdGl2ZShjb21wb25lbnQsIHRlbXBsYXRlRWwsIGV4cHJlc3Npb24sIGluaXRpYWxVcGRhdGUsIGV4dHJhVmFycykge1xuICAgIHdhcm5JZk1hbGZvcm1lZFRlbXBsYXRlKHRlbXBsYXRlRWwsICd4LWZvcicpO1xuICAgIGxldCBpdGVyYXRvck5hbWVzID0gdHlwZW9mIGV4cHJlc3Npb24gPT09ICdmdW5jdGlvbicgPyBwYXJzZUZvckV4cHJlc3Npb24oY29tcG9uZW50LmV2YWx1YXRlUmV0dXJuRXhwcmVzc2lvbih0ZW1wbGF0ZUVsLCBleHByZXNzaW9uKSkgOiBwYXJzZUZvckV4cHJlc3Npb24oZXhwcmVzc2lvbik7XG4gICAgbGV0IGl0ZW1zID0gZXZhbHVhdGVJdGVtc0FuZFJldHVybkVtcHR5SWZYSWZJc1ByZXNlbnRBbmRGYWxzZU9uRWxlbWVudChjb21wb25lbnQsIHRlbXBsYXRlRWwsIGl0ZXJhdG9yTmFtZXMsIGV4dHJhVmFycyk7IC8vIEFzIHdlIHdhbGsgdGhlIGFycmF5LCB3ZSdsbCBhbHNvIHdhbGsgdGhlIERPTSAodXBkYXRpbmcvY3JlYXRpbmcgYXMgd2UgZ28pLlxuXG4gICAgbGV0IGN1cnJlbnRFbCA9IHRlbXBsYXRlRWw7XG4gICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGxldCBpdGVyYXRpb25TY29wZVZhcmlhYmxlcyA9IGdldEl0ZXJhdGlvblNjb3BlVmFyaWFibGVzKGl0ZXJhdG9yTmFtZXMsIGl0ZW0sIGluZGV4LCBpdGVtcywgZXh0cmFWYXJzKCkpO1xuICAgICAgbGV0IGN1cnJlbnRLZXkgPSBnZW5lcmF0ZUtleUZvckl0ZXJhdGlvbihjb21wb25lbnQsIHRlbXBsYXRlRWwsIGluZGV4LCBpdGVyYXRpb25TY29wZVZhcmlhYmxlcyk7XG4gICAgICBsZXQgbmV4dEVsID0gbG9va0FoZWFkRm9yTWF0Y2hpbmdLZXllZEVsZW1lbnRBbmRNb3ZlSXRJZkZvdW5kKGN1cnJlbnRFbC5uZXh0RWxlbWVudFNpYmxpbmcsIGN1cnJlbnRLZXkpOyAvLyBJZiB3ZSBoYXZlbid0IGZvdW5kIGEgbWF0Y2hpbmcga2V5LCBpbnNlcnQgdGhlIGVsZW1lbnQgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG5cbiAgICAgIGlmICghbmV4dEVsKSB7XG4gICAgICAgIG5leHRFbCA9IGFkZEVsZW1lbnRJbkxvb3BBZnRlckN1cnJlbnRFbCh0ZW1wbGF0ZUVsLCBjdXJyZW50RWwpOyAvLyBBbmQgdHJhbnNpdGlvbiBpdCBpbiBpZiBpdCdzIG5vdCB0aGUgZmlyc3QgcGFnZSBsb2FkLlxuXG4gICAgICAgIHRyYW5zaXRpb25JbihuZXh0RWwsICgpID0+IHt9LCAoKSA9PiB7fSwgY29tcG9uZW50LCBpbml0aWFsVXBkYXRlKTtcbiAgICAgICAgbmV4dEVsLl9feF9mb3IgPSBpdGVyYXRpb25TY29wZVZhcmlhYmxlcztcbiAgICAgICAgY29tcG9uZW50LmluaXRpYWxpemVFbGVtZW50cyhuZXh0RWwsICgpID0+IG5leHRFbC5fX3hfZm9yKTsgLy8gT3RoZXJ3aXNlIHVwZGF0ZSB0aGUgZWxlbWVudCB3ZSBmb3VuZC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRlbXBvcmFyaWx5IHJlbW92ZSB0aGUga2V5IGluZGljYXRvciB0byBhbGxvdyB0aGUgbm9ybWFsIFwidXBkYXRlRWxlbWVudHNcIiB0byB3b3JrLlxuICAgICAgICBkZWxldGUgbmV4dEVsLl9feF9mb3Jfa2V5O1xuICAgICAgICBuZXh0RWwuX194X2ZvciA9IGl0ZXJhdGlvblNjb3BlVmFyaWFibGVzO1xuICAgICAgICBjb21wb25lbnQudXBkYXRlRWxlbWVudHMobmV4dEVsLCAoKSA9PiBuZXh0RWwuX194X2Zvcik7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRFbCA9IG5leHRFbDtcbiAgICAgIGN1cnJlbnRFbC5fX3hfZm9yX2tleSA9IGN1cnJlbnRLZXk7XG4gICAgfSk7XG4gICAgcmVtb3ZlQW55TGVmdE92ZXJFbGVtZW50c0Zyb21QcmV2aW91c1VwZGF0ZShjdXJyZW50RWwsIGNvbXBvbmVudCk7XG4gIH0gLy8gVGhpcyB3YXMgdGFrZW4gZnJvbSBWdWVKUyAyLiogY29yZS4gVGhhbmtzIFZ1ZSFcblxuICBmdW5jdGlvbiBwYXJzZUZvckV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICAgIGxldCBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xuICAgIGxldCBzdHJpcFBhcmVuc1JFID0gL15cXCh8XFwpJC9nO1xuICAgIGxldCBmb3JBbGlhc1JFID0gLyhbXFxzXFxTXSo/KVxccysoPzppbnxvZilcXHMrKFtcXHNcXFNdKikvO1xuICAgIGxldCBpbk1hdGNoID0gU3RyaW5nKGV4cHJlc3Npb24pLm1hdGNoKGZvckFsaWFzUkUpO1xuICAgIGlmICghaW5NYXRjaCkgcmV0dXJuO1xuICAgIGxldCByZXMgPSB7fTtcbiAgICByZXMuaXRlbXMgPSBpbk1hdGNoWzJdLnRyaW0oKTtcbiAgICBsZXQgaXRlbSA9IGluTWF0Y2hbMV0udHJpbSgpLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgJycpO1xuICAgIGxldCBpdGVyYXRvck1hdGNoID0gaXRlbS5tYXRjaChmb3JJdGVyYXRvclJFKTtcblxuICAgIGlmIChpdGVyYXRvck1hdGNoKSB7XG4gICAgICByZXMuaXRlbSA9IGl0ZW0ucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJykudHJpbSgpO1xuICAgICAgcmVzLmluZGV4ID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG5cbiAgICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XG4gICAgICAgIHJlcy5jb2xsZWN0aW9uID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcy5pdGVtID0gaXRlbTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0aW9uU2NvcGVWYXJpYWJsZXMoaXRlcmF0b3JOYW1lcywgaXRlbSwgaW5kZXgsIGl0ZW1zLCBleHRyYVZhcnMpIHtcbiAgICAvLyBXZSBtdXN0IGNyZWF0ZSBhIG5ldyBvYmplY3QsIHNvIGVhY2ggaXRlcmF0aW9uIGhhcyBhIG5ldyBzY29wZVxuICAgIGxldCBzY29wZVZhcmlhYmxlcyA9IGV4dHJhVmFycyA/IF9vYmplY3RTcHJlYWQyKHt9LCBleHRyYVZhcnMpIDoge307XG4gICAgc2NvcGVWYXJpYWJsZXNbaXRlcmF0b3JOYW1lcy5pdGVtXSA9IGl0ZW07XG4gICAgaWYgKGl0ZXJhdG9yTmFtZXMuaW5kZXgpIHNjb3BlVmFyaWFibGVzW2l0ZXJhdG9yTmFtZXMuaW5kZXhdID0gaW5kZXg7XG4gICAgaWYgKGl0ZXJhdG9yTmFtZXMuY29sbGVjdGlvbikgc2NvcGVWYXJpYWJsZXNbaXRlcmF0b3JOYW1lcy5jb2xsZWN0aW9uXSA9IGl0ZW1zO1xuICAgIHJldHVybiBzY29wZVZhcmlhYmxlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlS2V5Rm9ySXRlcmF0aW9uKGNvbXBvbmVudCwgZWwsIGluZGV4LCBpdGVyYXRpb25TY29wZVZhcmlhYmxlcykge1xuICAgIGxldCBiaW5kS2V5QXR0cmlidXRlID0gZ2V0WEF0dHJzKGVsLCBjb21wb25lbnQsICdiaW5kJykuZmlsdGVyKGF0dHIgPT4gYXR0ci52YWx1ZSA9PT0gJ2tleScpWzBdOyAvLyBJZiB0aGUgZGV2IGhhc24ndCBzcGVjaWZpZWQgYSBrZXksIGp1c3QgcmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgaXRlcmF0aW9uLlxuXG4gICAgaWYgKCFiaW5kS2V5QXR0cmlidXRlKSByZXR1cm4gaW5kZXg7XG4gICAgcmV0dXJuIGNvbXBvbmVudC5ldmFsdWF0ZVJldHVybkV4cHJlc3Npb24oZWwsIGJpbmRLZXlBdHRyaWJ1dGUuZXhwcmVzc2lvbiwgKCkgPT4gaXRlcmF0aW9uU2NvcGVWYXJpYWJsZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXZhbHVhdGVJdGVtc0FuZFJldHVybkVtcHR5SWZYSWZJc1ByZXNlbnRBbmRGYWxzZU9uRWxlbWVudChjb21wb25lbnQsIGVsLCBpdGVyYXRvck5hbWVzLCBleHRyYVZhcnMpIHtcbiAgICBsZXQgaWZBdHRyaWJ1dGUgPSBnZXRYQXR0cnMoZWwsIGNvbXBvbmVudCwgJ2lmJylbMF07XG5cbiAgICBpZiAoaWZBdHRyaWJ1dGUgJiYgIWNvbXBvbmVudC5ldmFsdWF0ZVJldHVybkV4cHJlc3Npb24oZWwsIGlmQXR0cmlidXRlLmV4cHJlc3Npb24pKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgbGV0IGl0ZW1zID0gY29tcG9uZW50LmV2YWx1YXRlUmV0dXJuRXhwcmVzc2lvbihlbCwgaXRlcmF0b3JOYW1lcy5pdGVtcywgZXh0cmFWYXJzKTsgLy8gVGhpcyBhZGRzIHN1cHBvcnQgZm9yIHRoZSBgaSBpbiBuYCBzeW50YXguXG5cbiAgICBpZiAoaXNOdW1lcmljKGl0ZW1zKSAmJiBpdGVtcyA+PSAwKSB7XG4gICAgICBpdGVtcyA9IEFycmF5LmZyb20oQXJyYXkoaXRlbXMpLmtleXMoKSwgaSA9PiBpICsgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRWxlbWVudEluTG9vcEFmdGVyQ3VycmVudEVsKHRlbXBsYXRlRWwsIGN1cnJlbnRFbCkge1xuICAgIGxldCBjbG9uZSA9IGRvY3VtZW50LmltcG9ydE5vZGUodGVtcGxhdGVFbC5jb250ZW50LCB0cnVlKTtcbiAgICBjdXJyZW50RWwucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIGN1cnJlbnRFbC5uZXh0RWxlbWVudFNpYmxpbmcpO1xuICAgIHJldHVybiBjdXJyZW50RWwubmV4dEVsZW1lbnRTaWJsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gbG9va0FoZWFkRm9yTWF0Y2hpbmdLZXllZEVsZW1lbnRBbmRNb3ZlSXRJZkZvdW5kKG5leHRFbCwgY3VycmVudEtleSkge1xuICAgIGlmICghbmV4dEVsKSByZXR1cm47IC8vIElmIHdlIGFyZSBhbHJlYWR5IHBhc3QgdGhlIHgtZm9yIGdlbmVyYXRlZCBlbGVtZW50cywgd2UgZG9uJ3QgbmVlZCB0byBsb29rIGFoZWFkLlxuXG4gICAgaWYgKG5leHRFbC5fX3hfZm9yX2tleSA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIElmIHRoZSB0aGUga2V5J3MgRE8gbWF0Y2gsIG5vIG5lZWQgdG8gbG9vayBhaGVhZC5cblxuICAgIGlmIChuZXh0RWwuX194X2Zvcl9rZXkgPT09IGN1cnJlbnRLZXkpIHJldHVybiBuZXh0RWw7IC8vIElmIHRoZXkgZG9uJ3QsIHdlJ2xsIGxvb2sgYWhlYWQgZm9yIGEgbWF0Y2guXG4gICAgLy8gSWYgd2UgZmluZCBpdCwgd2UnbGwgbW92ZSBpdCB0byB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgbG9vcC5cblxuICAgIGxldCB0bXBOZXh0RWwgPSBuZXh0RWw7XG5cbiAgICB3aGlsZSAodG1wTmV4dEVsKSB7XG4gICAgICBpZiAodG1wTmV4dEVsLl9feF9mb3Jfa2V5ID09PSBjdXJyZW50S2V5KSB7XG4gICAgICAgIHJldHVybiB0bXBOZXh0RWwucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUodG1wTmV4dEVsLCBuZXh0RWwpO1xuICAgICAgfVxuXG4gICAgICB0bXBOZXh0RWwgPSB0bXBOZXh0RWwubmV4dEVsZW1lbnRTaWJsaW5nICYmIHRtcE5leHRFbC5uZXh0RWxlbWVudFNpYmxpbmcuX194X2Zvcl9rZXkgIT09IHVuZGVmaW5lZCA/IHRtcE5leHRFbC5uZXh0RWxlbWVudFNpYmxpbmcgOiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbnlMZWZ0T3ZlckVsZW1lbnRzRnJvbVByZXZpb3VzVXBkYXRlKGN1cnJlbnRFbCwgY29tcG9uZW50KSB7XG4gICAgdmFyIG5leHRFbGVtZW50RnJvbU9sZExvb3AgPSBjdXJyZW50RWwubmV4dEVsZW1lbnRTaWJsaW5nICYmIGN1cnJlbnRFbC5uZXh0RWxlbWVudFNpYmxpbmcuX194X2Zvcl9rZXkgIT09IHVuZGVmaW5lZCA/IGN1cnJlbnRFbC5uZXh0RWxlbWVudFNpYmxpbmcgOiBmYWxzZTtcblxuICAgIHdoaWxlIChuZXh0RWxlbWVudEZyb21PbGRMb29wKSB7XG4gICAgICBsZXQgbmV4dEVsZW1lbnRGcm9tT2xkTG9vcEltbXV0YWJsZSA9IG5leHRFbGVtZW50RnJvbU9sZExvb3A7XG4gICAgICBsZXQgbmV4dFNpYmxpbmcgPSBuZXh0RWxlbWVudEZyb21PbGRMb29wLm5leHRFbGVtZW50U2libGluZztcbiAgICAgIHRyYW5zaXRpb25PdXQobmV4dEVsZW1lbnRGcm9tT2xkTG9vcCwgKCkgPT4ge1xuICAgICAgICBuZXh0RWxlbWVudEZyb21PbGRMb29wSW1tdXRhYmxlLnJlbW92ZSgpO1xuICAgICAgfSwgKCkgPT4ge30sIGNvbXBvbmVudCk7XG4gICAgICBuZXh0RWxlbWVudEZyb21PbGRMb29wID0gbmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcuX194X2Zvcl9rZXkgIT09IHVuZGVmaW5lZCA/IG5leHRTaWJsaW5nIDogZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQXR0cmlidXRlQmluZGluZ0RpcmVjdGl2ZShjb21wb25lbnQsIGVsLCBhdHRyTmFtZSwgZXhwcmVzc2lvbiwgZXh0cmFWYXJzLCBhdHRyVHlwZSwgbW9kaWZpZXJzKSB7XG4gICAgdmFyIHZhbHVlID0gY29tcG9uZW50LmV2YWx1YXRlUmV0dXJuRXhwcmVzc2lvbihlbCwgZXhwcmVzc2lvbiwgZXh0cmFWYXJzKTtcblxuICAgIGlmIChhdHRyTmFtZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgaWYgKEFscGluZS5pZ25vcmVGb2N1c2VkRm9yVmFsdWVCaW5kaW5nICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuaXNTYW1lTm9kZShlbCkpIHJldHVybjsgLy8gSWYgbmVzdGVkIG1vZGVsIGtleSBpcyB1bmRlZmluZWQsIHNldCB0aGUgZGVmYXVsdCB2YWx1ZSB0byBlbXB0eSBzdHJpbmcuXG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIFN0cmluZyhleHByZXNzaW9uKS5tYXRjaCgvXFwuLykpIHtcbiAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKGVsLnR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgLy8gU2V0IHJhZGlvIHZhbHVlIGZyb20geC1iaW5kOnZhbHVlLCBpZiBubyBcInZhbHVlXCIgYXR0cmlidXRlIGV4aXN0cy5cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGFueSBpbml0aWFsIHN0YXRlIHZhbHVlcywgcmFkaW8gd2lsbCBoYXZlIGEgY29ycmVjdFxuICAgICAgICAvLyBcImNoZWNrZWRcIiB2YWx1ZSBzaW5jZSB4LWJpbmQ6dmFsdWUgaXMgcHJvY2Vzc2VkIGJlZm9yZSB4LW1vZGVsLlxuICAgICAgICBpZiAoZWwuYXR0cmlidXRlcy52YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGF0dHJUeXBlID09PSAnYmluZCcpIHtcbiAgICAgICAgICBlbC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKGF0dHJUeXBlICE9PSAnYmluZCcpIHtcbiAgICAgICAgICBlbC5jaGVja2VkID0gY2hlY2tlZEF0dHJMb29zZUNvbXBhcmUoZWwudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbC50eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgIC8vIElmIHdlIGFyZSBleHBsaWNpdGx5IGJpbmRpbmcgYSBzdHJpbmcgdG8gdGhlIDp2YWx1ZSwgc2V0IHRoZSBzdHJpbmcsXG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4sIGxlYXZlIGl0IGFsb25lLCBpdCB3aWxsIGJlIHNldCB0byBcIm9uXCJcbiAgICAgICAgLy8gYXV0b21hdGljYWxseS5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nICYmICFbbnVsbCwgdW5kZWZpbmVkXS5pbmNsdWRlcyh2YWx1ZSkgJiYgYXR0clR5cGUgPT09ICdiaW5kJykge1xuICAgICAgICAgIGVsLnZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChhdHRyVHlwZSAhPT0gJ2JpbmQnKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBJJ20gcHVycG9zZWx5IG5vdCB1c2luZyBBcnJheS5pbmNsdWRlcyBoZXJlIGJlY2F1c2UgaXQnc1xuICAgICAgICAgICAgLy8gc3RyaWN0LCBhbmQgYmVjYXVzZSBvZiBOdW1lcmljL1N0cmluZyBtaXMtY2FzdGluZywgSVxuICAgICAgICAgICAgLy8gd2FudCB0aGUgXCJpbmNsdWRlc1wiIHRvIGJlIFwiZnV6enlcIi5cbiAgICAgICAgICAgIGVsLmNoZWNrZWQgPSB2YWx1ZS5zb21lKHZhbCA9PiBjaGVja2VkQXR0ckxvb3NlQ29tcGFyZSh2YWwsIGVsLnZhbHVlKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLmNoZWNrZWQgPSAhIXZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbC50YWdOYW1lID09PSAnU0VMRUNUJykge1xuICAgICAgICB1cGRhdGVTZWxlY3QoZWwsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbC52YWx1ZSA9PT0gdmFsdWUpIHJldHVybjtcbiAgICAgICAgZWwudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGF0dHJOYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxDbGFzc2VzID0gZWwuX194X29yaWdpbmFsX2NsYXNzZXMgfHwgW107XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBhcnJheVVuaXF1ZShvcmlnaW5hbENsYXNzZXMuY29uY2F0KHZhbHVlKSkuam9pbignICcpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBTb3J0aW5nIHRoZSBrZXlzIC8gY2xhc3MgbmFtZXMgYnkgdGhlaXIgYm9vbGVhbiB2YWx1ZSB3aWxsIGVuc3VyZSB0aGF0XG4gICAgICAgIC8vIGFueXRoaW5nIHRoYXQgZXZhbHVhdGVzIHRvIGBmYWxzZWAgYW5kIG5lZWRzIHRvIHJlbW92ZSBjbGFzc2VzIGlzIHJ1biBmaXJzdC5cbiAgICAgICAgY29uc3Qga2V5c1NvcnRlZEJ5Qm9vbGVhblZhbHVlID0gT2JqZWN0LmtleXModmFsdWUpLnNvcnQoKGEsIGIpID0+IHZhbHVlW2FdIC0gdmFsdWVbYl0pO1xuICAgICAgICBrZXlzU29ydGVkQnlCb29sZWFuVmFsdWUuZm9yRWFjaChjbGFzc05hbWVzID0+IHtcbiAgICAgICAgICBpZiAodmFsdWVbY2xhc3NOYW1lc10pIHtcbiAgICAgICAgICAgIGNvbnZlcnRDbGFzc1N0cmluZ1RvQXJyYXkoY2xhc3NOYW1lcykuZm9yRWFjaChjbGFzc05hbWUgPT4gZWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udmVydENsYXNzU3RyaW5nVG9BcnJheShjbGFzc05hbWVzKS5mb3JFYWNoKGNsYXNzTmFtZSA9PiBlbC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvcmlnaW5hbENsYXNzZXMgPSBlbC5fX3hfb3JpZ2luYWxfY2xhc3NlcyB8fCBbXTtcbiAgICAgICAgY29uc3QgbmV3Q2xhc3NlcyA9IHZhbHVlID8gY29udmVydENsYXNzU3RyaW5nVG9BcnJheSh2YWx1ZSkgOiBbXTtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGFycmF5VW5pcXVlKG9yaWdpbmFsQ2xhc3Nlcy5jb25jYXQobmV3Q2xhc3NlcykpLmpvaW4oJyAnKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGF0dHJOYW1lID0gbW9kaWZpZXJzLmluY2x1ZGVzKCdjYW1lbCcpID8gY2FtZWxDYXNlKGF0dHJOYW1lKSA6IGF0dHJOYW1lOyAvLyBJZiBhbiBhdHRyaWJ1dGUncyBib3VuZCB2YWx1ZSBpcyBudWxsLCB1bmRlZmluZWQgb3IgZmFsc2UsIHJlbW92ZSB0aGUgYXR0cmlidXRlXG5cbiAgICAgIGlmIChbbnVsbCwgdW5kZWZpbmVkLCBmYWxzZV0uaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0Jvb2xlYW5BdHRyKGF0dHJOYW1lKSA/IHNldElmQ2hhbmdlZChlbCwgYXR0ck5hbWUsIGF0dHJOYW1lKSA6IHNldElmQ2hhbmdlZChlbCwgYXR0ck5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRJZkNoYW5nZWQoZWwsIGF0dHJOYW1lLCB2YWx1ZSkge1xuICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpICE9IHZhbHVlKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTZWxlY3QoZWwsIHZhbHVlKSB7XG4gICAgY29uc3QgYXJyYXlXcmFwcGVkVmFsdWUgPSBbXS5jb25jYXQodmFsdWUpLm1hcCh2YWx1ZSA9PiB7XG4gICAgICByZXR1cm4gdmFsdWUgKyAnJztcbiAgICB9KTtcbiAgICBBcnJheS5mcm9tKGVsLm9wdGlvbnMpLmZvckVhY2gob3B0aW9uID0+IHtcbiAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGFycmF5V3JhcHBlZFZhbHVlLmluY2x1ZGVzKG9wdGlvbi52YWx1ZSB8fCBvcHRpb24udGV4dCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVUZXh0RGlyZWN0aXZlKGVsLCBvdXRwdXQsIGV4cHJlc3Npb24pIHtcbiAgICAvLyBJZiBuZXN0ZWQgbW9kZWwga2V5IGlzIHVuZGVmaW5lZCwgc2V0IHRoZSBkZWZhdWx0IHZhbHVlIHRvIGVtcHR5IHN0cmluZy5cbiAgICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQgJiYgU3RyaW5nKGV4cHJlc3Npb24pLm1hdGNoKC9cXC4vKSkge1xuICAgICAgb3V0cHV0ID0gJyc7XG4gICAgfVxuXG4gICAgZWwudGV4dENvbnRlbnQgPSBvdXRwdXQ7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVIdG1sRGlyZWN0aXZlKGNvbXBvbmVudCwgZWwsIGV4cHJlc3Npb24sIGV4dHJhVmFycykge1xuICAgIGVsLmlubmVySFRNTCA9IGNvbXBvbmVudC5ldmFsdWF0ZVJldHVybkV4cHJlc3Npb24oZWwsIGV4cHJlc3Npb24sIGV4dHJhVmFycyk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTaG93RGlyZWN0aXZlKGNvbXBvbmVudCwgZWwsIHZhbHVlLCBtb2RpZmllcnMsIGluaXRpYWxVcGRhdGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGhpZGUgPSAoKSA9PiB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgZWwuX194X2lzX3Nob3duID0gZmFsc2U7XG4gICAgfTtcblxuICAgIGNvbnN0IHNob3cgPSAoKSA9PiB7XG4gICAgICBpZiAoZWwuc3R5bGUubGVuZ3RoID09PSAxICYmIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnZGlzcGxheScpO1xuICAgICAgfVxuXG4gICAgICBlbC5fX3hfaXNfc2hvd24gPSB0cnVlO1xuICAgIH07XG5cbiAgICBpZiAoaW5pdGlhbFVwZGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHNob3coKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhpZGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZSA9IChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBpZiAoZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnIHx8IGVsLl9feF90cmFuc2l0aW9uKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbkluKGVsLCAoKSA9PiB7XG4gICAgICAgICAgICBzaG93KCk7XG4gICAgICAgICAgfSwgcmVqZWN0LCBjb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZSgoKSA9PiB7fSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZWwuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbk91dChlbCwgKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZSgoKSA9PiB7XG4gICAgICAgICAgICAgIGhpZGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIHJlamVjdCwgY29tcG9uZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKCgpID0+IHt9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07IC8vIFRoZSB3b3JraW5nIG9mIHgtc2hvdyBpcyBhIGJpdCBjb21wbGV4IGJlY2F1c2Ugd2UgbmVlZCB0b1xuICAgIC8vIHdhaXQgZm9yIGFueSBjaGlsZCB0cmFuc2l0aW9ucyB0byBmaW5pc2ggYmVmb3JlIGhpZGluZ1xuICAgIC8vIHNvbWUgZWxlbWVudC4gQWxzbywgdGhpcyBoYXMgdG8gYmUgZG9uZSByZWN1cnNpdmVseS5cbiAgICAvLyBJZiB4LXNob3cuaW1tZWRpYXRlLCBmb3JlZ29lIHRoZSB3YWl0aW5nLlxuXG5cbiAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdpbW1lZGlhdGUnKSkge1xuICAgICAgaGFuZGxlKGZpbmlzaCA9PiBmaW5pc2goKSwgKCkgPT4ge30pO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8geC1zaG93IGlzIGVuY291bnRlcmVkIGR1cmluZyBhIERPTSB0cmVlIHdhbGsuIElmIGFuIGVsZW1lbnRcbiAgICAvLyB3ZSBlbmNvdW50ZXIgaXMgTk9UIGEgY2hpbGQgb2YgYW5vdGhlciB4LXNob3cgZWxlbWVudCB3ZVxuICAgIC8vIGNhbiBleGVjdXRlIHRoZSBwcmV2aW91cyB4LXNob3cgc3RhY2sgKGlmIG9uZSBleGlzdHMpLlxuXG5cbiAgICBpZiAoY29tcG9uZW50LnNob3dEaXJlY3RpdmVMYXN0RWxlbWVudCAmJiAhY29tcG9uZW50LnNob3dEaXJlY3RpdmVMYXN0RWxlbWVudC5jb250YWlucyhlbCkpIHtcbiAgICAgIGNvbXBvbmVudC5leGVjdXRlQW5kQ2xlYXJSZW1haW5pbmdTaG93RGlyZWN0aXZlU3RhY2soKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnQuc2hvd0RpcmVjdGl2ZVN0YWNrLnB1c2goaGFuZGxlKTtcbiAgICBjb21wb25lbnQuc2hvd0RpcmVjdGl2ZUxhc3RFbGVtZW50ID0gZWw7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVJZkRpcmVjdGl2ZShjb21wb25lbnQsIGVsLCBleHByZXNzaW9uUmVzdWx0LCBpbml0aWFsVXBkYXRlLCBleHRyYVZhcnMpIHtcbiAgICB3YXJuSWZNYWxmb3JtZWRUZW1wbGF0ZShlbCwgJ3gtaWYnKTtcbiAgICBjb25zdCBlbGVtZW50SGFzQWxyZWFkeUJlZW5BZGRlZCA9IGVsLm5leHRFbGVtZW50U2libGluZyAmJiBlbC5uZXh0RWxlbWVudFNpYmxpbmcuX194X2luc2VydGVkX21lID09PSB0cnVlO1xuXG4gICAgaWYgKGV4cHJlc3Npb25SZXN1bHQgJiYgKCFlbGVtZW50SGFzQWxyZWFkeUJlZW5BZGRlZCB8fCBlbC5fX3hfdHJhbnNpdGlvbikpIHtcbiAgICAgIGNvbnN0IGNsb25lID0gZG9jdW1lbnQuaW1wb3J0Tm9kZShlbC5jb250ZW50LCB0cnVlKTtcbiAgICAgIGVsLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNsb25lLCBlbC5uZXh0RWxlbWVudFNpYmxpbmcpO1xuICAgICAgdHJhbnNpdGlvbkluKGVsLm5leHRFbGVtZW50U2libGluZywgKCkgPT4ge30sICgpID0+IHt9LCBjb21wb25lbnQsIGluaXRpYWxVcGRhdGUpO1xuICAgICAgY29tcG9uZW50LmluaXRpYWxpemVFbGVtZW50cyhlbC5uZXh0RWxlbWVudFNpYmxpbmcsIGV4dHJhVmFycyk7XG4gICAgICBlbC5uZXh0RWxlbWVudFNpYmxpbmcuX194X2luc2VydGVkX21lID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFleHByZXNzaW9uUmVzdWx0ICYmIGVsZW1lbnRIYXNBbHJlYWR5QmVlbkFkZGVkKSB7XG4gICAgICB0cmFuc2l0aW9uT3V0KGVsLm5leHRFbGVtZW50U2libGluZywgKCkgPT4ge1xuICAgICAgICBlbC5uZXh0RWxlbWVudFNpYmxpbmcucmVtb3ZlKCk7XG4gICAgICB9LCAoKSA9PiB7fSwgY29tcG9uZW50LCBpbml0aWFsVXBkYXRlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWdpc3Rlckxpc3RlbmVyKGNvbXBvbmVudCwgZWwsIGV2ZW50LCBtb2RpZmllcnMsIGV4cHJlc3Npb24sIGV4dHJhVmFycyA9IHt9KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIHBhc3NpdmU6IG1vZGlmaWVycy5pbmNsdWRlcygncGFzc2l2ZScpXG4gICAgfTtcblxuICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ2NhbWVsJykpIHtcbiAgICAgIGV2ZW50ID0gY2FtZWxDYXNlKGV2ZW50KTtcbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlciwgbGlzdGVuZXJUYXJnZXQ7XG5cbiAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdhd2F5JykpIHtcbiAgICAgIGxpc3RlbmVyVGFyZ2V0ID0gZG9jdW1lbnQ7XG5cbiAgICAgIGhhbmRsZXIgPSBlID0+IHtcbiAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlIGNsaWNrIGNhbWUgZnJvbSB0aGUgZWxlbWVudCBvciB3aXRoaW4gaXQuXG4gICAgICAgIGlmIChlbC5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjsgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhpcyBlbGVtZW50IGlzbid0IGN1cnJlbnRseSB2aXNpYmxlLlxuXG4gICAgICAgIGlmIChlbC5vZmZzZXRXaWR0aCA8IDEgJiYgZWwub2Zmc2V0SGVpZ2h0IDwgMSkgcmV0dXJuOyAvLyBOb3cgdGhhdCB3ZSBhcmUgc3VyZSB0aGUgZWxlbWVudCBpcyB2aXNpYmxlLCBBTkQgdGhlIGNsaWNrXG4gICAgICAgIC8vIGlzIGZyb20gb3V0c2lkZSBpdCwgbGV0J3MgcnVuIHRoZSBleHByZXNzaW9uLlxuXG4gICAgICAgIHJ1bkxpc3RlbmVySGFuZGxlcihjb21wb25lbnQsIGV4cHJlc3Npb24sIGUsIGV4dHJhVmFycyk7XG5cbiAgICAgICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygnb25jZScpKSB7XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3RlbmVyVGFyZ2V0ID0gbW9kaWZpZXJzLmluY2x1ZGVzKCd3aW5kb3cnKSA/IHdpbmRvdyA6IG1vZGlmaWVycy5pbmNsdWRlcygnZG9jdW1lbnQnKSA/IGRvY3VtZW50IDogZWw7XG5cbiAgICAgIGhhbmRsZXIgPSBlID0+IHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoaXMgZ2xvYmFsIGV2ZW50IGhhbmRsZXIgaWYgdGhlIGVsZW1lbnQgdGhhdCBkZWNsYXJlZCBpdFxuICAgICAgICAvLyBoYXMgYmVlbiByZW1vdmVkLiBJdCdzIG5vdyBzdGFsZS5cbiAgICAgICAgaWYgKGxpc3RlbmVyVGFyZ2V0ID09PSB3aW5kb3cgfHwgbGlzdGVuZXJUYXJnZXQgPT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGVsKSkge1xuICAgICAgICAgICAgbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzS2V5RXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgaWYgKGlzTGlzdGVuaW5nRm9yQVNwZWNpZmljS2V5VGhhdEhhc250QmVlblByZXNzZWQoZSwgbW9kaWZpZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ3ByZXZlbnQnKSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdzdG9wJykpIGUuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIElmIHRoZSAuc2VsZiBtb2RpZmllciBpc24ndCBwcmVzZW50LCBvciBpZiBpdCBpcyBwcmVzZW50IGFuZFxuICAgICAgICAvLyB0aGUgdGFyZ2V0IGVsZW1lbnQgbWF0Y2hlcyB0aGUgZWxlbWVudCB3ZSBhcmUgcmVnaXN0ZXJpbmcgdGhlXG4gICAgICAgIC8vIGV2ZW50IG9uLCBydW4gdGhlIGhhbmRsZXJcblxuICAgICAgICBpZiAoIW1vZGlmaWVycy5pbmNsdWRlcygnc2VsZicpIHx8IGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gcnVuTGlzdGVuZXJIYW5kbGVyKGNvbXBvbmVudCwgZXhwcmVzc2lvbiwgZSwgZXh0cmFWYXJzKTtcbiAgICAgICAgICByZXR1cm5WYWx1ZS50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygnb25jZScpKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdkZWJvdW5jZScpKSB7XG4gICAgICBsZXQgbmV4dE1vZGlmaWVyID0gbW9kaWZpZXJzW21vZGlmaWVycy5pbmRleE9mKCdkZWJvdW5jZScpICsgMV0gfHwgJ2ludmFsaWQtd2FpdCc7XG4gICAgICBsZXQgd2FpdCA9IGlzTnVtZXJpYyhuZXh0TW9kaWZpZXIuc3BsaXQoJ21zJylbMF0pID8gTnVtYmVyKG5leHRNb2RpZmllci5zcGxpdCgnbXMnKVswXSkgOiAyNTA7XG4gICAgICBoYW5kbGVyID0gZGVib3VuY2UoaGFuZGxlciwgd2FpdCk7XG4gICAgfVxuXG4gICAgbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiBydW5MaXN0ZW5lckhhbmRsZXIoY29tcG9uZW50LCBleHByZXNzaW9uLCBlLCBleHRyYVZhcnMpIHtcbiAgICByZXR1cm4gY29tcG9uZW50LmV2YWx1YXRlQ29tbWFuZEV4cHJlc3Npb24oZS50YXJnZXQsIGV4cHJlc3Npb24sICgpID0+IHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZXh0cmFWYXJzKCkpLCB7fSwge1xuICAgICAgICAnJGV2ZW50JzogZVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0tleUV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIFsna2V5ZG93bicsICdrZXl1cCddLmluY2x1ZGVzKGV2ZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTGlzdGVuaW5nRm9yQVNwZWNpZmljS2V5VGhhdEhhc250QmVlblByZXNzZWQoZSwgbW9kaWZpZXJzKSB7XG4gICAgbGV0IGtleU1vZGlmaWVycyA9IG1vZGlmaWVycy5maWx0ZXIoaSA9PiB7XG4gICAgICByZXR1cm4gIVsnd2luZG93JywgJ2RvY3VtZW50JywgJ3ByZXZlbnQnLCAnc3RvcCddLmluY2x1ZGVzKGkpO1xuICAgIH0pO1xuXG4gICAgaWYgKGtleU1vZGlmaWVycy5pbmNsdWRlcygnZGVib3VuY2UnKSkge1xuICAgICAgbGV0IGRlYm91bmNlSW5kZXggPSBrZXlNb2RpZmllcnMuaW5kZXhPZignZGVib3VuY2UnKTtcbiAgICAgIGtleU1vZGlmaWVycy5zcGxpY2UoZGVib3VuY2VJbmRleCwgaXNOdW1lcmljKChrZXlNb2RpZmllcnNbZGVib3VuY2VJbmRleCArIDFdIHx8ICdpbnZhbGlkLXdhaXQnKS5zcGxpdCgnbXMnKVswXSkgPyAyIDogMSk7XG4gICAgfSAvLyBJZiBubyBtb2RpZmllciBpcyBzcGVjaWZpZWQsIHdlJ2xsIGNhbGwgaXQgYSBwcmVzcy5cblxuXG4gICAgaWYgKGtleU1vZGlmaWVycy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTsgLy8gSWYgb25lIGlzIHBhc3NlZCwgQU5EIGl0IG1hdGNoZXMgdGhlIGtleSBwcmVzc2VkLCB3ZSdsbCBjYWxsIGl0IGEgcHJlc3MuXG5cbiAgICBpZiAoa2V5TW9kaWZpZXJzLmxlbmd0aCA9PT0gMSAmJiBrZXlNb2RpZmllcnNbMF0gPT09IGtleVRvTW9kaWZpZXIoZS5rZXkpKSByZXR1cm4gZmFsc2U7IC8vIFRoZSB1c2VyIGlzIGxpc3RlbmluZyBmb3Iga2V5IGNvbWJpbmF0aW9ucy5cblxuICAgIGNvbnN0IHN5c3RlbUtleU1vZGlmaWVycyA9IFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YScsICdjbWQnLCAnc3VwZXInXTtcbiAgICBjb25zdCBzZWxlY3RlZFN5c3RlbUtleU1vZGlmaWVycyA9IHN5c3RlbUtleU1vZGlmaWVycy5maWx0ZXIobW9kaWZpZXIgPT4ga2V5TW9kaWZpZXJzLmluY2x1ZGVzKG1vZGlmaWVyKSk7XG4gICAga2V5TW9kaWZpZXJzID0ga2V5TW9kaWZpZXJzLmZpbHRlcihpID0+ICFzZWxlY3RlZFN5c3RlbUtleU1vZGlmaWVycy5pbmNsdWRlcyhpKSk7XG5cbiAgICBpZiAoc2VsZWN0ZWRTeXN0ZW1LZXlNb2RpZmllcnMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYWN0aXZlbHlQcmVzc2VkS2V5TW9kaWZpZXJzID0gc2VsZWN0ZWRTeXN0ZW1LZXlNb2RpZmllcnMuZmlsdGVyKG1vZGlmaWVyID0+IHtcbiAgICAgICAgLy8gQWxpYXMgXCJjbWRcIiBhbmQgXCJzdXBlclwiIHRvIFwibWV0YVwiXG4gICAgICAgIGlmIChtb2RpZmllciA9PT0gJ2NtZCcgfHwgbW9kaWZpZXIgPT09ICdzdXBlcicpIG1vZGlmaWVyID0gJ21ldGEnO1xuICAgICAgICByZXR1cm4gZVtgJHttb2RpZmllcn1LZXlgXTtcbiAgICAgIH0pOyAvLyBJZiBhbGwgdGhlIG1vZGlmaWVycyBzZWxlY3RlZCBhcmUgcHJlc3NlZCwgLi4uXG5cbiAgICAgIGlmIChhY3RpdmVseVByZXNzZWRLZXlNb2RpZmllcnMubGVuZ3RoID09PSBzZWxlY3RlZFN5c3RlbUtleU1vZGlmaWVycy5sZW5ndGgpIHtcbiAgICAgICAgLy8gQU5EIHRoZSByZW1haW5pbmcga2V5IGlzIHByZXNzZWQgYXMgd2VsbC4gSXQncyBhIHByZXNzLlxuICAgICAgICBpZiAoa2V5TW9kaWZpZXJzWzBdID09PSBrZXlUb01vZGlmaWVyKGUua2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gLy8gV2UnbGwgY2FsbCBpdCBOT1QgYSB2YWxpZCBrZXlwcmVzcy5cblxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBrZXlUb01vZGlmaWVyKGtleSkge1xuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlICcvJzpcbiAgICAgICAgcmV0dXJuICdzbGFzaCc7XG5cbiAgICAgIGNhc2UgJyAnOlxuICAgICAgY2FzZSAnU3BhY2ViYXInOlxuICAgICAgICByZXR1cm4gJ3NwYWNlJztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGtleSAmJiBrZWJhYkNhc2Uoa2V5KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWdpc3Rlck1vZGVsTGlzdGVuZXIoY29tcG9uZW50LCBlbCwgbW9kaWZpZXJzLCBleHByZXNzaW9uLCBleHRyYVZhcnMpIHtcbiAgICAvLyBJZiB0aGUgZWxlbWVudCB3ZSBhcmUgYmluZGluZyB0byBpcyBhIHNlbGVjdCwgYSByYWRpbywgb3IgY2hlY2tib3hcbiAgICAvLyB3ZSdsbCBsaXN0ZW4gZm9yIHRoZSBjaGFuZ2UgZXZlbnQgaW5zdGVhZCBvZiB0aGUgXCJpbnB1dFwiIGV2ZW50LlxuICAgIHZhciBldmVudCA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NlbGVjdCcgfHwgWydjaGVja2JveCcsICdyYWRpbyddLmluY2x1ZGVzKGVsLnR5cGUpIHx8IG1vZGlmaWVycy5pbmNsdWRlcygnbGF6eScpID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIGNvbnN0IGxpc3RlbmVyRXhwcmVzc2lvbiA9IGAke2V4cHJlc3Npb259ID0gcmlnaHRTaWRlT2ZFeHByZXNzaW9uKCRldmVudCwgJHtleHByZXNzaW9ufSlgO1xuICAgIHJlZ2lzdGVyTGlzdGVuZXIoY29tcG9uZW50LCBlbCwgZXZlbnQsIG1vZGlmaWVycywgbGlzdGVuZXJFeHByZXNzaW9uLCAoKSA9PiB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGV4dHJhVmFycygpKSwge30sIHtcbiAgICAgICAgcmlnaHRTaWRlT2ZFeHByZXNzaW9uOiBnZW5lcmF0ZU1vZGVsQXNzaWdubWVudEZ1bmN0aW9uKGVsLCBtb2RpZmllcnMsIGV4cHJlc3Npb24pXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlTW9kZWxBc3NpZ25tZW50RnVuY3Rpb24oZWwsIG1vZGlmaWVycywgZXhwcmVzc2lvbikge1xuICAgIGlmIChlbC50eXBlID09PSAncmFkaW8nKSB7XG4gICAgICAvLyBSYWRpbyBidXR0b25zIG9ubHkgd29yayBwcm9wZXJseSB3aGVuIHRoZXkgc2hhcmUgYSBuYW1lIGF0dHJpYnV0ZS5cbiAgICAgIC8vIFBlb3BsZSBtaWdodCBhc3N1bWUgd2UgdGFrZSBjYXJlIG9mIHRoYXQgZm9yIHRoZW0sIGJlY2F1c2VcbiAgICAgIC8vIHRoZXkgYWxyZWFkeSBzZXQgYSBzaGFyZWQgXCJ4LW1vZGVsXCIgYXR0cmlidXRlLlxuICAgICAgaWYgKCFlbC5oYXNBdHRyaWJ1dGUoJ25hbWUnKSkgZWwuc2V0QXR0cmlidXRlKCduYW1lJywgZXhwcmVzc2lvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIChldmVudCwgY3VycmVudFZhbHVlKSA9PiB7XG4gICAgICAvLyBDaGVjayBmb3IgZXZlbnQuZGV0YWlsIGR1ZSB0byBhbiBpc3N1ZSB3aGVyZSBJRTExIGhhbmRsZXMgb3RoZXIgZXZlbnRzIGFzIGEgQ3VzdG9tRXZlbnQuXG4gICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBDdXN0b21FdmVudCAmJiBldmVudC5kZXRhaWwpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50LmRldGFpbDtcbiAgICAgIH0gZWxzZSBpZiAoZWwudHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgICAgICAvLyBJZiB0aGUgZGF0YSB3ZSBhcmUgYmluZGluZyB0byBpcyBhbiBhcnJheSwgdG9nZ2xlIGl0cyB2YWx1ZSBpbnNpZGUgdGhlIGFycmF5LlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBtb2RpZmllcnMuaW5jbHVkZXMoJ251bWJlcicpID8gc2FmZVBhcnNlTnVtYmVyKGV2ZW50LnRhcmdldC52YWx1ZSkgOiBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldC5jaGVja2VkID8gY3VycmVudFZhbHVlLmNvbmNhdChbbmV3VmFsdWVdKSA6IGN1cnJlbnRWYWx1ZS5maWx0ZXIoZWwgPT4gIWNoZWNrZWRBdHRyTG9vc2VDb21wYXJlKGVsLCBuZXdWYWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBldmVudC50YXJnZXQuY2hlY2tlZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnICYmIGVsLm11bHRpcGxlKSB7XG4gICAgICAgIHJldHVybiBtb2RpZmllcnMuaW5jbHVkZXMoJ251bWJlcicpID8gQXJyYXkuZnJvbShldmVudC50YXJnZXQuc2VsZWN0ZWRPcHRpb25zKS5tYXAob3B0aW9uID0+IHtcbiAgICAgICAgICBjb25zdCByYXdWYWx1ZSA9IG9wdGlvbi52YWx1ZSB8fCBvcHRpb24udGV4dDtcbiAgICAgICAgICByZXR1cm4gc2FmZVBhcnNlTnVtYmVyKHJhd1ZhbHVlKTtcbiAgICAgICAgfSkgOiBBcnJheS5mcm9tKGV2ZW50LnRhcmdldC5zZWxlY3RlZE9wdGlvbnMpLm1hcChvcHRpb24gPT4ge1xuICAgICAgICAgIHJldHVybiBvcHRpb24udmFsdWUgfHwgb3B0aW9uLnRleHQ7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmF3VmFsdWUgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgIHJldHVybiBtb2RpZmllcnMuaW5jbHVkZXMoJ251bWJlcicpID8gc2FmZVBhcnNlTnVtYmVyKHJhd1ZhbHVlKSA6IG1vZGlmaWVycy5pbmNsdWRlcygndHJpbScpID8gcmF3VmFsdWUudHJpbSgpIDogcmF3VmFsdWU7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVQYXJzZU51bWJlcihyYXdWYWx1ZSkge1xuICAgIGNvbnN0IG51bWJlciA9IHJhd1ZhbHVlID8gcGFyc2VGbG9hdChyYXdWYWx1ZSkgOiBudWxsO1xuICAgIHJldHVybiBpc051bWVyaWMobnVtYmVyKSA/IG51bWJlciA6IHJhd1ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvcHlyaWdodCAoQykgMjAxNyBzYWxlc2ZvcmNlLmNvbSwgaW5jLlxuICAgKi9cbiAgY29uc3QgeyBpc0FycmF5IH0gPSBBcnJheTtcbiAgY29uc3QgeyBnZXRQcm90b3R5cGVPZiwgY3JlYXRlOiBPYmplY3RDcmVhdGUsIGRlZmluZVByb3BlcnR5OiBPYmplY3REZWZpbmVQcm9wZXJ0eSwgZGVmaW5lUHJvcGVydGllczogT2JqZWN0RGVmaW5lUHJvcGVydGllcywgaXNFeHRlbnNpYmxlLCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsIGdldE93blByb3BlcnR5TmFtZXMsIGdldE93blByb3BlcnR5U3ltYm9scywgcHJldmVudEV4dGVuc2lvbnMsIGhhc093blByb3BlcnR5LCB9ID0gT2JqZWN0O1xuICBjb25zdCB7IHB1c2g6IEFycmF5UHVzaCwgY29uY2F0OiBBcnJheUNvbmNhdCwgbWFwOiBBcnJheU1hcCwgfSA9IEFycmF5LnByb3RvdHlwZTtcbiAgZnVuY3Rpb24gaXNVbmRlZmluZWQob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09PSB1bmRlZmluZWQ7XG4gIH1cbiAgZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xuICB9XG4gIGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xuICB9XG4gIGNvbnN0IHByb3h5VG9WYWx1ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gIGZ1bmN0aW9uIHJlZ2lzdGVyUHJveHkocHJveHksIHZhbHVlKSB7XG4gICAgICBwcm94eVRvVmFsdWVNYXAuc2V0KHByb3h5LCB2YWx1ZSk7XG4gIH1cbiAgY29uc3QgdW53cmFwID0gKHJlcGxpY2FPckFueSkgPT4gcHJveHlUb1ZhbHVlTWFwLmdldChyZXBsaWNhT3JBbnkpIHx8IHJlcGxpY2FPckFueTtcblxuICBmdW5jdGlvbiB3cmFwVmFsdWUobWVtYnJhbmUsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gbWVtYnJhbmUudmFsdWVJc09ic2VydmFibGUodmFsdWUpID8gbWVtYnJhbmUuZ2V0UHJveHkodmFsdWUpIDogdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFVud3JhcCBwcm9wZXJ0eSBkZXNjcmlwdG9ycyB3aWxsIHNldCB2YWx1ZSBvbiBvcmlnaW5hbCBkZXNjcmlwdG9yXG4gICAqIFdlIG9ubHkgbmVlZCB0byB1bndyYXAgaWYgdmFsdWUgaXMgc3BlY2lmaWVkXG4gICAqIEBwYXJhbSBkZXNjcmlwdG9yIGV4dGVybmFsIGRlc2NycGl0b3IgcHJvdmlkZWQgdG8gZGVmaW5lIG5ldyBwcm9wZXJ0eSBvbiBvcmlnaW5hbCB2YWx1ZVxuICAgKi9cbiAgZnVuY3Rpb24gdW53cmFwRGVzY3JpcHRvcihkZXNjcmlwdG9yKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChkZXNjcmlwdG9yLCAndmFsdWUnKSkge1xuICAgICAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSB1bndyYXAoZGVzY3JpcHRvci52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgfVxuICBmdW5jdGlvbiBsb2NrU2hhZG93VGFyZ2V0KG1lbWJyYW5lLCBzaGFkb3dUYXJnZXQsIG9yaWdpbmFsVGFyZ2V0KSB7XG4gICAgICBjb25zdCB0YXJnZXRLZXlzID0gQXJyYXlDb25jYXQuY2FsbChnZXRPd25Qcm9wZXJ0eU5hbWVzKG9yaWdpbmFsVGFyZ2V0KSwgZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9yaWdpbmFsVGFyZ2V0KSk7XG4gICAgICB0YXJnZXRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgIGxldCBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9yaWdpbmFsVGFyZ2V0LCBrZXkpO1xuICAgICAgICAgIC8vIFdlIGRvIG5vdCBuZWVkIHRvIHdyYXAgdGhlIGRlc2NyaXB0b3IgaWYgY29uZmlndXJhYmxlXG4gICAgICAgICAgLy8gQmVjYXVzZSB3ZSBjYW4gZGVhbCB3aXRoIHdyYXBwaW5nIGl0IHdoZW4gdXNlciBnb2VzIHRocm91Z2hcbiAgICAgICAgICAvLyBHZXQgb3duIHByb3BlcnR5IGRlc2NyaXB0b3IuIFRoZXJlIGlzIGFsc28gYSBjaGFuY2UgdGhhdCB0aGlzIGRlc2NyaXB0b3JcbiAgICAgICAgICAvLyBjb3VsZCBjaGFuZ2Ugc29tZXRpbWUgaW4gdGhlIGZ1dHVyZSwgc28gd2UgY2FuIGRlZmVyIHdyYXBwaW5nXG4gICAgICAgICAgLy8gdW50aWwgd2UgbmVlZCB0b1xuICAgICAgICAgIGlmICghZGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgICAgZGVzY3JpcHRvciA9IHdyYXBEZXNjcmlwdG9yKG1lbWJyYW5lLCBkZXNjcmlwdG9yLCB3cmFwVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBPYmplY3REZWZpbmVQcm9wZXJ0eShzaGFkb3dUYXJnZXQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICB9KTtcbiAgICAgIHByZXZlbnRFeHRlbnNpb25zKHNoYWRvd1RhcmdldCk7XG4gIH1cbiAgY2xhc3MgUmVhY3RpdmVQcm94eUhhbmRsZXIge1xuICAgICAgY29uc3RydWN0b3IobWVtYnJhbmUsIHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5vcmlnaW5hbFRhcmdldCA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMubWVtYnJhbmUgPSBtZW1icmFuZTtcbiAgICAgIH1cbiAgICAgIGdldChzaGFkb3dUYXJnZXQsIGtleSkge1xuICAgICAgICAgIGNvbnN0IHsgb3JpZ2luYWxUYXJnZXQsIG1lbWJyYW5lIH0gPSB0aGlzO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gb3JpZ2luYWxUYXJnZXRba2V5XTtcbiAgICAgICAgICBjb25zdCB7IHZhbHVlT2JzZXJ2ZWQgfSA9IG1lbWJyYW5lO1xuICAgICAgICAgIHZhbHVlT2JzZXJ2ZWQob3JpZ2luYWxUYXJnZXQsIGtleSk7XG4gICAgICAgICAgcmV0dXJuIG1lbWJyYW5lLmdldFByb3h5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHNldChzaGFkb3dUYXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsVGFyZ2V0LCBtZW1icmFuZTogeyB2YWx1ZU11dGF0ZWQgfSB9ID0gdGhpcztcbiAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IG9yaWdpbmFsVGFyZ2V0W2tleV07XG4gICAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICBvcmlnaW5hbFRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgIHZhbHVlTXV0YXRlZChvcmlnaW5hbFRhcmdldCwga2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnbGVuZ3RoJyAmJiBpc0FycmF5KG9yaWdpbmFsVGFyZ2V0KSkge1xuICAgICAgICAgICAgICAvLyBmaXggZm9yIGlzc3VlICMyMzY6IHB1c2ggd2lsbCBhZGQgdGhlIG5ldyBpbmRleCwgYW5kIGJ5IHRoZSB0aW1lIGxlbmd0aFxuICAgICAgICAgICAgICAvLyBpcyB1cGRhdGVkLCB0aGUgaW50ZXJuYWwgbGVuZ3RoIGlzIGFscmVhZHkgZXF1YWwgdG8gdGhlIG5ldyBsZW5ndGggdmFsdWVcbiAgICAgICAgICAgICAgLy8gdGhlcmVmb3JlLCB0aGUgb2xkVmFsdWUgaXMgZXF1YWwgdG8gdGhlIHZhbHVlLiBUaGlzIGlzIHRoZSBmb3JraW5nIGxvZ2ljXG4gICAgICAgICAgICAgIC8vIHRvIHN1cHBvcnQgdGhpcyB1c2UgY2FzZS5cbiAgICAgICAgICAgICAgdmFsdWVNdXRhdGVkKG9yaWdpbmFsVGFyZ2V0LCBrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZVByb3BlcnR5KHNoYWRvd1RhcmdldCwga2V5KSB7XG4gICAgICAgICAgY29uc3QgeyBvcmlnaW5hbFRhcmdldCwgbWVtYnJhbmU6IHsgdmFsdWVNdXRhdGVkIH0gfSA9IHRoaXM7XG4gICAgICAgICAgZGVsZXRlIG9yaWdpbmFsVGFyZ2V0W2tleV07XG4gICAgICAgICAgdmFsdWVNdXRhdGVkKG9yaWdpbmFsVGFyZ2V0LCBrZXkpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgYXBwbHkoc2hhZG93VGFyZ2V0LCB0aGlzQXJnLCBhcmdBcnJheSkge1xuICAgICAgICAgIC8qIE5vIG9wICovXG4gICAgICB9XG4gICAgICBjb25zdHJ1Y3QodGFyZ2V0LCBhcmdBcnJheSwgbmV3VGFyZ2V0KSB7XG4gICAgICAgICAgLyogTm8gb3AgKi9cbiAgICAgIH1cbiAgICAgIGhhcyhzaGFkb3dUYXJnZXQsIGtleSkge1xuICAgICAgICAgIGNvbnN0IHsgb3JpZ2luYWxUYXJnZXQsIG1lbWJyYW5lOiB7IHZhbHVlT2JzZXJ2ZWQgfSB9ID0gdGhpcztcbiAgICAgICAgICB2YWx1ZU9ic2VydmVkKG9yaWdpbmFsVGFyZ2V0LCBrZXkpO1xuICAgICAgICAgIHJldHVybiBrZXkgaW4gb3JpZ2luYWxUYXJnZXQ7XG4gICAgICB9XG4gICAgICBvd25LZXlzKHNoYWRvd1RhcmdldCkge1xuICAgICAgICAgIGNvbnN0IHsgb3JpZ2luYWxUYXJnZXQgfSA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIEFycmF5Q29uY2F0LmNhbGwoZ2V0T3duUHJvcGVydHlOYW1lcyhvcmlnaW5hbFRhcmdldCksIGdldE93blByb3BlcnR5U3ltYm9scyhvcmlnaW5hbFRhcmdldCkpO1xuICAgICAgfVxuICAgICAgaXNFeHRlbnNpYmxlKHNoYWRvd1RhcmdldCkge1xuICAgICAgICAgIGNvbnN0IHNoYWRvd0lzRXh0ZW5zaWJsZSA9IGlzRXh0ZW5zaWJsZShzaGFkb3dUYXJnZXQpO1xuICAgICAgICAgIGlmICghc2hhZG93SXNFeHRlbnNpYmxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzaGFkb3dJc0V4dGVuc2libGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHsgb3JpZ2luYWxUYXJnZXQsIG1lbWJyYW5lIH0gPSB0aGlzO1xuICAgICAgICAgIGNvbnN0IHRhcmdldElzRXh0ZW5zaWJsZSA9IGlzRXh0ZW5zaWJsZShvcmlnaW5hbFRhcmdldCk7XG4gICAgICAgICAgaWYgKCF0YXJnZXRJc0V4dGVuc2libGUpIHtcbiAgICAgICAgICAgICAgbG9ja1NoYWRvd1RhcmdldChtZW1icmFuZSwgc2hhZG93VGFyZ2V0LCBvcmlnaW5hbFRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0YXJnZXRJc0V4dGVuc2libGU7XG4gICAgICB9XG4gICAgICBzZXRQcm90b3R5cGVPZihzaGFkb3dUYXJnZXQsIHByb3RvdHlwZSkge1xuICAgICAgfVxuICAgICAgZ2V0UHJvdG90eXBlT2Yoc2hhZG93VGFyZ2V0KSB7XG4gICAgICAgICAgY29uc3QgeyBvcmlnaW5hbFRhcmdldCB9ID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWxUYXJnZXQpO1xuICAgICAgfVxuICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNoYWRvd1RhcmdldCwga2V5KSB7XG4gICAgICAgICAgY29uc3QgeyBvcmlnaW5hbFRhcmdldCwgbWVtYnJhbmUgfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3QgeyB2YWx1ZU9ic2VydmVkIH0gPSB0aGlzLm1lbWJyYW5lO1xuICAgICAgICAgIC8vIGtleXMgbG9va2VkIHVwIHZpYSBoYXNPd25Qcm9wZXJ0eSBuZWVkIHRvIGJlIHJlYWN0aXZlXG4gICAgICAgICAgdmFsdWVPYnNlcnZlZChvcmlnaW5hbFRhcmdldCwga2V5KTtcbiAgICAgICAgICBsZXQgZGVzYyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvcmlnaW5hbFRhcmdldCwga2V5KTtcbiAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoZGVzYykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNoYWRvd0Rlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc2hhZG93VGFyZ2V0LCBrZXkpO1xuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoc2hhZG93RGVzY3JpcHRvcikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNoYWRvd0Rlc2NyaXB0b3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5vdGU6IGJ5IGFjY2Vzc2luZyB0aGUgZGVzY3JpcHRvciwgdGhlIGtleSBpcyBtYXJrZWQgYXMgb2JzZXJ2ZWRcbiAgICAgICAgICAvLyBidXQgYWNjZXNzIHRvIHRoZSB2YWx1ZSwgc2V0dGVyIG9yIGdldHRlciAoaWYgYXZhaWxhYmxlKSBjYW5ub3Qgb2JzZXJ2ZVxuICAgICAgICAgIC8vIG11dGF0aW9ucywganVzdCBsaWtlIHJlZ3VsYXIgbWV0aG9kcywgaW4gd2hpY2ggY2FzZSB3ZSBqdXN0IGRvIG5vdGhpbmcuXG4gICAgICAgICAgZGVzYyA9IHdyYXBEZXNjcmlwdG9yKG1lbWJyYW5lLCBkZXNjLCB3cmFwVmFsdWUpO1xuICAgICAgICAgIGlmICghZGVzYy5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgICAgLy8gSWYgZGVzY3JpcHRvciBmcm9tIG9yaWdpbmFsIHRhcmdldCBpcyBub3QgY29uZmlndXJhYmxlLFxuICAgICAgICAgICAgICAvLyBXZSBtdXN0IGNvcHkgdGhlIHdyYXBwZWQgZGVzY3JpcHRvciBvdmVyIHRvIHRoZSBzaGFkb3cgdGFyZ2V0LlxuICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHByb3h5IHdpbGwgdGhyb3cgYW4gaW52YXJpYW50IGVycm9yLlxuICAgICAgICAgICAgICAvLyBUaGlzIGlzIG91ciBsYXN0IGNoYW5jZSB0byBsb2NrIHRoZSB2YWx1ZS5cbiAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJveHkvaGFuZGxlci9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IjSW52YXJpYW50c1xuICAgICAgICAgICAgICBPYmplY3REZWZpbmVQcm9wZXJ0eShzaGFkb3dUYXJnZXQsIGtleSwgZGVzYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkZXNjO1xuICAgICAgfVxuICAgICAgcHJldmVudEV4dGVuc2lvbnMoc2hhZG93VGFyZ2V0KSB7XG4gICAgICAgICAgY29uc3QgeyBvcmlnaW5hbFRhcmdldCwgbWVtYnJhbmUgfSA9IHRoaXM7XG4gICAgICAgICAgbG9ja1NoYWRvd1RhcmdldChtZW1icmFuZSwgc2hhZG93VGFyZ2V0LCBvcmlnaW5hbFRhcmdldCk7XG4gICAgICAgICAgcHJldmVudEV4dGVuc2lvbnMob3JpZ2luYWxUYXJnZXQpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZGVmaW5lUHJvcGVydHkoc2hhZG93VGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsVGFyZ2V0LCBtZW1icmFuZSB9ID0gdGhpcztcbiAgICAgICAgICBjb25zdCB7IHZhbHVlTXV0YXRlZCB9ID0gbWVtYnJhbmU7XG4gICAgICAgICAgY29uc3QgeyBjb25maWd1cmFibGUgfSA9IGRlc2NyaXB0b3I7XG4gICAgICAgICAgLy8gV2UgaGF2ZSB0byBjaGVjayBmb3IgdmFsdWUgaW4gZGVzY3JpcHRvclxuICAgICAgICAgIC8vIGJlY2F1c2UgT2JqZWN0LmZyZWV6ZShwcm94eSkgY2FsbHMgdGhpcyBtZXRob2RcbiAgICAgICAgICAvLyB3aXRoIG9ubHkgeyBjb25maWd1cmFibGU6IGZhbHNlLCB3cml0ZWFibGU6IGZhbHNlIH1cbiAgICAgICAgICAvLyBBZGRpdGlvbmFsbHksIG1ldGhvZCB3aWxsIG9ubHkgYmUgY2FsbGVkIHdpdGggd3JpdGVhYmxlOmZhbHNlXG4gICAgICAgICAgLy8gaWYgdGhlIGRlc2NyaXB0b3IgaGFzIGEgdmFsdWUsIGFzIG9wcG9zZWQgdG8gZ2V0dGVyL3NldHRlclxuICAgICAgICAgIC8vIFNvIHdlIGNhbiBqdXN0IGNoZWNrIGlmIHdyaXRhYmxlIGlzIHByZXNlbnQgYW5kIHRoZW4gc2VlIGlmXG4gICAgICAgICAgLy8gdmFsdWUgaXMgcHJlc2VudC4gVGhpcyBlbGltaW5hdGVzIGdldHRlciBhbmQgc2V0dGVyIGRlc2NyaXB0b3JzXG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoZGVzY3JpcHRvciwgJ3dyaXRhYmxlJykgJiYgIWhhc093blByb3BlcnR5LmNhbGwoZGVzY3JpcHRvciwgJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9yaWdpbmFsVGFyZ2V0LCBrZXkpO1xuICAgICAgICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gb3JpZ2luYWxEZXNjcmlwdG9yLnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBPYmplY3REZWZpbmVQcm9wZXJ0eShvcmlnaW5hbFRhcmdldCwga2V5LCB1bndyYXBEZXNjcmlwdG9yKGRlc2NyaXB0b3IpKTtcbiAgICAgICAgICBpZiAoY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBPYmplY3REZWZpbmVQcm9wZXJ0eShzaGFkb3dUYXJnZXQsIGtleSwgd3JhcERlc2NyaXB0b3IobWVtYnJhbmUsIGRlc2NyaXB0b3IsIHdyYXBWYWx1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZU11dGF0ZWQob3JpZ2luYWxUYXJnZXQsIGtleSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwUmVhZE9ubHlWYWx1ZShtZW1icmFuZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBtZW1icmFuZS52YWx1ZUlzT2JzZXJ2YWJsZSh2YWx1ZSkgPyBtZW1icmFuZS5nZXRSZWFkT25seVByb3h5KHZhbHVlKSA6IHZhbHVlO1xuICB9XG4gIGNsYXNzIFJlYWRPbmx5SGFuZGxlciB7XG4gICAgICBjb25zdHJ1Y3RvcihtZW1icmFuZSwgdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLm9yaWdpbmFsVGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5tZW1icmFuZSA9IG1lbWJyYW5lO1xuICAgICAgfVxuICAgICAgZ2V0KHNoYWRvd1RhcmdldCwga2V5KSB7XG4gICAgICAgICAgY29uc3QgeyBtZW1icmFuZSwgb3JpZ2luYWxUYXJnZXQgfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBvcmlnaW5hbFRhcmdldFtrZXldO1xuICAgICAgICAgIGNvbnN0IHsgdmFsdWVPYnNlcnZlZCB9ID0gbWVtYnJhbmU7XG4gICAgICAgICAgdmFsdWVPYnNlcnZlZChvcmlnaW5hbFRhcmdldCwga2V5KTtcbiAgICAgICAgICByZXR1cm4gbWVtYnJhbmUuZ2V0UmVhZE9ubHlQcm94eSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBzZXQoc2hhZG93VGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZGVsZXRlUHJvcGVydHkoc2hhZG93VGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBhcHBseShzaGFkb3dUYXJnZXQsIHRoaXNBcmcsIGFyZ0FycmF5KSB7XG4gICAgICAgICAgLyogTm8gb3AgKi9cbiAgICAgIH1cbiAgICAgIGNvbnN0cnVjdCh0YXJnZXQsIGFyZ0FycmF5LCBuZXdUYXJnZXQpIHtcbiAgICAgICAgICAvKiBObyBvcCAqL1xuICAgICAgfVxuICAgICAgaGFzKHNoYWRvd1RhcmdldCwga2V5KSB7XG4gICAgICAgICAgY29uc3QgeyBvcmlnaW5hbFRhcmdldCwgbWVtYnJhbmU6IHsgdmFsdWVPYnNlcnZlZCB9IH0gPSB0aGlzO1xuICAgICAgICAgIHZhbHVlT2JzZXJ2ZWQob3JpZ2luYWxUYXJnZXQsIGtleSk7XG4gICAgICAgICAgcmV0dXJuIGtleSBpbiBvcmlnaW5hbFRhcmdldDtcbiAgICAgIH1cbiAgICAgIG93bktleXMoc2hhZG93VGFyZ2V0KSB7XG4gICAgICAgICAgY29uc3QgeyBvcmlnaW5hbFRhcmdldCB9ID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gQXJyYXlDb25jYXQuY2FsbChnZXRPd25Qcm9wZXJ0eU5hbWVzKG9yaWdpbmFsVGFyZ2V0KSwgZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9yaWdpbmFsVGFyZ2V0KSk7XG4gICAgICB9XG4gICAgICBzZXRQcm90b3R5cGVPZihzaGFkb3dUYXJnZXQsIHByb3RvdHlwZSkge1xuICAgICAgfVxuICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNoYWRvd1RhcmdldCwga2V5KSB7XG4gICAgICAgICAgY29uc3QgeyBvcmlnaW5hbFRhcmdldCwgbWVtYnJhbmUgfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3QgeyB2YWx1ZU9ic2VydmVkIH0gPSBtZW1icmFuZTtcbiAgICAgICAgICAvLyBrZXlzIGxvb2tlZCB1cCB2aWEgaGFzT3duUHJvcGVydHkgbmVlZCB0byBiZSByZWFjdGl2ZVxuICAgICAgICAgIHZhbHVlT2JzZXJ2ZWQob3JpZ2luYWxUYXJnZXQsIGtleSk7XG4gICAgICAgICAgbGV0IGRlc2MgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3JpZ2luYWxUYXJnZXQsIGtleSk7XG4gICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGRlc2MpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkZXNjO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzaGFkb3dEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNoYWRvd1RhcmdldCwga2V5KTtcbiAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHNoYWRvd0Rlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzaGFkb3dEZXNjcmlwdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBOb3RlOiBieSBhY2Nlc3NpbmcgdGhlIGRlc2NyaXB0b3IsIHRoZSBrZXkgaXMgbWFya2VkIGFzIG9ic2VydmVkXG4gICAgICAgICAgLy8gYnV0IGFjY2VzcyB0byB0aGUgdmFsdWUgb3IgZ2V0dGVyIChpZiBhdmFpbGFibGUpIGNhbm5vdCBiZSBvYnNlcnZlZCxcbiAgICAgICAgICAvLyBqdXN0IGxpa2UgcmVndWxhciBtZXRob2RzLCBpbiB3aGljaCBjYXNlIHdlIGp1c3QgZG8gbm90aGluZy5cbiAgICAgICAgICBkZXNjID0gd3JhcERlc2NyaXB0b3IobWVtYnJhbmUsIGRlc2MsIHdyYXBSZWFkT25seVZhbHVlKTtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChkZXNjLCAnc2V0JykpIHtcbiAgICAgICAgICAgICAgZGVzYy5zZXQgPSB1bmRlZmluZWQ7IC8vIHJlYWRPbmx5IG1lbWJyYW5lIGRvZXMgbm90IGFsbG93IHNldHRlcnNcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFkZXNjLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICAgICAgICAvLyBJZiBkZXNjcmlwdG9yIGZyb20gb3JpZ2luYWwgdGFyZ2V0IGlzIG5vdCBjb25maWd1cmFibGUsXG4gICAgICAgICAgICAgIC8vIFdlIG11c3QgY29weSB0aGUgd3JhcHBlZCBkZXNjcmlwdG9yIG92ZXIgdG8gdGhlIHNoYWRvdyB0YXJnZXQuXG4gICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgcHJveHkgd2lsbCB0aHJvdyBhbiBpbnZhcmlhbnQgZXJyb3IuXG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgb3VyIGxhc3QgY2hhbmNlIHRvIGxvY2sgdGhlIHZhbHVlLlxuICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm94eS9oYW5kbGVyL2dldE93blByb3BlcnR5RGVzY3JpcHRvciNJbnZhcmlhbnRzXG4gICAgICAgICAgICAgIE9iamVjdERlZmluZVByb3BlcnR5KHNoYWRvd1RhcmdldCwga2V5LCBkZXNjKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICB9XG4gICAgICBwcmV2ZW50RXh0ZW5zaW9ucyhzaGFkb3dUYXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBkZWZpbmVQcm9wZXJ0eShzaGFkb3dUYXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVTaGFkb3dUYXJnZXQodmFsdWUpIHtcbiAgICAgIGxldCBzaGFkb3dUYXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBzaGFkb3dUYXJnZXQgPSBbXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgIHNoYWRvd1RhcmdldCA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNoYWRvd1RhcmdldDtcbiAgfVxuICBjb25zdCBPYmplY3REb3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuICBmdW5jdGlvbiBkZWZhdWx0VmFsdWVJc09ic2VydmFibGUodmFsdWUpIHtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgY2hlY2tpbmcgZm9yIG51bGxcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIHRyZWF0IGFsbCBub24tb2JqZWN0IHR5cGVzLCBpbmNsdWRpbmcgdW5kZWZpbmVkLCBhcyBub24tb2JzZXJ2YWJsZSB2YWx1ZXNcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm90byA9IGdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICAgIHJldHVybiAocHJvdG8gPT09IE9iamVjdERvdFByb3RvdHlwZSB8fCBwcm90byA9PT0gbnVsbCB8fCBnZXRQcm90b3R5cGVPZihwcm90bykgPT09IG51bGwpO1xuICB9XG4gIGNvbnN0IGRlZmF1bHRWYWx1ZU9ic2VydmVkID0gKG9iaiwga2V5KSA9PiB7XG4gICAgICAvKiBkbyBub3RoaW5nICovXG4gIH07XG4gIGNvbnN0IGRlZmF1bHRWYWx1ZU11dGF0ZWQgPSAob2JqLCBrZXkpID0+IHtcbiAgICAgIC8qIGRvIG5vdGhpbmcgKi9cbiAgfTtcbiAgY29uc3QgZGVmYXVsdFZhbHVlRGlzdG9ydGlvbiA9ICh2YWx1ZSkgPT4gdmFsdWU7XG4gIGZ1bmN0aW9uIHdyYXBEZXNjcmlwdG9yKG1lbWJyYW5lLCBkZXNjcmlwdG9yLCBnZXRWYWx1ZSkge1xuICAgICAgY29uc3QgeyBzZXQsIGdldCB9ID0gZGVzY3JpcHRvcjtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGRlc2NyaXB0b3IsICd2YWx1ZScpKSB7XG4gICAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IGdldFZhbHVlKG1lbWJyYW5lLCBkZXNjcmlwdG9yLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoZ2V0KSkge1xuICAgICAgICAgICAgICBkZXNjcmlwdG9yLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGludm9raW5nIHRoZSBvcmlnaW5hbCBnZXR0ZXIgd2l0aCB0aGUgb3JpZ2luYWwgdGFyZ2V0XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWUobWVtYnJhbmUsIGdldC5jYWxsKHVud3JhcCh0aGlzKSkpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHNldCkpIHtcbiAgICAgICAgICAgICAgZGVzY3JpcHRvci5zZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgZG9uJ3QgaGF2ZSBhIGNsZWFyIGluZGljYXRpb24gb2Ygd2hldGhlclxuICAgICAgICAgICAgICAgICAgLy8gb3Igbm90IGEgdmFsaWQgbXV0YXRpb24gd2lsbCBvY2N1ciwgd2UgZG9uJ3QgaGF2ZSB0aGUga2V5LFxuICAgICAgICAgICAgICAgICAgLy8gYW5kIHdlIGFyZSBub3Qgc3VyZSB3aHkgYW5kIGhvdyB0aGV5IGFyZSBpbnZva2luZyB0aGlzIHNldHRlci5cbiAgICAgICAgICAgICAgICAgIC8vIE5ldmVydGhlbGVzcyB3ZSBwcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgc2VtYW50aWNzIGJ5IGludm9raW5nIHRoZVxuICAgICAgICAgICAgICAgICAgLy8gb3JpZ2luYWwgc2V0dGVyIHdpdGggdGhlIG9yaWdpbmFsIHRhcmdldCBhbmQgdGhlIHVud3JhcHBlZCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgc2V0LmNhbGwodW53cmFwKHRoaXMpLCBtZW1icmFuZS51bndyYXBQcm94eSh2YWx1ZSkpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICB9XG4gIGNsYXNzIFJlYWN0aXZlTWVtYnJhbmUge1xuICAgICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICAgIHRoaXMudmFsdWVEaXN0b3J0aW9uID0gZGVmYXVsdFZhbHVlRGlzdG9ydGlvbjtcbiAgICAgICAgICB0aGlzLnZhbHVlTXV0YXRlZCA9IGRlZmF1bHRWYWx1ZU11dGF0ZWQ7XG4gICAgICAgICAgdGhpcy52YWx1ZU9ic2VydmVkID0gZGVmYXVsdFZhbHVlT2JzZXJ2ZWQ7XG4gICAgICAgICAgdGhpcy52YWx1ZUlzT2JzZXJ2YWJsZSA9IGRlZmF1bHRWYWx1ZUlzT2JzZXJ2YWJsZTtcbiAgICAgICAgICB0aGlzLm9iamVjdEdyYXBoID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWVEaXN0b3J0aW9uLCB2YWx1ZU11dGF0ZWQsIHZhbHVlT2JzZXJ2ZWQsIHZhbHVlSXNPYnNlcnZhYmxlIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgICB0aGlzLnZhbHVlRGlzdG9ydGlvbiA9IGlzRnVuY3Rpb24odmFsdWVEaXN0b3J0aW9uKSA/IHZhbHVlRGlzdG9ydGlvbiA6IGRlZmF1bHRWYWx1ZURpc3RvcnRpb247XG4gICAgICAgICAgICAgIHRoaXMudmFsdWVNdXRhdGVkID0gaXNGdW5jdGlvbih2YWx1ZU11dGF0ZWQpID8gdmFsdWVNdXRhdGVkIDogZGVmYXVsdFZhbHVlTXV0YXRlZDtcbiAgICAgICAgICAgICAgdGhpcy52YWx1ZU9ic2VydmVkID0gaXNGdW5jdGlvbih2YWx1ZU9ic2VydmVkKSA/IHZhbHVlT2JzZXJ2ZWQgOiBkZWZhdWx0VmFsdWVPYnNlcnZlZDtcbiAgICAgICAgICAgICAgdGhpcy52YWx1ZUlzT2JzZXJ2YWJsZSA9IGlzRnVuY3Rpb24odmFsdWVJc09ic2VydmFibGUpID8gdmFsdWVJc09ic2VydmFibGUgOiBkZWZhdWx0VmFsdWVJc09ic2VydmFibGU7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2V0UHJveHkodmFsdWUpIHtcbiAgICAgICAgICBjb25zdCB1bndyYXBwZWRWYWx1ZSA9IHVud3JhcCh2YWx1ZSk7XG4gICAgICAgICAgY29uc3QgZGlzdG9ydGVkID0gdGhpcy52YWx1ZURpc3RvcnRpb24odW53cmFwcGVkVmFsdWUpO1xuICAgICAgICAgIGlmICh0aGlzLnZhbHVlSXNPYnNlcnZhYmxlKGRpc3RvcnRlZCkpIHtcbiAgICAgICAgICAgICAgY29uc3QgbyA9IHRoaXMuZ2V0UmVhY3RpdmVTdGF0ZSh1bndyYXBwZWRWYWx1ZSwgZGlzdG9ydGVkKTtcbiAgICAgICAgICAgICAgLy8gd2hlbiB0cnlpbmcgdG8gZXh0cmFjdCB0aGUgd3JpdGFibGUgdmVyc2lvbiBvZiBhIHJlYWRvbmx5XG4gICAgICAgICAgICAgIC8vIHdlIHJldHVybiB0aGUgcmVhZG9ubHkuXG4gICAgICAgICAgICAgIHJldHVybiBvLnJlYWRPbmx5ID09PSB2YWx1ZSA/IHZhbHVlIDogby5yZWFjdGl2ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRpc3RvcnRlZDtcbiAgICAgIH1cbiAgICAgIGdldFJlYWRPbmx5UHJveHkodmFsdWUpIHtcbiAgICAgICAgICB2YWx1ZSA9IHVud3JhcCh2YWx1ZSk7XG4gICAgICAgICAgY29uc3QgZGlzdG9ydGVkID0gdGhpcy52YWx1ZURpc3RvcnRpb24odmFsdWUpO1xuICAgICAgICAgIGlmICh0aGlzLnZhbHVlSXNPYnNlcnZhYmxlKGRpc3RvcnRlZCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVhY3RpdmVTdGF0ZSh2YWx1ZSwgZGlzdG9ydGVkKS5yZWFkT25seTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRpc3RvcnRlZDtcbiAgICAgIH1cbiAgICAgIHVud3JhcFByb3h5KHApIHtcbiAgICAgICAgICByZXR1cm4gdW53cmFwKHApO1xuICAgICAgfVxuICAgICAgZ2V0UmVhY3RpdmVTdGF0ZSh2YWx1ZSwgZGlzdG9ydGVkVmFsdWUpIHtcbiAgICAgICAgICBjb25zdCB7IG9iamVjdEdyYXBoLCB9ID0gdGhpcztcbiAgICAgICAgICBsZXQgcmVhY3RpdmVTdGF0ZSA9IG9iamVjdEdyYXBoLmdldChkaXN0b3J0ZWRWYWx1ZSk7XG4gICAgICAgICAgaWYgKHJlYWN0aXZlU3RhdGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlYWN0aXZlU3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG1lbWJyYW5lID0gdGhpcztcbiAgICAgICAgICByZWFjdGl2ZVN0YXRlID0ge1xuICAgICAgICAgICAgICBnZXQgcmVhY3RpdmUoKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCByZWFjdGl2ZUhhbmRsZXIgPSBuZXcgUmVhY3RpdmVQcm94eUhhbmRsZXIobWVtYnJhbmUsIGRpc3RvcnRlZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIC8vIGNhY2hpbmcgdGhlIHJlYWN0aXZlIHByb3h5IGFmdGVyIHRoZSBmaXJzdCB0aW1lIGl0IGlzIGFjY2Vzc2VkXG4gICAgICAgICAgICAgICAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShjcmVhdGVTaGFkb3dUYXJnZXQoZGlzdG9ydGVkVmFsdWUpLCByZWFjdGl2ZUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJQcm94eShwcm94eSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgT2JqZWN0RGVmaW5lUHJvcGVydHkodGhpcywgJ3JlYWN0aXZlJywgeyB2YWx1ZTogcHJveHkgfSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcHJveHk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGdldCByZWFkT25seSgpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRPbmx5SGFuZGxlciA9IG5ldyBSZWFkT25seUhhbmRsZXIobWVtYnJhbmUsIGRpc3RvcnRlZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIC8vIGNhY2hpbmcgdGhlIHJlYWRPbmx5IHByb3h5IGFmdGVyIHRoZSBmaXJzdCB0aW1lIGl0IGlzIGFjY2Vzc2VkXG4gICAgICAgICAgICAgICAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShjcmVhdGVTaGFkb3dUYXJnZXQoZGlzdG9ydGVkVmFsdWUpLCByZWFkT25seUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJQcm94eShwcm94eSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgT2JqZWN0RGVmaW5lUHJvcGVydHkodGhpcywgJ3JlYWRPbmx5JywgeyB2YWx1ZTogcHJveHkgfSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcHJveHk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIG9iamVjdEdyYXBoLnNldChkaXN0b3J0ZWRWYWx1ZSwgcmVhY3RpdmVTdGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIHJlYWN0aXZlU3RhdGU7XG4gICAgICB9XG4gIH1cbiAgLyoqIHZlcnNpb246IDAuMjYuMCAqL1xuXG4gIGZ1bmN0aW9uIHdyYXAoZGF0YSwgbXV0YXRpb25DYWxsYmFjaykge1xuXG4gICAgbGV0IG1lbWJyYW5lID0gbmV3IFJlYWN0aXZlTWVtYnJhbmUoe1xuICAgICAgdmFsdWVNdXRhdGVkKHRhcmdldCwga2V5KSB7XG4gICAgICAgIG11dGF0aW9uQ2FsbGJhY2sodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IG1lbWJyYW5lLmdldFByb3h5KGRhdGEpLFxuICAgICAgbWVtYnJhbmU6IG1lbWJyYW5lXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB1bndyYXAkMShtZW1icmFuZSwgb2JzZXJ2YWJsZSkge1xuICAgIGxldCB1bndyYXBwZWREYXRhID0gbWVtYnJhbmUudW53cmFwUHJveHkob2JzZXJ2YWJsZSk7XG4gICAgbGV0IGNvcHkgPSB7fTtcbiAgICBPYmplY3Qua2V5cyh1bndyYXBwZWREYXRhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBpZiAoWyckZWwnLCAnJHJlZnMnLCAnJG5leHRUaWNrJywgJyR3YXRjaCddLmluY2x1ZGVzKGtleSkpIHJldHVybjtcbiAgICAgIGNvcHlba2V5XSA9IHVud3JhcHBlZERhdGFba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29weTtcbiAgfVxuXG4gIGNsYXNzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWwsIGNvbXBvbmVudEZvckNsb25lID0gbnVsbCkge1xuICAgICAgdGhpcy4kZWwgPSBlbDtcbiAgICAgIGNvbnN0IGRhdGFBdHRyID0gdGhpcy4kZWwuZ2V0QXR0cmlidXRlKCd4LWRhdGEnKTtcbiAgICAgIGNvbnN0IGRhdGFFeHByZXNzaW9uID0gZGF0YUF0dHIgPT09ICcnID8gJ3t9JyA6IGRhdGFBdHRyO1xuICAgICAgY29uc3QgaW5pdEV4cHJlc3Npb24gPSB0aGlzLiRlbC5nZXRBdHRyaWJ1dGUoJ3gtaW5pdCcpO1xuICAgICAgbGV0IGRhdGFFeHRyYXMgPSB7XG4gICAgICAgICRlbDogdGhpcy4kZWxcbiAgICAgIH07XG4gICAgICBsZXQgY2Fub25pY2FsQ29tcG9uZW50RWxlbWVudFJlZmVyZW5jZSA9IGNvbXBvbmVudEZvckNsb25lID8gY29tcG9uZW50Rm9yQ2xvbmUuJGVsIDogdGhpcy4kZWw7XG4gICAgICBPYmplY3QuZW50cmllcyhBbHBpbmUubWFnaWNQcm9wZXJ0aWVzKS5mb3JFYWNoKChbbmFtZSwgY2FsbGJhY2tdKSA9PiB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhRXh0cmFzLCBgJCR7bmFtZX1gLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2Fub25pY2FsQ29tcG9uZW50RWxlbWVudFJlZmVyZW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy51bm9ic2VydmVkRGF0YSA9IGNvbXBvbmVudEZvckNsb25lID8gY29tcG9uZW50Rm9yQ2xvbmUuZ2V0VW5vYnNlcnZlZERhdGEoKSA6IHNhZmVyRXZhbChlbCwgZGF0YUV4cHJlc3Npb24sIGRhdGFFeHRyYXMpO1xuICAgICAgLy8gQ29uc3RydWN0IGEgUHJveHktYmFzZWQgb2JzZXJ2YWJsZS4gVGhpcyB3aWxsIGJlIHVzZWQgdG8gaGFuZGxlIHJlYWN0aXZpdHkuXG5cbiAgICAgIGxldCB7XG4gICAgICAgIG1lbWJyYW5lLFxuICAgICAgICBkYXRhXG4gICAgICB9ID0gdGhpcy53cmFwRGF0YUluT2JzZXJ2YWJsZSh0aGlzLnVub2JzZXJ2ZWREYXRhKTtcbiAgICAgIHRoaXMuJGRhdGEgPSBkYXRhO1xuICAgICAgdGhpcy5tZW1icmFuZSA9IG1lbWJyYW5lOyAvLyBBZnRlciBtYWtpbmcgdXNlci1zdXBwbGllZCBkYXRhIG1ldGhvZHMgcmVhY3RpdmUsIHdlIGNhbiBub3cgYWRkXG4gICAgICAvLyBvdXIgbWFnaWMgcHJvcGVydGllcyB0byB0aGUgb3JpZ2luYWwgZGF0YSBmb3IgYWNjZXNzLlxuXG4gICAgICB0aGlzLnVub2JzZXJ2ZWREYXRhLiRlbCA9IHRoaXMuJGVsO1xuICAgICAgdGhpcy51bm9ic2VydmVkRGF0YS4kcmVmcyA9IHRoaXMuZ2V0UmVmc1Byb3h5KCk7XG4gICAgICB0aGlzLm5leHRUaWNrU3RhY2sgPSBbXTtcblxuICAgICAgdGhpcy51bm9ic2VydmVkRGF0YS4kbmV4dFRpY2sgPSBjYWxsYmFjayA9PiB7XG4gICAgICAgIHRoaXMubmV4dFRpY2tTdGFjay5wdXNoKGNhbGxiYWNrKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMud2F0Y2hlcnMgPSB7fTtcblxuICAgICAgdGhpcy51bm9ic2VydmVkRGF0YS4kd2F0Y2ggPSAocHJvcGVydHksIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy53YXRjaGVyc1twcm9wZXJ0eV0pIHRoaXMud2F0Y2hlcnNbcHJvcGVydHldID0gW107XG4gICAgICAgIHRoaXMud2F0Y2hlcnNbcHJvcGVydHldLnB1c2goY2FsbGJhY2spO1xuICAgICAgfTtcbiAgICAgIC8qIE1PREVSTi1PTkxZOlNUQVJUICovXG4gICAgICAvLyBXZSByZW1vdmUgdGhpcyBwaWVjZSBvZiBjb2RlIGZyb20gdGhlIGxlZ2FjeSBidWlsZC5cbiAgICAgIC8vIEluIElFMTEsIHdlIGhhdmUgYWxyZWFkeSBkZWZpbmVkIG91ciBoZWxwZXJzIGF0IHRoaXMgcG9pbnQuXG4gICAgICAvLyBSZWdpc3RlciBjdXN0b20gbWFnaWMgcHJvcGVydGllcy5cblxuXG4gICAgICBPYmplY3QuZW50cmllcyhBbHBpbmUubWFnaWNQcm9wZXJ0aWVzKS5mb3JFYWNoKChbbmFtZSwgY2FsbGJhY2tdKSA9PiB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnVub2JzZXJ2ZWREYXRhLCBgJCR7bmFtZX1gLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2Fub25pY2FsQ29tcG9uZW50RWxlbWVudFJlZmVyZW5jZSwgdGhpcy4kZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8qIE1PREVSTi1PTkxZOkVORCAqL1xuXG4gICAgICB0aGlzLnNob3dEaXJlY3RpdmVTdGFjayA9IFtdO1xuICAgICAgdGhpcy5zaG93RGlyZWN0aXZlTGFzdEVsZW1lbnQ7XG4gICAgICBjb21wb25lbnRGb3JDbG9uZSB8fCBBbHBpbmUub25CZWZvcmVDb21wb25lbnRJbml0aWFsaXplZHMuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayh0aGlzKSk7XG4gICAgICB2YXIgaW5pdFJldHVybmVkQ2FsbGJhY2s7IC8vIElmIHgtaW5pdCBpcyBwcmVzZW50IEFORCB3ZSBhcmVuJ3QgY2xvbmluZyAoc2tpcCB4LWluaXQgb24gY2xvbmUpXG5cbiAgICAgIGlmIChpbml0RXhwcmVzc2lvbiAmJiAhY29tcG9uZW50Rm9yQ2xvbmUpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBhbGxvdyBkYXRhIG1hbmlwdWxhdGlvbiwgYnV0IG5vdCB0cmlnZ2VyIERPTSB1cGRhdGVzIGp1c3QgeWV0LlxuICAgICAgICAvLyBXZSBoYXZlbid0IGV2ZW4gaW5pdGlhbGl6ZWQgdGhlIGVsZW1lbnRzIHdpdGggdGhlaXIgQWxwaW5lIGJpbmRpbmdzLiBJIG1lYW4gYydtb24uXG4gICAgICAgIHRoaXMucGF1c2VSZWFjdGl2aXR5ID0gdHJ1ZTtcbiAgICAgICAgaW5pdFJldHVybmVkQ2FsbGJhY2sgPSB0aGlzLmV2YWx1YXRlUmV0dXJuRXhwcmVzc2lvbih0aGlzLiRlbCwgaW5pdEV4cHJlc3Npb24pO1xuICAgICAgICB0aGlzLnBhdXNlUmVhY3Rpdml0eSA9IGZhbHNlO1xuICAgICAgfSAvLyBSZWdpc3RlciBhbGwgb3VyIGxpc3RlbmVycyBhbmQgc2V0IGFsbCBvdXIgYXR0cmlidXRlIGJpbmRpbmdzLlxuICAgICAgLy8gSWYgd2UncmUgY2xvbmluZyBhIGNvbXBvbmVudCwgdGhlIHRoaXJkIHBhcmFtZXRlciBlbnN1cmVzIG5vIGR1cGxpY2F0ZVxuICAgICAgLy8gZXZlbnQgbGlzdGVuZXJzIGFyZSByZWdpc3RlcmVkICh0aGUgbXV0YXRpb24gb2JzZXJ2ZXIgd2lsbCB0YWtlIGNhcmUgb2YgdGhlbSlcblxuXG4gICAgICB0aGlzLmluaXRpYWxpemVFbGVtZW50cyh0aGlzLiRlbCwgKCkgPT4ge30sIGNvbXBvbmVudEZvckNsb25lKTsgLy8gVXNlIG11dGF0aW9uIG9ic2VydmVyIHRvIGRldGVjdCBuZXcgZWxlbWVudHMgYmVpbmcgYWRkZWQgd2l0aGluIHRoaXMgY29tcG9uZW50IGF0IHJ1bi10aW1lLlxuICAgICAgLy8gQWxwaW5lJ3MganVzdCBzbyBkYXJuIGZsZXhpYmxlIGFtaXJpdGU/XG5cbiAgICAgIHRoaXMubGlzdGVuRm9yTmV3RWxlbWVudHNUb0luaXRpYWxpemUoKTtcblxuICAgICAgaWYgKHR5cGVvZiBpbml0UmV0dXJuZWRDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBSdW4gdGhlIGNhbGxiYWNrIHJldHVybmVkIGZyb20gdGhlIFwieC1pbml0XCIgaG9vayB0byBhbGxvdyB0aGUgdXNlciB0byBkbyBzdHVmZiBhZnRlclxuICAgICAgICAvLyBBbHBpbmUncyBnb3QgaXQncyBncnViYnkgbGl0dGxlIHBhd3MgYWxsIG92ZXIgZXZlcnl0aGluZy5cbiAgICAgICAgaW5pdFJldHVybmVkQ2FsbGJhY2suY2FsbCh0aGlzLiRkYXRhKTtcbiAgICAgIH1cblxuICAgICAgY29tcG9uZW50Rm9yQ2xvbmUgfHwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIEFscGluZS5vbkNvbXBvbmVudEluaXRpYWxpemVkcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKHRoaXMpKTtcbiAgICAgIH0sIDApO1xuICAgIH1cblxuICAgIGdldFVub2JzZXJ2ZWREYXRhKCkge1xuICAgICAgcmV0dXJuIHVud3JhcCQxKHRoaXMubWVtYnJhbmUsIHRoaXMuJGRhdGEpO1xuICAgIH1cblxuICAgIHdyYXBEYXRhSW5PYnNlcnZhYmxlKGRhdGEpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIGxldCB1cGRhdGVEb20gPSBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYudXBkYXRlRWxlbWVudHMoc2VsZi4kZWwpO1xuICAgICAgfSwgMCk7XG4gICAgICByZXR1cm4gd3JhcChkYXRhLCAodGFyZ2V0LCBrZXkpID0+IHtcbiAgICAgICAgaWYgKHNlbGYud2F0Y2hlcnNba2V5XSkge1xuICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSB3YXRjaGVyIGZvciB0aGlzIHNwZWNpZmljIGtleSwgcnVuIGl0LlxuICAgICAgICAgIHNlbGYud2F0Y2hlcnNba2V5XS5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKHRhcmdldFtrZXldKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgLy8gQXJyYXlzIGFyZSBzcGVjaWFsIGNhc2VzLCBpZiBhbnkgb2YgdGhlIGl0ZW1zIGNoYW5nZSwgd2UgY29uc2lkZXIgdGhlIGFycmF5IGFzIG11dGF0ZWQuXG4gICAgICAgICAgT2JqZWN0LmtleXMoc2VsZi53YXRjaGVycykuZm9yRWFjaChmdWxsRG90Tm90YXRpb25LZXkgPT4ge1xuICAgICAgICAgICAgbGV0IGRvdE5vdGF0aW9uUGFydHMgPSBmdWxsRG90Tm90YXRpb25LZXkuc3BsaXQoJy4nKTsgLy8gSWdub3JlIGxlbmd0aCBtdXRhdGlvbnMgc2luY2UgdGhleSB3b3VsZCByZXN1bHQgaW4gZHVwbGljYXRlIGNhbGxzLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIHdoZW4gY2FsbGluZyBwdXNoLCB3ZSB3b3VsZCBnZXQgYSBtdXRhdGlvbiBmb3IgdGhlIGl0ZW0ncyBrZXlcbiAgICAgICAgICAgIC8vIGFuZCBhIHNlY29uZCBtdXRhdGlvbiBmb3IgdGhlIGxlbmd0aCBwcm9wZXJ0eS5cblxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2xlbmd0aCcpIHJldHVybjtcbiAgICAgICAgICAgIGRvdE5vdGF0aW9uUGFydHMucmVkdWNlKChjb21wYXJpc29uRGF0YSwgcGFydCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoT2JqZWN0LmlzKHRhcmdldCwgY29tcGFyaXNvbkRhdGFbcGFydF0pKSB7XG4gICAgICAgICAgICAgICAgc2VsZi53YXRjaGVyc1tmdWxsRG90Tm90YXRpb25LZXldLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2sodGFyZ2V0KSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbkRhdGFbcGFydF07XG4gICAgICAgICAgICB9LCBzZWxmLnVub2JzZXJ2ZWREYXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBMZXQncyB3YWxrIHRocm91Z2ggdGhlIHdhdGNoZXJzIHdpdGggXCJkb3Qtbm90YXRpb25cIiAoZm9vLmJhcikgYW5kIHNlZVxuICAgICAgICAgIC8vIGlmIHRoaXMgbXV0YXRpb24gZml0cyBhbnkgb2YgdGhlbS5cbiAgICAgICAgICBPYmplY3Qua2V5cyhzZWxmLndhdGNoZXJzKS5maWx0ZXIoaSA9PiBpLmluY2x1ZGVzKCcuJykpLmZvckVhY2goZnVsbERvdE5vdGF0aW9uS2V5ID0+IHtcbiAgICAgICAgICAgIGxldCBkb3ROb3RhdGlvblBhcnRzID0gZnVsbERvdE5vdGF0aW9uS2V5LnNwbGl0KCcuJyk7IC8vIElmIHRoaXMgZG90LW5vdGF0aW9uIHdhdGNoZXIncyBsYXN0IFwicGFydFwiIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnRcbiAgICAgICAgICAgIC8vIGtleSwgdGhlbiBza2lwIGl0IGVhcmx5IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLlxuXG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBkb3ROb3RhdGlvblBhcnRzW2RvdE5vdGF0aW9uUGFydHMubGVuZ3RoIC0gMV0pIHJldHVybjsgLy8gTm93LCB3YWxrIHRocm91Z2ggdGhlIGRvdC1ub3RhdGlvbiBcInBhcnRzXCIgcmVjdXJzaXZlbHkgdG8gZmluZFxuICAgICAgICAgICAgLy8gYSBtYXRjaCwgYW5kIGNhbGwgdGhlIHdhdGNoZXIgaWYgb25lJ3MgZm91bmQuXG5cbiAgICAgICAgICAgIGRvdE5vdGF0aW9uUGFydHMucmVkdWNlKChjb21wYXJpc29uRGF0YSwgcGFydCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoT2JqZWN0LmlzKHRhcmdldCwgY29tcGFyaXNvbkRhdGEpKSB7XG4gICAgICAgICAgICAgICAgLy8gUnVuIHRoZSB3YXRjaGVycy5cbiAgICAgICAgICAgICAgICBzZWxmLndhdGNoZXJzW2Z1bGxEb3ROb3RhdGlvbktleV0uZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayh0YXJnZXRba2V5XSkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb25EYXRhW3BhcnRdO1xuICAgICAgICAgICAgfSwgc2VsZi51bm9ic2VydmVkRGF0YSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gRG9uJ3QgcmVhY3QgdG8gZGF0YSBjaGFuZ2VzIGZvciBjYXNlcyBsaWtlIHRoZSBgeC1jcmVhdGVkYCBob29rLlxuXG5cbiAgICAgICAgaWYgKHNlbGYucGF1c2VSZWFjdGl2aXR5KSByZXR1cm47XG4gICAgICAgIHVwZGF0ZURvbSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgd2Fsa0FuZFNraXBOZXN0ZWRDb21wb25lbnRzKGVsLCBjYWxsYmFjaywgaW5pdGlhbGl6ZUNvbXBvbmVudENhbGxiYWNrID0gKCkgPT4ge30pIHtcbiAgICAgIHdhbGsoZWwsIGVsID0+IHtcbiAgICAgICAgLy8gV2UndmUgaGl0IGEgY29tcG9uZW50LlxuICAgICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCd4LWRhdGEnKSkge1xuICAgICAgICAgIC8vIElmIGl0J3Mgbm90IHRoZSBjdXJyZW50IG9uZS5cbiAgICAgICAgICBpZiAoIWVsLmlzU2FtZU5vZGUodGhpcy4kZWwpKSB7XG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIGl0IGlmIGl0J3Mgbm90LlxuICAgICAgICAgICAgaWYgKCFlbC5fX3gpIGluaXRpYWxpemVDb21wb25lbnRDYWxsYmFjayhlbCk7IC8vIE5vdyB3ZSdsbCBsZXQgdGhhdCBzdWItY29tcG9uZW50IGRlYWwgd2l0aCBpdHNlbGYuXG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZWwpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZUVsZW1lbnRzKHJvb3RFbCwgZXh0cmFWYXJzID0gKCkgPT4ge30sIGNvbXBvbmVudEZvckNsb25lID0gZmFsc2UpIHtcbiAgICAgIHRoaXMud2Fsa0FuZFNraXBOZXN0ZWRDb21wb25lbnRzKHJvb3RFbCwgZWwgPT4ge1xuICAgICAgICAvLyBEb24ndCB0b3VjaCBzcGF3bnMgZnJvbSBmb3IgbG9vcFxuICAgICAgICBpZiAoZWwuX194X2Zvcl9rZXkgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlOyAvLyBEb24ndCB0b3VjaCBzcGF3bnMgZnJvbSBpZiBkaXJlY3RpdmVzXG5cbiAgICAgICAgaWYgKGVsLl9feF9pbnNlcnRlZF9tZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUVsZW1lbnQoZWwsIGV4dHJhVmFycywgY29tcG9uZW50Rm9yQ2xvbmUgPyBmYWxzZSA6IHRydWUpO1xuICAgICAgfSwgZWwgPT4ge1xuICAgICAgICBpZiAoIWNvbXBvbmVudEZvckNsb25lKSBlbC5fX3ggPSBuZXcgQ29tcG9uZW50KGVsKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5leGVjdXRlQW5kQ2xlYXJSZW1haW5pbmdTaG93RGlyZWN0aXZlU3RhY2soKTtcbiAgICAgIHRoaXMuZXhlY3V0ZUFuZENsZWFyTmV4dFRpY2tTdGFjayhyb290RWwpO1xuICAgIH1cblxuICAgIGluaXRpYWxpemVFbGVtZW50KGVsLCBleHRyYVZhcnMsIHNob3VsZFJlZ2lzdGVyTGlzdGVuZXJzID0gdHJ1ZSkge1xuICAgICAgLy8gVG8gc3VwcG9ydCBjbGFzcyBhdHRyaWJ1dGUgbWVyZ2luZywgd2UgaGF2ZSB0byBrbm93IHdoYXQgdGhlIGVsZW1lbnQnc1xuICAgICAgLy8gb3JpZ2luYWwgY2xhc3MgYXR0cmlidXRlIGxvb2tlZCBsaWtlIGZvciByZWZlcmVuY2UuXG4gICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdjbGFzcycpICYmIGdldFhBdHRycyhlbCwgdGhpcykubGVuZ3RoID4gMCkge1xuICAgICAgICBlbC5fX3hfb3JpZ2luYWxfY2xhc3NlcyA9IGNvbnZlcnRDbGFzc1N0cmluZ1RvQXJyYXkoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpKTtcbiAgICAgIH1cblxuICAgICAgc2hvdWxkUmVnaXN0ZXJMaXN0ZW5lcnMgJiYgdGhpcy5yZWdpc3Rlckxpc3RlbmVycyhlbCwgZXh0cmFWYXJzKTtcbiAgICAgIHRoaXMucmVzb2x2ZUJvdW5kQXR0cmlidXRlcyhlbCwgdHJ1ZSwgZXh0cmFWYXJzKTtcbiAgICB9XG5cbiAgICB1cGRhdGVFbGVtZW50cyhyb290RWwsIGV4dHJhVmFycyA9ICgpID0+IHt9KSB7XG4gICAgICB0aGlzLndhbGtBbmRTa2lwTmVzdGVkQ29tcG9uZW50cyhyb290RWwsIGVsID0+IHtcbiAgICAgICAgLy8gRG9uJ3QgdG91Y2ggc3Bhd25zIGZyb20gZm9yIGxvb3AgKGFuZCBjaGVjayBpZiB0aGUgcm9vdCBpcyBhY3R1YWxseSBhIGZvciBsb29wIGluIGEgcGFyZW50LCBkb24ndCBza2lwIGl0LilcbiAgICAgICAgaWYgKGVsLl9feF9mb3Jfa2V5ICE9PSB1bmRlZmluZWQgJiYgIWVsLmlzU2FtZU5vZGUodGhpcy4kZWwpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChlbCwgZXh0cmFWYXJzKTtcbiAgICAgIH0sIGVsID0+IHtcbiAgICAgICAgZWwuX194ID0gbmV3IENvbXBvbmVudChlbCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZXhlY3V0ZUFuZENsZWFyUmVtYWluaW5nU2hvd0RpcmVjdGl2ZVN0YWNrKCk7XG4gICAgICB0aGlzLmV4ZWN1dGVBbmRDbGVhck5leHRUaWNrU3RhY2socm9vdEVsKTtcbiAgICB9XG5cbiAgICBleGVjdXRlQW5kQ2xlYXJOZXh0VGlja1N0YWNrKGVsKSB7XG4gICAgICAvLyBTa2lwIHNwYXducyBmcm9tIGFscGluZSBkaXJlY3RpdmVzXG4gICAgICBpZiAoZWwgPT09IHRoaXMuJGVsICYmIHRoaXMubmV4dFRpY2tTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIFdlIHJ1biB0aGUgdGljayBzdGFjayBhZnRlciB0aGUgbmV4dCBmcmFtZSB0byBhbGxvdyBhbnlcbiAgICAgICAgLy8gcnVubmluZyB0cmFuc2l0aW9ucyB0byBwYXNzIHRoZSBpbml0aWFsIHNob3cgc3RhZ2UuXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgd2hpbGUgKHRoaXMubmV4dFRpY2tTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRUaWNrU3RhY2suc2hpZnQoKSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhlY3V0ZUFuZENsZWFyUmVtYWluaW5nU2hvd0RpcmVjdGl2ZVN0YWNrKCkge1xuICAgICAgLy8gVGhlIGdvYWwgaGVyZSBpcyB0byBzdGFydCBhbGwgdGhlIHgtc2hvdyB0cmFuc2l0aW9uc1xuICAgICAgLy8gYW5kIGJ1aWxkIGEgbmVzdGVkIHByb21pc2UgY2hhaW4gc28gdGhhdCBlbGVtZW50c1xuICAgICAgLy8gb25seSBoaWRlIHdoZW4gdGhlIGNoaWxkcmVuIGFyZSBmaW5pc2hlZCBoaWRpbmcuXG4gICAgICB0aGlzLnNob3dEaXJlY3RpdmVTdGFjay5yZXZlcnNlKCkubWFwKGhhbmRsZXIgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGhhbmRsZXIocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9KS5yZWR1Y2UoKHByb21pc2VDaGFpbiwgcHJvbWlzZSkgPT4ge1xuICAgICAgICByZXR1cm4gcHJvbWlzZUNoYWluLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZmluaXNoRWxlbWVudCA9PiB7XG4gICAgICAgICAgICBmaW5pc2hFbGVtZW50KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgUHJvbWlzZS5yZXNvbHZlKCgpID0+IHt9KSkuY2F0Y2goZSA9PiB7XG4gICAgICAgIGlmIChlICE9PSBUUkFOU0lUSU9OX0NBTkNFTExFRCkgdGhyb3cgZTtcbiAgICAgIH0pOyAvLyBXZSd2ZSBwcm9jZXNzZWQgdGhlIGhhbmRsZXIgc3RhY2suIGxldCdzIGNsZWFyIGl0LlxuXG4gICAgICB0aGlzLnNob3dEaXJlY3RpdmVTdGFjayA9IFtdO1xuICAgICAgdGhpcy5zaG93RGlyZWN0aXZlTGFzdEVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdXBkYXRlRWxlbWVudChlbCwgZXh0cmFWYXJzKSB7XG4gICAgICB0aGlzLnJlc29sdmVCb3VuZEF0dHJpYnV0ZXMoZWwsIGZhbHNlLCBleHRyYVZhcnMpO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyTGlzdGVuZXJzKGVsLCBleHRyYVZhcnMpIHtcbiAgICAgIGdldFhBdHRycyhlbCwgdGhpcykuZm9yRWFjaCgoe1xuICAgICAgICB0eXBlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbW9kaWZpZXJzLFxuICAgICAgICBleHByZXNzaW9uXG4gICAgICB9KSA9PiB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ29uJzpcbiAgICAgICAgICAgIHJlZ2lzdGVyTGlzdGVuZXIodGhpcywgZWwsIHZhbHVlLCBtb2RpZmllcnMsIGV4cHJlc3Npb24sIGV4dHJhVmFycyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ21vZGVsJzpcbiAgICAgICAgICAgIHJlZ2lzdGVyTW9kZWxMaXN0ZW5lcih0aGlzLCBlbCwgbW9kaWZpZXJzLCBleHByZXNzaW9uLCBleHRyYVZhcnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlc29sdmVCb3VuZEF0dHJpYnV0ZXMoZWwsIGluaXRpYWxVcGRhdGUgPSBmYWxzZSwgZXh0cmFWYXJzKSB7XG4gICAgICBsZXQgYXR0cnMgPSBnZXRYQXR0cnMoZWwsIHRoaXMpO1xuICAgICAgYXR0cnMuZm9yRWFjaCgoe1xuICAgICAgICB0eXBlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbW9kaWZpZXJzLFxuICAgICAgICBleHByZXNzaW9uXG4gICAgICB9KSA9PiB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgJ21vZGVsJzpcbiAgICAgICAgICAgIGhhbmRsZUF0dHJpYnV0ZUJpbmRpbmdEaXJlY3RpdmUodGhpcywgZWwsICd2YWx1ZScsIGV4cHJlc3Npb24sIGV4dHJhVmFycywgdHlwZSwgbW9kaWZpZXJzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYmluZCc6XG4gICAgICAgICAgICAvLyBUaGUgOmtleSBiaW5kaW5nIG9uIGFuIHgtZm9yIGlzIHNwZWNpYWwsIGlnbm9yZSBpdC5cbiAgICAgICAgICAgIGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0ZW1wbGF0ZScgJiYgdmFsdWUgPT09ICdrZXknKSByZXR1cm47XG4gICAgICAgICAgICBoYW5kbGVBdHRyaWJ1dGVCaW5kaW5nRGlyZWN0aXZlKHRoaXMsIGVsLCB2YWx1ZSwgZXhwcmVzc2lvbiwgZXh0cmFWYXJzLCB0eXBlLCBtb2RpZmllcnMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLmV2YWx1YXRlUmV0dXJuRXhwcmVzc2lvbihlbCwgZXhwcmVzc2lvbiwgZXh0cmFWYXJzKTtcbiAgICAgICAgICAgIGhhbmRsZVRleHREaXJlY3RpdmUoZWwsIG91dHB1dCwgZXhwcmVzc2lvbik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICAgICAgaGFuZGxlSHRtbERpcmVjdGl2ZSh0aGlzLCBlbCwgZXhwcmVzc2lvbiwgZXh0cmFWYXJzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc2hvdyc6XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5ldmFsdWF0ZVJldHVybkV4cHJlc3Npb24oZWwsIGV4cHJlc3Npb24sIGV4dHJhVmFycyk7XG4gICAgICAgICAgICBoYW5kbGVTaG93RGlyZWN0aXZlKHRoaXMsIGVsLCBvdXRwdXQsIG1vZGlmaWVycywgaW5pdGlhbFVwZGF0ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2lmJzpcbiAgICAgICAgICAgIC8vIElmIHRoaXMgZWxlbWVudCBhbHNvIGhhcyB4LWZvciBvbiBpdCwgZG9uJ3QgcHJvY2VzcyB4LWlmLlxuICAgICAgICAgICAgLy8gV2Ugd2lsbCBsZXQgdGhlIFwieC1mb3JcIiBkaXJlY3RpdmUgaGFuZGxlIHRoZSBcImlmXCJpbmcuXG4gICAgICAgICAgICBpZiAoYXR0cnMuc29tZShpID0+IGkudHlwZSA9PT0gJ2ZvcicpKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5ldmFsdWF0ZVJldHVybkV4cHJlc3Npb24oZWwsIGV4cHJlc3Npb24sIGV4dHJhVmFycyk7XG4gICAgICAgICAgICBoYW5kbGVJZkRpcmVjdGl2ZSh0aGlzLCBlbCwgb3V0cHV0LCBpbml0aWFsVXBkYXRlLCBleHRyYVZhcnMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdmb3InOlxuICAgICAgICAgICAgaGFuZGxlRm9yRGlyZWN0aXZlKHRoaXMsIGVsLCBleHByZXNzaW9uLCBpbml0aWFsVXBkYXRlLCBleHRyYVZhcnMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjbG9hayc6XG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3gtY2xvYWsnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBldmFsdWF0ZVJldHVybkV4cHJlc3Npb24oZWwsIGV4cHJlc3Npb24sIGV4dHJhVmFycyA9ICgpID0+IHt9KSB7XG4gICAgICByZXR1cm4gc2FmZXJFdmFsKGVsLCBleHByZXNzaW9uLCB0aGlzLiRkYXRhLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZXh0cmFWYXJzKCkpLCB7fSwge1xuICAgICAgICAkZGlzcGF0Y2g6IHRoaXMuZ2V0RGlzcGF0Y2hGdW5jdGlvbihlbClcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBldmFsdWF0ZUNvbW1hbmRFeHByZXNzaW9uKGVsLCBleHByZXNzaW9uLCBleHRyYVZhcnMgPSAoKSA9PiB7fSkge1xuICAgICAgcmV0dXJuIHNhZmVyRXZhbE5vUmV0dXJuKGVsLCBleHByZXNzaW9uLCB0aGlzLiRkYXRhLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZXh0cmFWYXJzKCkpLCB7fSwge1xuICAgICAgICAkZGlzcGF0Y2g6IHRoaXMuZ2V0RGlzcGF0Y2hGdW5jdGlvbihlbClcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBnZXREaXNwYXRjaEZ1bmN0aW9uKGVsKSB7XG4gICAgICByZXR1cm4gKGV2ZW50LCBkZXRhaWwgPSB7fSkgPT4ge1xuICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChldmVudCwge1xuICAgICAgICAgIGRldGFpbCxcbiAgICAgICAgICBidWJibGVzOiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGlzdGVuRm9yTmV3RWxlbWVudHNUb0luaXRpYWxpemUoKSB7XG4gICAgICBjb25zdCB0YXJnZXROb2RlID0gdGhpcy4kZWw7XG4gICAgICBjb25zdCBvYnNlcnZlck9wdGlvbnMgPSB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAvLyBGaWx0ZXIgb3V0IG11dGF0aW9ucyB0cmlnZ2VyZWQgZnJvbSBjaGlsZCBjb21wb25lbnRzLlxuICAgICAgICAgIGNvbnN0IGNsb3Nlc3RQYXJlbnRDb21wb25lbnQgPSBtdXRhdGlvbnNbaV0udGFyZ2V0LmNsb3Nlc3QoJ1t4LWRhdGFdJyk7XG4gICAgICAgICAgaWYgKCEoY2xvc2VzdFBhcmVudENvbXBvbmVudCAmJiBjbG9zZXN0UGFyZW50Q29tcG9uZW50LmlzU2FtZU5vZGUodGhpcy4kZWwpKSkgY29udGludWU7XG5cbiAgICAgICAgICBpZiAobXV0YXRpb25zW2ldLnR5cGUgPT09ICdhdHRyaWJ1dGVzJyAmJiBtdXRhdGlvbnNbaV0uYXR0cmlidXRlTmFtZSA9PT0gJ3gtZGF0YScpIHtcbiAgICAgICAgICAgIGNvbnN0IHhBdHRyID0gbXV0YXRpb25zW2ldLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ3gtZGF0YScpIHx8ICd7fSc7XG4gICAgICAgICAgICBjb25zdCByYXdEYXRhID0gc2FmZXJFdmFsKHRoaXMuJGVsLCB4QXR0ciwge1xuICAgICAgICAgICAgICAkZWw6IHRoaXMuJGVsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHJhd0RhdGEpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuJGRhdGFba2V5XSAhPT0gcmF3RGF0YVtrZXldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZGF0YVtrZXldID0gcmF3RGF0YVtrZXldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobXV0YXRpb25zW2ldLmFkZGVkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbXV0YXRpb25zW2ldLmFkZGVkTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IDEgfHwgbm9kZS5fX3hfaW5zZXJ0ZWRfbWUpIHJldHVybjtcblxuICAgICAgICAgICAgICBpZiAobm9kZS5tYXRjaGVzKCdbeC1kYXRhXScpICYmICFub2RlLl9feCkge1xuICAgICAgICAgICAgICAgIG5vZGUuX194ID0gbmV3IENvbXBvbmVudChub2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVFbGVtZW50cyhub2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKHRhcmdldE5vZGUsIG9ic2VydmVyT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgZ2V0UmVmc1Byb3h5KCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHJlZk9iaiA9IHt9O1xuICAgICAgLy8gT25lIG9mIHRoZSBnb2FscyBvZiB0aGlzIGlzIHRvIG5vdCBob2xkIGVsZW1lbnRzIGluIG1lbW9yeSwgYnV0IHJhdGhlciByZS1ldmFsdWF0ZVxuICAgICAgLy8gdGhlIERPTSB3aGVuIHRoZSBzeXN0ZW0gbmVlZHMgc29tZXRoaW5nIGZyb20gaXQuIFRoaXMgd2F5LCB0aGUgZnJhbWV3b3JrIGlzIGZsZXhpYmxlIGFuZFxuICAgICAgLy8gZnJpZW5kbHkgdG8gb3V0c2lkZSBET00gY2hhbmdlcyBmcm9tIGxpYnJhcmllcyBsaWtlIFZ1ZS9MaXZld2lyZS5cbiAgICAgIC8vIEZvciB0aGlzIHJlYXNvbiwgSSdtIHVzaW5nIGFuIFwib24tZGVtYW5kXCIgcHJveHkgdG8gZmFrZSBhIFwiJHJlZnNcIiBvYmplY3QuXG5cbiAgICAgIHJldHVybiBuZXcgUHJveHkocmVmT2JqLCB7XG4gICAgICAgIGdldChvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICAgICAgaWYgKHByb3BlcnR5ID09PSAnJGlzQWxwaW5lUHJveHknKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB2YXIgcmVmOyAvLyBXZSBjYW4ndCBqdXN0IHF1ZXJ5IHRoZSBET00gYmVjYXVzZSBpdCdzIGhhcmQgdG8gZmlsdGVyIG91dCByZWZzIGluXG4gICAgICAgICAgLy8gbmVzdGVkIGNvbXBvbmVudHMuXG5cbiAgICAgICAgICBzZWxmLndhbGtBbmRTa2lwTmVzdGVkQ29tcG9uZW50cyhzZWxmLiRlbCwgZWwgPT4ge1xuICAgICAgICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgneC1yZWYnKSAmJiBlbC5nZXRBdHRyaWJ1dGUoJ3gtcmVmJykgPT09IHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHJlZiA9IGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZWY7XG4gICAgICAgIH1cblxuICAgICAgfSk7XG4gICAgfVxuXG4gIH1cblxuICBjb25zdCBBbHBpbmUgPSB7XG4gICAgdmVyc2lvbjogXCIyLjguMlwiLFxuICAgIHBhdXNlTXV0YXRpb25PYnNlcnZlcjogZmFsc2UsXG4gICAgbWFnaWNQcm9wZXJ0aWVzOiB7fSxcbiAgICBvbkNvbXBvbmVudEluaXRpYWxpemVkczogW10sXG4gICAgb25CZWZvcmVDb21wb25lbnRJbml0aWFsaXplZHM6IFtdLFxuICAgIGlnbm9yZUZvY3VzZWRGb3JWYWx1ZUJpbmRpbmc6IGZhbHNlLFxuICAgIHN0YXJ0OiBhc3luYyBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIGlmICghaXNUZXN0aW5nKCkpIHtcbiAgICAgICAgYXdhaXQgZG9tUmVhZHkoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kaXNjb3ZlckNvbXBvbmVudHMoZWwgPT4ge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVDb21wb25lbnQoZWwpO1xuICAgICAgfSk7IC8vIEl0J3MgZWFzaWVyIGFuZCBtb3JlIHBlcmZvcm1hbnQgdG8ganVzdCBzdXBwb3J0IFR1cmJvbGlua3MgdGhhbiBsaXN0ZW5cbiAgICAgIC8vIHRvIE11dGF0aW9uT2JzZXJ2ZXIgbXV0YXRpb25zIGF0IHRoZSBkb2N1bWVudCBsZXZlbC5cblxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInR1cmJvbGlua3M6bG9hZFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZGlzY292ZXJVbmluaXRpYWxpemVkQ29tcG9uZW50cyhlbCA9PiB7XG4gICAgICAgICAgdGhpcy5pbml0aWFsaXplQ29tcG9uZW50KGVsKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubGlzdGVuRm9yTmV3VW5pbml0aWFsaXplZENvbXBvbmVudHNBdFJ1blRpbWUoKTtcbiAgICB9LFxuICAgIGRpc2NvdmVyQ29tcG9uZW50czogZnVuY3Rpb24gZGlzY292ZXJDb21wb25lbnRzKGNhbGxiYWNrKSB7XG4gICAgICBjb25zdCByb290RWxzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW3gtZGF0YV0nKTtcbiAgICAgIHJvb3RFbHMuZm9yRWFjaChyb290RWwgPT4ge1xuICAgICAgICBjYWxsYmFjayhyb290RWwpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkaXNjb3ZlclVuaW5pdGlhbGl6ZWRDb21wb25lbnRzOiBmdW5jdGlvbiBkaXNjb3ZlclVuaW5pdGlhbGl6ZWRDb21wb25lbnRzKGNhbGxiYWNrLCBlbCA9IG51bGwpIHtcbiAgICAgIGNvbnN0IHJvb3RFbHMgPSAoZWwgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoJ1t4LWRhdGFdJyk7XG4gICAgICBBcnJheS5mcm9tKHJvb3RFbHMpLmZpbHRlcihlbCA9PiBlbC5fX3ggPT09IHVuZGVmaW5lZCkuZm9yRWFjaChyb290RWwgPT4ge1xuICAgICAgICBjYWxsYmFjayhyb290RWwpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBsaXN0ZW5Gb3JOZXdVbmluaXRpYWxpemVkQ29tcG9uZW50c0F0UnVuVGltZTogZnVuY3Rpb24gbGlzdGVuRm9yTmV3VW5pbml0aWFsaXplZENvbXBvbmVudHNBdFJ1blRpbWUoKSB7XG4gICAgICBjb25zdCB0YXJnZXROb2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuICAgICAgY29uc3Qgb2JzZXJ2ZXJPcHRpb25zID0ge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICAgIH07XG4gICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG11dGF0aW9ucyA9PiB7XG4gICAgICAgIGlmICh0aGlzLnBhdXNlTXV0YXRpb25PYnNlcnZlcikgcmV0dXJuO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKG11dGF0aW9uc1tpXS5hZGRlZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG11dGF0aW9uc1tpXS5hZGRlZE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgIC8vIERpc2NhcmQgbm9uLWVsZW1lbnQgbm9kZXMgKGxpa2UgbGluZS1icmVha3MpXG4gICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSAxKSByZXR1cm47IC8vIERpc2NhcmQgYW55IGNoYW5nZXMgaGFwcGVuaW5nIHdpdGhpbiBhbiBleGlzdGluZyBjb21wb25lbnQuXG4gICAgICAgICAgICAgIC8vIFRoZXkgd2lsbCB0YWtlIGNhcmUgb2YgdGhlbXNlbHZlcy5cblxuICAgICAgICAgICAgICBpZiAobm9kZS5wYXJlbnRFbGVtZW50ICYmIG5vZGUucGFyZW50RWxlbWVudC5jbG9zZXN0KCdbeC1kYXRhXScpKSByZXR1cm47XG4gICAgICAgICAgICAgIHRoaXMuZGlzY292ZXJVbmluaXRpYWxpemVkQ29tcG9uZW50cyhlbCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplQ29tcG9uZW50KGVsKTtcbiAgICAgICAgICAgICAgfSwgbm9kZS5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKHRhcmdldE5vZGUsIG9ic2VydmVyT3B0aW9ucyk7XG4gICAgfSxcbiAgICBpbml0aWFsaXplQ29tcG9uZW50OiBmdW5jdGlvbiBpbml0aWFsaXplQ29tcG9uZW50KGVsKSB7XG4gICAgICBpZiAoIWVsLl9feCkge1xuICAgICAgICAvLyBXcmFwIGluIGEgdHJ5L2NhdGNoIHNvIHRoYXQgd2UgZG9uJ3QgcHJldmVudCBvdGhlciBjb21wb25lbnRzXG4gICAgICAgIC8vIGZyb20gaW5pdGlhbGl6aW5nIHdoZW4gb25lIGNvbXBvbmVudCBjb250YWlucyBhbiBlcnJvci5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBlbC5fX3ggPSBuZXcgQ29tcG9uZW50KGVsKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoY29tcG9uZW50LCBuZXdFbCkge1xuICAgICAgaWYgKCFuZXdFbC5fX3gpIHtcbiAgICAgICAgbmV3RWwuX194ID0gbmV3IENvbXBvbmVudChuZXdFbCwgY29tcG9uZW50KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFkZE1hZ2ljUHJvcGVydHk6IGZ1bmN0aW9uIGFkZE1hZ2ljUHJvcGVydHkobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIHRoaXMubWFnaWNQcm9wZXJ0aWVzW25hbWVdID0gY2FsbGJhY2s7XG4gICAgfSxcbiAgICBvbkNvbXBvbmVudEluaXRpYWxpemVkOiBmdW5jdGlvbiBvbkNvbXBvbmVudEluaXRpYWxpemVkKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uQ29tcG9uZW50SW5pdGlhbGl6ZWRzLnB1c2goY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb25CZWZvcmVDb21wb25lbnRJbml0aWFsaXplZDogZnVuY3Rpb24gb25CZWZvcmVDb21wb25lbnRJbml0aWFsaXplZChjYWxsYmFjaykge1xuICAgICAgdGhpcy5vbkJlZm9yZUNvbXBvbmVudEluaXRpYWxpemVkcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKCFpc1Rlc3RpbmcoKSkge1xuICAgIHdpbmRvdy5BbHBpbmUgPSBBbHBpbmU7XG5cbiAgICBpZiAod2luZG93LmRlZmVyTG9hZGluZ0FscGluZSkge1xuICAgICAgd2luZG93LmRlZmVyTG9hZGluZ0FscGluZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5BbHBpbmUuc3RhcnQoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuQWxwaW5lLnN0YXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEFscGluZTtcblxufSkpKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLFdBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/alpinejs/dist/alpine.js\n");

/***/ }),

/***/ "./node_modules/nprogress/nprogress.js":
/*!*********************************************!*\
  !*** ./node_modules/nprogress/nprogress.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress\n * @license MIT */\n\n;(function(root, factory) {\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n})(this, function() {\n  var NProgress = {};\n\n  NProgress.version = '0.2.0';\n\n  var Settings = NProgress.settings = {\n    minimum: 0.08,\n    easing: 'ease',\n    positionUsing: '',\n    speed: 200,\n    trickle: true,\n    trickleRate: 0.02,\n    trickleSpeed: 800,\n    showSpinner: true,\n    barSelector: '[role=\"bar\"]',\n    spinnerSelector: '[role=\"spinner\"]',\n    parent: 'body',\n    template: '<div class=\"bar\" role=\"bar\"><div class=\"peg\"></div></div><div class=\"spinner\" role=\"spinner\"><div class=\"spinner-icon\"></div></div>'\n  };\n\n  /**\n   * Updates configuration.\n   *\n   *     NProgress.configure({\n   *       minimum: 0.1\n   *     });\n   */\n  NProgress.configure = function(options) {\n    var key, value;\n    for (key in options) {\n      value = options[key];\n      if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;\n    }\n\n    return this;\n  };\n\n  /**\n   * Last number.\n   */\n\n  NProgress.status = null;\n\n  /**\n   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.\n   *\n   *     NProgress.set(0.4);\n   *     NProgress.set(1.0);\n   */\n\n  NProgress.set = function(n) {\n    var started = NProgress.isStarted();\n\n    n = clamp(n, Settings.minimum, 1);\n    NProgress.status = (n === 1 ? null : n);\n\n    var progress = NProgress.render(!started),\n        bar      = progress.querySelector(Settings.barSelector),\n        speed    = Settings.speed,\n        ease     = Settings.easing;\n\n    progress.offsetWidth; /* Repaint */\n\n    queue(function(next) {\n      // Set positionUsing if it hasn't already been set\n      if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS();\n\n      // Add transition\n      css(bar, barPositionCSS(n, speed, ease));\n\n      if (n === 1) {\n        // Fade out\n        css(progress, { \n          transition: 'none', \n          opacity: 1 \n        });\n        progress.offsetWidth; /* Repaint */\n\n        setTimeout(function() {\n          css(progress, { \n            transition: 'all ' + speed + 'ms linear', \n            opacity: 0 \n          });\n          setTimeout(function() {\n            NProgress.remove();\n            next();\n          }, speed);\n        }, speed);\n      } else {\n        setTimeout(next, speed);\n      }\n    });\n\n    return this;\n  };\n\n  NProgress.isStarted = function() {\n    return typeof NProgress.status === 'number';\n  };\n\n  /**\n   * Shows the progress bar.\n   * This is the same as setting the status to 0%, except that it doesn't go backwards.\n   *\n   *     NProgress.start();\n   *\n   */\n  NProgress.start = function() {\n    if (!NProgress.status) NProgress.set(0);\n\n    var work = function() {\n      setTimeout(function() {\n        if (!NProgress.status) return;\n        NProgress.trickle();\n        work();\n      }, Settings.trickleSpeed);\n    };\n\n    if (Settings.trickle) work();\n\n    return this;\n  };\n\n  /**\n   * Hides the progress bar.\n   * This is the *sort of* the same as setting the status to 100%, with the\n   * difference being `done()` makes some placebo effect of some realistic motion.\n   *\n   *     NProgress.done();\n   *\n   * If `true` is passed, it will show the progress bar even if its hidden.\n   *\n   *     NProgress.done(true);\n   */\n\n  NProgress.done = function(force) {\n    if (!force && !NProgress.status) return this;\n\n    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);\n  };\n\n  /**\n   * Increments by a random amount.\n   */\n\n  NProgress.inc = function(amount) {\n    var n = NProgress.status;\n\n    if (!n) {\n      return NProgress.start();\n    } else {\n      if (typeof amount !== 'number') {\n        amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);\n      }\n\n      n = clamp(n + amount, 0, 0.994);\n      return NProgress.set(n);\n    }\n  };\n\n  NProgress.trickle = function() {\n    return NProgress.inc(Math.random() * Settings.trickleRate);\n  };\n\n  /**\n   * Waits for all supplied jQuery promises and\n   * increases the progress as the promises resolve.\n   *\n   * @param $promise jQUery Promise\n   */\n  (function() {\n    var initial = 0, current = 0;\n\n    NProgress.promise = function($promise) {\n      if (!$promise || $promise.state() === \"resolved\") {\n        return this;\n      }\n\n      if (current === 0) {\n        NProgress.start();\n      }\n\n      initial++;\n      current++;\n\n      $promise.always(function() {\n        current--;\n        if (current === 0) {\n            initial = 0;\n            NProgress.done();\n        } else {\n            NProgress.set((initial - current) / initial);\n        }\n      });\n\n      return this;\n    };\n\n  })();\n\n  /**\n   * (Internal) renders the progress bar markup based on the `template`\n   * setting.\n   */\n\n  NProgress.render = function(fromStart) {\n    if (NProgress.isRendered()) return document.getElementById('nprogress');\n\n    addClass(document.documentElement, 'nprogress-busy');\n    \n    var progress = document.createElement('div');\n    progress.id = 'nprogress';\n    progress.innerHTML = Settings.template;\n\n    var bar      = progress.querySelector(Settings.barSelector),\n        perc     = fromStart ? '-100' : toBarPerc(NProgress.status || 0),\n        parent   = document.querySelector(Settings.parent),\n        spinner;\n    \n    css(bar, {\n      transition: 'all 0 linear',\n      transform: 'translate3d(' + perc + '%,0,0)'\n    });\n\n    if (!Settings.showSpinner) {\n      spinner = progress.querySelector(Settings.spinnerSelector);\n      spinner && removeElement(spinner);\n    }\n\n    if (parent != document.body) {\n      addClass(parent, 'nprogress-custom-parent');\n    }\n\n    parent.appendChild(progress);\n    return progress;\n  };\n\n  /**\n   * Removes the element. Opposite of render().\n   */\n\n  NProgress.remove = function() {\n    removeClass(document.documentElement, 'nprogress-busy');\n    removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');\n    var progress = document.getElementById('nprogress');\n    progress && removeElement(progress);\n  };\n\n  /**\n   * Checks if the progress bar is rendered.\n   */\n\n  NProgress.isRendered = function() {\n    return !!document.getElementById('nprogress');\n  };\n\n  /**\n   * Determine which positioning CSS rule to use.\n   */\n\n  NProgress.getPositioningCSS = function() {\n    // Sniff on document.body.style\n    var bodyStyle = document.body.style;\n\n    // Sniff prefixes\n    var vendorPrefix = ('WebkitTransform' in bodyStyle) ? 'Webkit' :\n                       ('MozTransform' in bodyStyle) ? 'Moz' :\n                       ('msTransform' in bodyStyle) ? 'ms' :\n                       ('OTransform' in bodyStyle) ? 'O' : '';\n\n    if (vendorPrefix + 'Perspective' in bodyStyle) {\n      // Modern browsers with 3D support, e.g. Webkit, IE10\n      return 'translate3d';\n    } else if (vendorPrefix + 'Transform' in bodyStyle) {\n      // Browsers without 3D support, e.g. IE9\n      return 'translate';\n    } else {\n      // Browsers without translate() support, e.g. IE7-8\n      return 'margin';\n    }\n  };\n\n  /**\n   * Helpers\n   */\n\n  function clamp(n, min, max) {\n    if (n < min) return min;\n    if (n > max) return max;\n    return n;\n  }\n\n  /**\n   * (Internal) converts a percentage (`0..1`) to a bar translateX\n   * percentage (`-100%..0%`).\n   */\n\n  function toBarPerc(n) {\n    return (-1 + n) * 100;\n  }\n\n\n  /**\n   * (Internal) returns the correct CSS for changing the bar's\n   * position given an n percentage, and speed and ease from Settings\n   */\n\n  function barPositionCSS(n, speed, ease) {\n    var barCSS;\n\n    if (Settings.positionUsing === 'translate3d') {\n      barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' };\n    } else if (Settings.positionUsing === 'translate') {\n      barCSS = { transform: 'translate('+toBarPerc(n)+'%,0)' };\n    } else {\n      barCSS = { 'margin-left': toBarPerc(n)+'%' };\n    }\n\n    barCSS.transition = 'all '+speed+'ms '+ease;\n\n    return barCSS;\n  }\n\n  /**\n   * (Internal) Queues a function to be executed.\n   */\n\n  var queue = (function() {\n    var pending = [];\n    \n    function next() {\n      var fn = pending.shift();\n      if (fn) {\n        fn(next);\n      }\n    }\n\n    return function(fn) {\n      pending.push(fn);\n      if (pending.length == 1) next();\n    };\n  })();\n\n  /**\n   * (Internal) Applies css properties to an element, similar to the jQuery \n   * css method.\n   *\n   * While this helper does assist with vendor prefixed property names, it \n   * does not perform any manipulation of values prior to setting styles.\n   */\n\n  var css = (function() {\n    var cssPrefixes = [ 'Webkit', 'O', 'Moz', 'ms' ],\n        cssProps    = {};\n\n    function camelCase(string) {\n      return string.replace(/^-ms-/, 'ms-').replace(/-([\\da-z])/gi, function(match, letter) {\n        return letter.toUpperCase();\n      });\n    }\n\n    function getVendorProp(name) {\n      var style = document.body.style;\n      if (name in style) return name;\n\n      var i = cssPrefixes.length,\n          capName = name.charAt(0).toUpperCase() + name.slice(1),\n          vendorName;\n      while (i--) {\n        vendorName = cssPrefixes[i] + capName;\n        if (vendorName in style) return vendorName;\n      }\n\n      return name;\n    }\n\n    function getStyleProp(name) {\n      name = camelCase(name);\n      return cssProps[name] || (cssProps[name] = getVendorProp(name));\n    }\n\n    function applyCss(element, prop, value) {\n      prop = getStyleProp(prop);\n      element.style[prop] = value;\n    }\n\n    return function(element, properties) {\n      var args = arguments,\n          prop, \n          value;\n\n      if (args.length == 2) {\n        for (prop in properties) {\n          value = properties[prop];\n          if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);\n        }\n      } else {\n        applyCss(element, args[1], args[2]);\n      }\n    }\n  })();\n\n  /**\n   * (Internal) Determines if an element or space separated list of class names contains a class name.\n   */\n\n  function hasClass(element, name) {\n    var list = typeof element == 'string' ? element : classList(element);\n    return list.indexOf(' ' + name + ' ') >= 0;\n  }\n\n  /**\n   * (Internal) Adds a class to an element.\n   */\n\n  function addClass(element, name) {\n    var oldList = classList(element),\n        newList = oldList + name;\n\n    if (hasClass(oldList, name)) return; \n\n    // Trim the opening space.\n    element.className = newList.substring(1);\n  }\n\n  /**\n   * (Internal) Removes a class from an element.\n   */\n\n  function removeClass(element, name) {\n    var oldList = classList(element),\n        newList;\n\n    if (!hasClass(element, name)) return;\n\n    // Replace the class name.\n    newList = oldList.replace(' ' + name + ' ', ' ');\n\n    // Trim the opening and closing spaces.\n    element.className = newList.substring(1, newList.length - 1);\n  }\n\n  /**\n   * (Internal) Gets a space separated list of the class names on the element. \n   * The list is wrapped with a single space on each end to facilitate finding \n   * matches within the list.\n   */\n\n  function classList(element) {\n    return (' ' + (element.className || '') + ' ').replace(/\\s+/gi, ' ');\n  }\n\n  /**\n   * (Internal) Removes an element from the DOM.\n   */\n\n  function removeElement(element) {\n    element && element.parentNode && element.parentNode.removeChild(element);\n  }\n\n  return NProgress;\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbnByb2dyZXNzL25wcm9ncmVzcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ucHJvZ3Jlc3MvbnByb2dyZXNzLmpzPzMyM2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyogTlByb2dyZXNzLCAoYykgMjAxMywgMjAxNCBSaWNvIFN0YS4gQ3J1eiAtIGh0dHA6Ly9yaWNvc3RhY3J1ei5jb20vbnByb2dyZXNzXG4gKiBAbGljZW5zZSBNSVQgKi9cblxuOyhmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmYWN0b3J5KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICByb290Lk5Qcm9ncmVzcyA9IGZhY3RvcnkoKTtcbiAgfVxuXG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgdmFyIE5Qcm9ncmVzcyA9IHt9O1xuXG4gIE5Qcm9ncmVzcy52ZXJzaW9uID0gJzAuMi4wJztcblxuICB2YXIgU2V0dGluZ3MgPSBOUHJvZ3Jlc3Muc2V0dGluZ3MgPSB7XG4gICAgbWluaW11bTogMC4wOCxcbiAgICBlYXNpbmc6ICdlYXNlJyxcbiAgICBwb3NpdGlvblVzaW5nOiAnJyxcbiAgICBzcGVlZDogMjAwLFxuICAgIHRyaWNrbGU6IHRydWUsXG4gICAgdHJpY2tsZVJhdGU6IDAuMDIsXG4gICAgdHJpY2tsZVNwZWVkOiA4MDAsXG4gICAgc2hvd1NwaW5uZXI6IHRydWUsXG4gICAgYmFyU2VsZWN0b3I6ICdbcm9sZT1cImJhclwiXScsXG4gICAgc3Bpbm5lclNlbGVjdG9yOiAnW3JvbGU9XCJzcGlubmVyXCJdJyxcbiAgICBwYXJlbnQ6ICdib2R5JyxcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJiYXJcIiByb2xlPVwiYmFyXCI+PGRpdiBjbGFzcz1cInBlZ1wiPjwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9XCJzcGlubmVyXCIgcm9sZT1cInNwaW5uZXJcIj48ZGl2IGNsYXNzPVwic3Bpbm5lci1pY29uXCI+PC9kaXY+PC9kaXY+J1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqICAgICBOUHJvZ3Jlc3MuY29uZmlndXJlKHtcbiAgICogICAgICAgbWluaW11bTogMC4xXG4gICAqICAgICB9KTtcbiAgICovXG4gIE5Qcm9ncmVzcy5jb25maWd1cmUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGtleSwgdmFsdWU7XG4gICAgZm9yIChrZXkgaW4gb3B0aW9ucykge1xuICAgICAgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIFNldHRpbmdzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogTGFzdCBudW1iZXIuXG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5zdGF0dXMgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcm9ncmVzcyBiYXIgc3RhdHVzLCB3aGVyZSBgbmAgaXMgYSBudW1iZXIgZnJvbSBgMC4wYCB0byBgMS4wYC5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5zZXQoMC40KTtcbiAgICogICAgIE5Qcm9ncmVzcy5zZXQoMS4wKTtcbiAgICovXG5cbiAgTlByb2dyZXNzLnNldCA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgc3RhcnRlZCA9IE5Qcm9ncmVzcy5pc1N0YXJ0ZWQoKTtcblxuICAgIG4gPSBjbGFtcChuLCBTZXR0aW5ncy5taW5pbXVtLCAxKTtcbiAgICBOUHJvZ3Jlc3Muc3RhdHVzID0gKG4gPT09IDEgPyBudWxsIDogbik7XG5cbiAgICB2YXIgcHJvZ3Jlc3MgPSBOUHJvZ3Jlc3MucmVuZGVyKCFzdGFydGVkKSxcbiAgICAgICAgYmFyICAgICAgPSBwcm9ncmVzcy5xdWVyeVNlbGVjdG9yKFNldHRpbmdzLmJhclNlbGVjdG9yKSxcbiAgICAgICAgc3BlZWQgICAgPSBTZXR0aW5ncy5zcGVlZCxcbiAgICAgICAgZWFzZSAgICAgPSBTZXR0aW5ncy5lYXNpbmc7XG5cbiAgICBwcm9ncmVzcy5vZmZzZXRXaWR0aDsgLyogUmVwYWludCAqL1xuXG4gICAgcXVldWUoZnVuY3Rpb24obmV4dCkge1xuICAgICAgLy8gU2V0IHBvc2l0aW9uVXNpbmcgaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiBzZXRcbiAgICAgIGlmIChTZXR0aW5ncy5wb3NpdGlvblVzaW5nID09PSAnJykgU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9IE5Qcm9ncmVzcy5nZXRQb3NpdGlvbmluZ0NTUygpO1xuXG4gICAgICAvLyBBZGQgdHJhbnNpdGlvblxuICAgICAgY3NzKGJhciwgYmFyUG9zaXRpb25DU1Mobiwgc3BlZWQsIGVhc2UpKTtcblxuICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgLy8gRmFkZSBvdXRcbiAgICAgICAgY3NzKHByb2dyZXNzLCB7IFxuICAgICAgICAgIHRyYW5zaXRpb246ICdub25lJywgXG4gICAgICAgICAgb3BhY2l0eTogMSBcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2dyZXNzLm9mZnNldFdpZHRoOyAvKiBSZXBhaW50ICovXG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBjc3MocHJvZ3Jlc3MsIHsgXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiAnYWxsICcgKyBzcGVlZCArICdtcyBsaW5lYXInLCBcbiAgICAgICAgICAgIG9wYWNpdHk6IDAgXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIE5Qcm9ncmVzcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9LCBzcGVlZCk7XG4gICAgICAgIH0sIHNwZWVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQobmV4dCwgc3BlZWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgTlByb2dyZXNzLmlzU3RhcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0eXBlb2YgTlByb2dyZXNzLnN0YXR1cyA9PT0gJ251bWJlcic7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3dzIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqIFRoaXMgaXMgdGhlIHNhbWUgYXMgc2V0dGluZyB0aGUgc3RhdHVzIHRvIDAlLCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGdvIGJhY2t3YXJkcy5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5zdGFydCgpO1xuICAgKlxuICAgKi9cbiAgTlByb2dyZXNzLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFOUHJvZ3Jlc3Muc3RhdHVzKSBOUHJvZ3Jlc3Muc2V0KDApO1xuXG4gICAgdmFyIHdvcmsgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghTlByb2dyZXNzLnN0YXR1cykgcmV0dXJuO1xuICAgICAgICBOUHJvZ3Jlc3MudHJpY2tsZSgpO1xuICAgICAgICB3b3JrKCk7XG4gICAgICB9LCBTZXR0aW5ncy50cmlja2xlU3BlZWQpO1xuICAgIH07XG5cbiAgICBpZiAoU2V0dGluZ3MudHJpY2tsZSkgd29yaygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqIFRoaXMgaXMgdGhlICpzb3J0IG9mKiB0aGUgc2FtZSBhcyBzZXR0aW5nIHRoZSBzdGF0dXMgdG8gMTAwJSwgd2l0aCB0aGVcbiAgICogZGlmZmVyZW5jZSBiZWluZyBgZG9uZSgpYCBtYWtlcyBzb21lIHBsYWNlYm8gZWZmZWN0IG9mIHNvbWUgcmVhbGlzdGljIG1vdGlvbi5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5kb25lKCk7XG4gICAqXG4gICAqIElmIGB0cnVlYCBpcyBwYXNzZWQsIGl0IHdpbGwgc2hvdyB0aGUgcHJvZ3Jlc3MgYmFyIGV2ZW4gaWYgaXRzIGhpZGRlbi5cbiAgICpcbiAgICogICAgIE5Qcm9ncmVzcy5kb25lKHRydWUpO1xuICAgKi9cblxuICBOUHJvZ3Jlc3MuZG9uZSA9IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgaWYgKCFmb3JjZSAmJiAhTlByb2dyZXNzLnN0YXR1cykgcmV0dXJuIHRoaXM7XG5cbiAgICByZXR1cm4gTlByb2dyZXNzLmluYygwLjMgKyAwLjUgKiBNYXRoLnJhbmRvbSgpKS5zZXQoMSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudHMgYnkgYSByYW5kb20gYW1vdW50LlxuICAgKi9cblxuICBOUHJvZ3Jlc3MuaW5jID0gZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgdmFyIG4gPSBOUHJvZ3Jlc3Muc3RhdHVzO1xuXG4gICAgaWYgKCFuKSB7XG4gICAgICByZXR1cm4gTlByb2dyZXNzLnN0YXJ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgYW1vdW50ICE9PSAnbnVtYmVyJykge1xuICAgICAgICBhbW91bnQgPSAoMSAtIG4pICogY2xhbXAoTWF0aC5yYW5kb20oKSAqIG4sIDAuMSwgMC45NSk7XG4gICAgICB9XG5cbiAgICAgIG4gPSBjbGFtcChuICsgYW1vdW50LCAwLCAwLjk5NCk7XG4gICAgICByZXR1cm4gTlByb2dyZXNzLnNldChuKTtcbiAgICB9XG4gIH07XG5cbiAgTlByb2dyZXNzLnRyaWNrbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTlByb2dyZXNzLmluYyhNYXRoLnJhbmRvbSgpICogU2V0dGluZ3MudHJpY2tsZVJhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3IgYWxsIHN1cHBsaWVkIGpRdWVyeSBwcm9taXNlcyBhbmRcbiAgICogaW5jcmVhc2VzIHRoZSBwcm9ncmVzcyBhcyB0aGUgcHJvbWlzZXMgcmVzb2x2ZS5cbiAgICpcbiAgICogQHBhcmFtICRwcm9taXNlIGpRVWVyeSBQcm9taXNlXG4gICAqL1xuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluaXRpYWwgPSAwLCBjdXJyZW50ID0gMDtcblxuICAgIE5Qcm9ncmVzcy5wcm9taXNlID0gZnVuY3Rpb24oJHByb21pc2UpIHtcbiAgICAgIGlmICghJHByb21pc2UgfHwgJHByb21pc2Uuc3RhdGUoKSA9PT0gXCJyZXNvbHZlZFwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudCA9PT0gMCkge1xuICAgICAgICBOUHJvZ3Jlc3Muc3RhcnQoKTtcbiAgICAgIH1cblxuICAgICAgaW5pdGlhbCsrO1xuICAgICAgY3VycmVudCsrO1xuXG4gICAgICAkcHJvbWlzZS5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgIGN1cnJlbnQtLTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgICAgIGluaXRpYWwgPSAwO1xuICAgICAgICAgICAgTlByb2dyZXNzLmRvbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE5Qcm9ncmVzcy5zZXQoKGluaXRpYWwgLSBjdXJyZW50KSAvIGluaXRpYWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICB9KSgpO1xuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIHJlbmRlcnMgdGhlIHByb2dyZXNzIGJhciBtYXJrdXAgYmFzZWQgb24gdGhlIGB0ZW1wbGF0ZWBcbiAgICogc2V0dGluZy5cbiAgICovXG5cbiAgTlByb2dyZXNzLnJlbmRlciA9IGZ1bmN0aW9uKGZyb21TdGFydCkge1xuICAgIGlmIChOUHJvZ3Jlc3MuaXNSZW5kZXJlZCgpKSByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25wcm9ncmVzcycpO1xuXG4gICAgYWRkQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnbnByb2dyZXNzLWJ1c3knKTtcbiAgICBcbiAgICB2YXIgcHJvZ3Jlc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwcm9ncmVzcy5pZCA9ICducHJvZ3Jlc3MnO1xuICAgIHByb2dyZXNzLmlubmVySFRNTCA9IFNldHRpbmdzLnRlbXBsYXRlO1xuXG4gICAgdmFyIGJhciAgICAgID0gcHJvZ3Jlc3MucXVlcnlTZWxlY3RvcihTZXR0aW5ncy5iYXJTZWxlY3RvciksXG4gICAgICAgIHBlcmMgICAgID0gZnJvbVN0YXJ0ID8gJy0xMDAnIDogdG9CYXJQZXJjKE5Qcm9ncmVzcy5zdGF0dXMgfHwgMCksXG4gICAgICAgIHBhcmVudCAgID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihTZXR0aW5ncy5wYXJlbnQpLFxuICAgICAgICBzcGlubmVyO1xuICAgIFxuICAgIGNzcyhiYXIsIHtcbiAgICAgIHRyYW5zaXRpb246ICdhbGwgMCBsaW5lYXInLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoJyArIHBlcmMgKyAnJSwwLDApJ1xuICAgIH0pO1xuXG4gICAgaWYgKCFTZXR0aW5ncy5zaG93U3Bpbm5lcikge1xuICAgICAgc3Bpbm5lciA9IHByb2dyZXNzLnF1ZXJ5U2VsZWN0b3IoU2V0dGluZ3Muc3Bpbm5lclNlbGVjdG9yKTtcbiAgICAgIHNwaW5uZXIgJiYgcmVtb3ZlRWxlbWVudChzcGlubmVyKTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50ICE9IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGFkZENsYXNzKHBhcmVudCwgJ25wcm9ncmVzcy1jdXN0b20tcGFyZW50Jyk7XG4gICAgfVxuXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKHByb2dyZXNzKTtcbiAgICByZXR1cm4gcHJvZ3Jlc3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGVsZW1lbnQuIE9wcG9zaXRlIG9mIHJlbmRlcigpLlxuICAgKi9cblxuICBOUHJvZ3Jlc3MucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnbnByb2dyZXNzLWJ1c3knKTtcbiAgICByZW1vdmVDbGFzcyhkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFNldHRpbmdzLnBhcmVudCksICducHJvZ3Jlc3MtY3VzdG9tLXBhcmVudCcpO1xuICAgIHZhciBwcm9ncmVzcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCducHJvZ3Jlc3MnKTtcbiAgICBwcm9ncmVzcyAmJiByZW1vdmVFbGVtZW50KHByb2dyZXNzKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwcm9ncmVzcyBiYXIgaXMgcmVuZGVyZWQuXG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5pc1JlbmRlcmVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25wcm9ncmVzcycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hpY2ggcG9zaXRpb25pbmcgQ1NTIHJ1bGUgdG8gdXNlLlxuICAgKi9cblxuICBOUHJvZ3Jlc3MuZ2V0UG9zaXRpb25pbmdDU1MgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBTbmlmZiBvbiBkb2N1bWVudC5ib2R5LnN0eWxlXG4gICAgdmFyIGJvZHlTdHlsZSA9IGRvY3VtZW50LmJvZHkuc3R5bGU7XG5cbiAgICAvLyBTbmlmZiBwcmVmaXhlc1xuICAgIHZhciB2ZW5kb3JQcmVmaXggPSAoJ1dlYmtpdFRyYW5zZm9ybScgaW4gYm9keVN0eWxlKSA/ICdXZWJraXQnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgKCdNb3pUcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkgPyAnTW96JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICgnbXNUcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkgPyAnbXMnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgKCdPVHJhbnNmb3JtJyBpbiBib2R5U3R5bGUpID8gJ08nIDogJyc7XG5cbiAgICBpZiAodmVuZG9yUHJlZml4ICsgJ1BlcnNwZWN0aXZlJyBpbiBib2R5U3R5bGUpIHtcbiAgICAgIC8vIE1vZGVybiBicm93c2VycyB3aXRoIDNEIHN1cHBvcnQsIGUuZy4gV2Via2l0LCBJRTEwXG4gICAgICByZXR1cm4gJ3RyYW5zbGF0ZTNkJztcbiAgICB9IGVsc2UgaWYgKHZlbmRvclByZWZpeCArICdUcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkge1xuICAgICAgLy8gQnJvd3NlcnMgd2l0aG91dCAzRCBzdXBwb3J0LCBlLmcuIElFOVxuICAgICAgcmV0dXJuICd0cmFuc2xhdGUnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCcm93c2VycyB3aXRob3V0IHRyYW5zbGF0ZSgpIHN1cHBvcnQsIGUuZy4gSUU3LThcbiAgICAgIHJldHVybiAnbWFyZ2luJztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhlbHBlcnNcbiAgICovXG5cbiAgZnVuY3Rpb24gY2xhbXAobiwgbWluLCBtYXgpIHtcbiAgICBpZiAobiA8IG1pbikgcmV0dXJuIG1pbjtcbiAgICBpZiAobiA+IG1heCkgcmV0dXJuIG1heDtcbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIGNvbnZlcnRzIGEgcGVyY2VudGFnZSAoYDAuLjFgKSB0byBhIGJhciB0cmFuc2xhdGVYXG4gICAqIHBlcmNlbnRhZ2UgKGAtMTAwJS4uMCVgKS5cbiAgICovXG5cbiAgZnVuY3Rpb24gdG9CYXJQZXJjKG4pIHtcbiAgICByZXR1cm4gKC0xICsgbikgKiAxMDA7XG4gIH1cblxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIHJldHVybnMgdGhlIGNvcnJlY3QgQ1NTIGZvciBjaGFuZ2luZyB0aGUgYmFyJ3NcbiAgICogcG9zaXRpb24gZ2l2ZW4gYW4gbiBwZXJjZW50YWdlLCBhbmQgc3BlZWQgYW5kIGVhc2UgZnJvbSBTZXR0aW5nc1xuICAgKi9cblxuICBmdW5jdGlvbiBiYXJQb3NpdGlvbkNTUyhuLCBzcGVlZCwgZWFzZSkge1xuICAgIHZhciBiYXJDU1M7XG5cbiAgICBpZiAoU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9PT0gJ3RyYW5zbGF0ZTNkJykge1xuICAgICAgYmFyQ1NTID0geyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgnK3RvQmFyUGVyYyhuKSsnJSwwLDApJyB9O1xuICAgIH0gZWxzZSBpZiAoU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9PT0gJ3RyYW5zbGF0ZScpIHtcbiAgICAgIGJhckNTUyA9IHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlKCcrdG9CYXJQZXJjKG4pKyclLDApJyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXJDU1MgPSB7ICdtYXJnaW4tbGVmdCc6IHRvQmFyUGVyYyhuKSsnJScgfTtcbiAgICB9XG5cbiAgICBiYXJDU1MudHJhbnNpdGlvbiA9ICdhbGwgJytzcGVlZCsnbXMgJytlYXNlO1xuXG4gICAgcmV0dXJuIGJhckNTUztcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIFF1ZXVlcyBhIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICAgKi9cblxuICB2YXIgcXVldWUgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHBlbmRpbmcgPSBbXTtcbiAgICBcbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgdmFyIGZuID0gcGVuZGluZy5zaGlmdCgpO1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIGZuKG5leHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihmbikge1xuICAgICAgcGVuZGluZy5wdXNoKGZuKTtcbiAgICAgIGlmIChwZW5kaW5nLmxlbmd0aCA9PSAxKSBuZXh0KCk7XG4gICAgfTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogKEludGVybmFsKSBBcHBsaWVzIGNzcyBwcm9wZXJ0aWVzIHRvIGFuIGVsZW1lbnQsIHNpbWlsYXIgdG8gdGhlIGpRdWVyeSBcbiAgICogY3NzIG1ldGhvZC5cbiAgICpcbiAgICogV2hpbGUgdGhpcyBoZWxwZXIgZG9lcyBhc3Npc3Qgd2l0aCB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHkgbmFtZXMsIGl0IFxuICAgKiBkb2VzIG5vdCBwZXJmb3JtIGFueSBtYW5pcHVsYXRpb24gb2YgdmFsdWVzIHByaW9yIHRvIHNldHRpbmcgc3R5bGVzLlxuICAgKi9cblxuICB2YXIgY3NzID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjc3NQcmVmaXhlcyA9IFsgJ1dlYmtpdCcsICdPJywgJ01veicsICdtcycgXSxcbiAgICAgICAgY3NzUHJvcHMgICAgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGNhbWVsQ2FzZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvXi1tcy0vLCAnbXMtJykucmVwbGFjZSgvLShbXFxkYS16XSkvZ2ksIGZ1bmN0aW9uKG1hdGNoLCBsZXR0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VmVuZG9yUHJvcChuYW1lKSB7XG4gICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuICAgICAgaWYgKG5hbWUgaW4gc3R5bGUpIHJldHVybiBuYW1lO1xuXG4gICAgICB2YXIgaSA9IGNzc1ByZWZpeGVzLmxlbmd0aCxcbiAgICAgICAgICBjYXBOYW1lID0gbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksXG4gICAgICAgICAgdmVuZG9yTmFtZTtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmVuZG9yTmFtZSA9IGNzc1ByZWZpeGVzW2ldICsgY2FwTmFtZTtcbiAgICAgICAgaWYgKHZlbmRvck5hbWUgaW4gc3R5bGUpIHJldHVybiB2ZW5kb3JOYW1lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdHlsZVByb3AobmFtZSkge1xuICAgICAgbmFtZSA9IGNhbWVsQ2FzZShuYW1lKTtcbiAgICAgIHJldHVybiBjc3NQcm9wc1tuYW1lXSB8fCAoY3NzUHJvcHNbbmFtZV0gPSBnZXRWZW5kb3JQcm9wKG5hbWUpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseUNzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgcHJvcCA9IGdldFN0eWxlUHJvcChwcm9wKTtcbiAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oZWxlbWVudCwgcHJvcGVydGllcykge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgcHJvcCwgXG4gICAgICAgICAgdmFsdWU7XG5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAyKSB7XG4gICAgICAgIGZvciAocHJvcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wZXJ0aWVzW3Byb3BdO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcCkpIGFwcGx5Q3NzKGVsZW1lbnQsIHByb3AsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwbHlDc3MoZWxlbWVudCwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICB9XG4gICAgfVxuICB9KSgpO1xuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIERldGVybWluZXMgaWYgYW4gZWxlbWVudCBvciBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBjbGFzcyBuYW1lcyBjb250YWlucyBhIGNsYXNzIG5hbWUuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIG5hbWUpIHtcbiAgICB2YXIgbGlzdCA9IHR5cGVvZiBlbGVtZW50ID09ICdzdHJpbmcnID8gZWxlbWVudCA6IGNsYXNzTGlzdChlbGVtZW50KTtcbiAgICByZXR1cm4gbGlzdC5pbmRleE9mKCcgJyArIG5hbWUgKyAnICcpID49IDA7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBBZGRzIGEgY2xhc3MgdG8gYW4gZWxlbWVudC5cbiAgICovXG5cbiAgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICAgIHZhciBvbGRMaXN0ID0gY2xhc3NMaXN0KGVsZW1lbnQpLFxuICAgICAgICBuZXdMaXN0ID0gb2xkTGlzdCArIG5hbWU7XG5cbiAgICBpZiAoaGFzQ2xhc3Mob2xkTGlzdCwgbmFtZSkpIHJldHVybjsgXG5cbiAgICAvLyBUcmltIHRoZSBvcGVuaW5nIHNwYWNlLlxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gbmV3TGlzdC5zdWJzdHJpbmcoMSk7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBSZW1vdmVzIGEgY2xhc3MgZnJvbSBhbiBlbGVtZW50LlxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBuYW1lKSB7XG4gICAgdmFyIG9sZExpc3QgPSBjbGFzc0xpc3QoZWxlbWVudCksXG4gICAgICAgIG5ld0xpc3Q7XG5cbiAgICBpZiAoIWhhc0NsYXNzKGVsZW1lbnQsIG5hbWUpKSByZXR1cm47XG5cbiAgICAvLyBSZXBsYWNlIHRoZSBjbGFzcyBuYW1lLlxuICAgIG5ld0xpc3QgPSBvbGRMaXN0LnJlcGxhY2UoJyAnICsgbmFtZSArICcgJywgJyAnKTtcblxuICAgIC8vIFRyaW0gdGhlIG9wZW5pbmcgYW5kIGNsb3Npbmcgc3BhY2VzLlxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gbmV3TGlzdC5zdWJzdHJpbmcoMSwgbmV3TGlzdC5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiAoSW50ZXJuYWwpIEdldHMgYSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiB0aGUgY2xhc3MgbmFtZXMgb24gdGhlIGVsZW1lbnQuIFxuICAgKiBUaGUgbGlzdCBpcyB3cmFwcGVkIHdpdGggYSBzaW5nbGUgc3BhY2Ugb24gZWFjaCBlbmQgdG8gZmFjaWxpdGF0ZSBmaW5kaW5nIFxuICAgKiBtYXRjaGVzIHdpdGhpbiB0aGUgbGlzdC5cbiAgICovXG5cbiAgZnVuY3Rpb24gY2xhc3NMaXN0KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gKCcgJyArIChlbGVtZW50LmNsYXNzTmFtZSB8fCAnJykgKyAnICcpLnJlcGxhY2UoL1xccysvZ2ksICcgJyk7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBSZW1vdmVzIGFuIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBlbGVtZW50ICYmIGVsZW1lbnQucGFyZW50Tm9kZSAmJiBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gTlByb2dyZXNzO1xufSk7XG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBLFdBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/nprogress/nprogress.js\n");

/***/ }),

/***/ 0:
/*!*************************!*\
  !*** multi ./js/app.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./js/app.js */"./js/app.js");


/***/ })

/******/ });